0000                          .ENGINE   mycomputer   
0000                             ; 
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $0800   
0000                ROMSIZE:   EQU   $0800   
0000                RAMSIZE:   EQU   $0800   
0000                EOF:      EQU   -1   
0000                NULL:     EQU   0   
0000                CTRL_C:   EQU   3   
0000                CTRL_H:   EQU   8   
0000                ESC:      EQU   27   
0000                NO_MATCH:   EQU   -1   
0000                BUFFER_SIZE:   EQU   $80   
0000                TOKENS:      
0000                COLON_:   EQU   ":"   
0000                COMMA_:   EQU   ","   
0000                DIRECT_:   EQU   "D"   
0000                DOLLAR_:   EQU   "$"   
0000                EOF_:     EQU   "E"   
0000                FLAG_:    EQU   "F"   
0000                IDENT_:   EQU   "I"   
0000                LABEL_:   EQU   "L"   
0000                LPAREN_:   EQU   "("   
0000                NEWLN_:   EQU   "\n"   
0000                NUM_:     EQU   "9"   
0000                OPCODE_:   EQU   "C"   
0000                REG_:     EQU   "R"   
0000                REGPAIR_:   EQU   "P"   
0000                RPAREN_:   EQU   ")"   
0000                UNKNOWN_:   EQU   "U"   
0000                ALU_CODE:   EQU   0x00   
0000                ROT_CODE:   EQU   0x20   
0000                BLI_CODE:   EQU   0x40   
0000                GEN1_CODE:   EQU   0x60   
0000                GEN2_CODE:   EQU   0x80   
0000                ALU_IDX:      
0000                ADD_:     EQU   0 | alu_code   
0000                ADC_:     EQU   1 | alu_code   
0000                SUB_:     EQU   2 | alu_code   
0000                SBC_:     EQU   3 | alu_code   
0000                AND_:     EQU   4 | alu_code   
0000                XOR_:     EQU   5 | alu_code   
0000                OR_:      EQU   6 | alu_code   
0000                CP_:      EQU   7 | alu_code   
0000                ROT_IDX:      
0000                RLC_:     EQU   0 | rot_code   
0000                RRC_:     EQU   1 | rot_code   
0000                RL_:      EQU   2 | rot_code   
0000                RR_:      EQU   3 | rot_code   
0000                SLA_:     EQU   4 | rot_code   
0000                SRA_:     EQU   5 | rot_code   
0000                SLL_:     EQU   6 | rot_code   
0000                SRL_:     EQU   7 | rot_code   
0000                BLI_IDX:      
0000                LDI_:     EQU   00 | bli_code   
0000                CPI_:     EQU   01 | bli_code   
0000                INI_:     EQU   02 | bli_code   
0000                OUTI_:    EQU   03 | bli_code   
0000                LDD_:     EQU   04 | bli_code   
0000                CPD_:     EQU   05 | bli_code   
0000                IND_:     EQU   06 | bli_code   
0000                OUTD_:    EQU   07 | bli_code   
0000                LDIR_:    EQU   08 | bli_code   
0000                CPIR_:    EQU   09 | bli_code   
0000                INIR_:    EQU   10 | bli_code   
0000                OTIR_:    EQU   11 | bli_code   
0000                LDDR_:    EQU   12 | bli_code   
0000                CPDR_:    EQU   13 | bli_code   
0000                INDR_:    EQU   14 | bli_code   
0000                OTDR_:    EQU   15 | bli_code   
0000                GEN1_IDX:      
0000                CCF_:     EQU   00  | gen1_code   
0000                CPL_:     EQU   01  | gen1_code   
0000                DAA_:     EQU   02  | gen1_code   
0000                DI_:      EQU   03  | gen1_code   
0000                EI_:      EQU   04  | gen1_code   
0000                HALT_:    EQU   05  | gen1_code   
0000                NOP_:     EQU   06  | gen1_code   
0000                RLCA_:    EQU   07  | gen1_code   
0000                RST_:     EQU   08  | gen2_code   
0000                SCF_:     EQU   09  | gen1_code   
0000                GEN2_IDX:      
0000                BIT_:     EQU   00  | gen2_code   
0000                CALL_:    EQU   01  | gen2_code   
0000                DEC_:     EQU   02  | gen2_code   
0000                DJNZ_:    EQU   03  | gen2_code   
0000                EX_:      EQU   04  | gen2_code   
0000                EXX_:     EQU   05  | gen2_code   
0000                IM_:      EQU   06  | gen2_code   
0000                IN_:      EQU   07  | gen2_code   
0000                INC_:     EQU   08  | gen2_code   
0000                JP_:      EQU   09  | gen2_code   
0000                JR_:      EQU   10  | gen2_code   
0000                LD_:      EQU   11  | gen2_code   
0000                NEG_:     EQU   12  | gen2_code   
0000                OUT_:     EQU   13  | gen2_code   
0000                POP_:     EQU   14  | gen2_code   
0000                PUSH_:    EQU   15  | gen2_code   
0000                RES_:     EQU   16  | gen2_code   
0000                RET_:     EQU   17  | gen2_code   
0000                RETI_:    EQU   18  | gen2_code   
0000                RETN_:    EQU   19  | gen2_code   
0000                RLA_:     EQU   20  | gen2_code   
0000                RLD_:     EQU   21  | gen2_code   
0000                RRA_:     EQU   22  | gen2_code   
0000                RRCA_:    EQU   23  | gen2_code   
0000                RRD_:     EQU   24  | gen2_code   
0000                SET_:     EQU   25  | gen2_code   
0000                FLAG_CODE:   EQU   0x08   ; NZ etc
0000                REG_CODE:   EQU   0x10   ; A, B etc
0000                IMMED_CODE:   EQU   0x18   ; 0xff or 0xffff
0000                I16_CODE:   EQU   0x20   ; 8-bit or 16-bit e.g. A or HL, 0xff or 0xffff
0000                MEM_CODE:   EQU   0x40   ; (HL) or (0xffff)
0000                NA_CODE:   EQU   0x80   ; n/a high 7th bit means no operand (can use -1)
0000                REG8_IDX:      ; 8-bit registers
0000                B_:       EQU   0   ; B
0000                C_:       EQU   1   ; C
0000                D_:       EQU   2   ; D
0000                E_:       EQU   3   ; E
0000                H_:       EQU   4   ; H
0000                L_:       EQU   5   ; L
0000                MHL_:     EQU   6   ; (HL)
0000                A_:       EQU   7   ; A
0000                I_:       EQU   8   ; I
0000                R_:       EQU   9   ; R
0000                REG16_IDX:      ; 16-bit registers
0000                BC_:      EQU   0   
0000                DE_:      EQU   1   
0000                HL_:      EQU   2   
0000                SP_:      EQU   3   
0000                IX_:      EQU   5   
0000                IY_:      EQU   6   
0000                AFP_:     EQU   4   ; AF' (prime)
0000                AF_:      EQU   7   ; NOTE: AF has the same code as SP in some instructions
0000                FLAG_IDX:      
0000                NZ_:      EQU   0   
0000                Z_:       EQU   1   
0000                NC_:      EQU   2   
0000                C_:       EQU   3   
0000                PO_:      EQU   4   
0000                PE_:      EQU   5   
0000                P_:       EQU   6   
0000                M_:       EQU   7   
0000                DIRECTIVE_IDX:      
0000                ALIGN_:   EQU   0   
0000                DB_:      EQU   1   
0000                ORG_:     EQU   2   
0000                SET_:     EQU   3   
0000                             ; -----------------------------------------------------------------------------------------------
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                             ; *************************************************************************
0000                             ; 
0000                             ;       Serial routines 
0000                             ; 
0000                             ;       written by Craig Jones 
0000                             ; 
0000                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
0000                             ; 
0000                             ;       see the LICENSE file in this repo for more information 
0000                             ; 
0000                             ; *****************************************************************************
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8D 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 80 09               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 82 09               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 84 09               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A 86 09               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A 88 09               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A 8A 09               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A 8E 09               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A 90 09               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   E5                     PUSH   HL   
0082   2A 92 09               LD   HL,(GETCVEC)   
0085   E3                     EX   (SP),HL   
0086   C9                     RET      
0087                             ; 
0087                PUTCHAR:      
0087   E5                     PUSH   HL   
0088   2A 94 09               LD   HL,(PUTCVEC)   
008B   E3                     EX   (SP),HL   
008C   C9                     RET      
008D                             ; 
008D                RESET:       
008D   31 80 09               LD   SP,stack   
0090   21 5F 00               LD   HL,IntRet   
0093   22 80 09               LD   (RST08),HL   
0096   22 82 09               LD   (RST10),HL   
0099   22 84 09               LD   (RST18),HL   
009C   22 86 09               LD   (RST20),HL   
009F   22 88 09               LD   (RST28),HL   
00A2   22 8A 09               LD   (RST30),HL   
00A5   22 8E 09               LD   (INTVEC),HL   
00A8   22 90 09               LD   (NMIVEC),HL   
00AB                             ; 
00AB   21 78 00               LD   HL,RXDATA   
00AE   22 92 09               LD   (GETCVEC),HL   
00B1   21 6B 00               LD   HL,TXDATA   
00B4   22 94 09               LD   (PUTCVEC),HL   
00B7                             ; 
00B7                          IF   TEC_1   
00B7                          IF   BITBANG = 0   
00B7                             ; 
00B7   3E 03                  LD   a,MRESET   
00B9   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00BB                             ; 
00BB                          ENDIF      
00BB                          ENDIF      
00BB                             ; 
00BB   CD 50 00               CALL   PWRUP   
00BE   ED 56                  IM   1   
00C0   FB                     EI      
00C1                             ; 
00C1                          IF   TEC_1   
00C1                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00C1                          ELSE      ;6850      
00C1                             ; 
00C1   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C3   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C5                             ; 
00C5                          ENDIF      
00C5                          ENDIF      
00C5                             ; 
00C5                             ; 
00C5                             ; 
00C5   C3 80 01               JP   start   
00C8                             ; 
00C8                             ; *************************************************************************
00C8                             ; 
00C8                             ;       TecM8 1.0 Assembler for the Tec-1
00C8                             ; 
00C8                             ;       by John Hardy
00C8                             ; 
00C8                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
00C8                             ; 
00C8                             ;       see the LICENSE file in this repo for more information
00C8                             ; 
00C8                             ; *****************************************************************************
00C8                             ; **************************************************************************
00C8                             ; Page 0  Initialisation
00C8                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put TecM8 code from here	
0180                             ; *****************************************************************************
0180                             ; Routine: start
0180                             ; 
0180                             ; Purpose:
0180                             ;    Entry point of TecM8. Initializes the STACK pointer, calls the initialization
0180                             ;    routine, prints TecM8 version information, and jumps to the parsing routine.
0180                             ; 
0180                             ; Inputs:
0180                             ;    None
0180                             ; 
0180                             ; Outputs:
0180                             ;    None
0180                             ; 
0180                             ; Registers Destroyed:
0180                             ;    A, HL
0180                             ; *****************************************************************************
0180                START:       
0180   31 80 09               LD   sp,STACK   ; Initialize STACK pointer
0183   CD 98 01               CALL   init   ; Call initialization routine
0186   CD F9 04               CALL   print   ; Print TecM8 version information
0189   54 65 63 4D 38 20 30 2E 30 0D 0A 00 .CSTR   "TecM8 0.0\r\n"   
0195   C3 C0 01               JP   parse   ; Jump to the parsing routine
0198                             ; *****************************************************************************
0198                             ; Routine: init
0198                             ; 
0198                             ; Purpose:
0198                             ;    Initializes various pointers and variables used by TecM8.
0198                             ; 
0198                             ; Inputs:
0198                             ;    None
0198                             ; 
0198                             ; Outputs:
0198                             ;    None
0198                             ; 
0198                             ; Registers Destroyed:
0198                             ;    A, HL
0198                             ; *****************************************************************************
0198                INIT:        
0198   AF                     XOR   a   ; Clear A register
0199   32 9A 09               LD   (vToken),a   ; Initialize vToken with NUL_ token
019C   32 9D 09               LD   (vBufferPos),a   ; Initialize BUFFER position
019F   3E 0A                  LD   a,"\n"   ; put new line into first char of buffer
01A1   32 00 08               LD   (BUFFER),a   ; 
01A4   21 A7 0C               LD   hl,ASSEMBLY   ; Load ASSEMBLY pointer
01A7   22 9F 09               LD   (vAsmPtr),hl   ; Store in vAsmPtr
01AA   21 A7 09               LD   hl,STRINGS   ; Load STRINGS pointer
01AD   22 A1 09               LD   (vStrPtr),hl   ; Store in vStrPtr
01B0   22 9B 09               LD   (vTokenVal),hl   ; Initialize token value pointer
01B3   21 A7 0A               LD   hl,SYMBOLS   ; Load SYMBOLS pointer
01B6   22 A3 09               LD   (vSymPtr),hl   ; Store in vSymPtr
01B9   21 A7 0B               LD   hl,EXPRS   ; Load expressions pointer
01BC   22 A5 09               LD   (vExprPtr),hl   ; Store in vExprPtr
01BF   C9                     RET      ; Return
01C0                             ; *****************************************************************************
01C0                             ; Routine: parse
01C0                             ; 
01C0                             ; Purpose:
01C0                             ;    Parses the input program, calling the statementList routine, printing the
01C0                             ;    completion message, and halting the system.
01C0                             ; 
01C0                             ; Inputs:
01C0                             ;    None
01C0                             ; 
01C0                             ; Outputs:
01C0                             ;    None
01C0                             ; 
01C0                             ; Registers Destroyed:
01C0                             ;    None
01C0                             ; *****************************************************************************
01C0                PARSE:       
01C0   CD E7 01               CALL   statementList   ; Parse the input program
01C3   CD F9 04               CALL   print   ; Print completion message
01C6   50 61 72 73 69 6E 67 20 63 6F 6D 70 6C 65 74 65 64 20 73 75 63 63 65 73 73 66 75 6C 6C 79 2E 00 .CSTR   "Parsing completed successfully."   
01E6   76                     HALT      ; Halt the system
01E7                             ; *****************************************************************************
01E7                             ; Routine: statementList
01E7                             ; 
01E7                             ; Purpose:
01E7                             ;    Parses a list of statements, repeatedly calling the statement routine until
01E7                             ;    the end of file (EOF) token is encountered.
01E7                             ; 
01E7                             ; Inputs:
01E7                             ;    None
01E7                             ; 
01E7                             ; Outputs:
01E7                             ;    None
01E7                             ; 
01E7                             ; Registers Destroyed:
01E7                             ;    A
01E7                             ; *****************************************************************************
01E7                STATEMENTLIST:      
01E7   CD 24 02               CALL   nextToken   ; Get the next token
01EA   FE 45                  CP   EOF_   ; Check if it's the end of file
01EC   C8                     RET   z   ; If yes, return
01ED   CD F2 01               CALL   statement   ; Parse a statement
01F0   18 F5                  JR   statementList   ; Repeat for the next statement
01F2                             ; *****************************************************************************
01F2                             ; Routine: statement
01F2                             ; 
01F2                             ; Purpose:
01F2                             ;    Parses a single statement, checking its type (label, opcode, or directive)
01F2                             ;    and performing corresponding actions.
01F2                             ; 
01F2                             ; Inputs:
01F2                             ;    None
01F2                             ; 
01F2                             ; Outputs:
01F2                             ;    None
01F2                             ; 
01F2                             ; Registers Destroyed:
01F2                             ;    A
01F2                             ; *****************************************************************************
01F2                STATEMENT:      
01F2                             ; setOpcode null
01F2                             ; setOperand1 null
01F2                             ; setOperand2 null
01F2   FE 4C                  CP   LABEL_   ; Check if it's a label
01F4   20 03                  JR   nz,statement10   ; If not, jump to statement10
01F6                             ; call addLabel            ; Add label to symbol table
01F6   CD 24 02               CALL   nextToken   ; Get the next token
01F9                STATEMENT10:      
01F9   FE 43                  CP   OPCODE_   ; Check if it's an opcode
01FB   20 00                  JR   nz,statement1   
01FD                             ; call instruction      ; Jump to parseInstruction routine
01FD                             ; call nextToken
01FD                             ; jr statement2
01FD                STATEMENT1:      
01FD   FE 44                  CP   DIRECT_   ; Check if it's a directive
01FF   20 00                  JR   nz,statement2   
0201                             ; jp directive        ; Jump to parseDirective routine
0201                             ; call nextToken
0201                STATEMENT2:      
0201   FE 0A                  CP   NEWLN_   
0203   C8                     RET   z   
0204   FE 45                  CP   EOF_   
0206   C8                     RET   z   
0207                             ; throw error, expected NEWLN or EOF
0207   C9                     RET      
0208                INSTRUCTION:      
0208                             ; check if Opcode has been set
0208                             ; setOpcode a
0208   CD 24 02               CALL   nextToken   
020B   FE 0A                  CP   NEWLN_   
020D   28 04                  JR   z,instruction1   
020F   FE 45                  CP   EOF_   
0211   28 03                  JR   z,instruction2   
0213                INSTRUCTION1:      
0213   CD 45 03               CALL   pushBackToken   
0216                INSTRUCTION2:      
0216   CD 24 02               CALL   firstOperand   
0219   CD 24 02               CALL   nextToken   
021C   FE 2C                  CP   COMMA_   
021E   CD 24 02               CALL   nextToken   
0221   CD 24 02               CALL   secondOperand   
0224                FIRSTOPERAND:      
0224                SECONDOPERAND:      
0224                DIRECTIVE:      
0224                             ; nextToken is a lexer function that reads characters from the input and classifies
0224                             ; them into different token types. It handles whitespace, end of input, newlines,
0224                             ; comments, identifiers, labels, directives, hexadecimal numbers, and other SYMBOLS.
0224                             ; Input: None
0224                             ; Output:
0224                             ; a: contains the type of the next token.
0224                             ; hl: contains the value associated with the next token.
0224                             ; Destroyed: None
0224                             ; *****************************************************************************
0224                             ; Routine: nextToken
0224                             ; 
0224                             ; Purpose:
0224                             ;    Parses the next token from the input stream, identifying various types of
0224                             ;    tokens such as identifiers, labels, opcodes, registers, flags, numbers,
0224                             ;    and special characters.
0224                             ; 
0224                             ; Inputs:
0224                             ;    None
0224                             ; 
0224                             ; Outputs:
0224                             ;    A - Token representing the type of the parsed element
0224                             ; 
0224                             ; Registers Destroyed:
0224                             ;    A, BC, DE, HL
0224                             ; *****************************************************************************
0224                NEXTTOKEN:      
0224   CB 77                  BIT   7,(vToken)   ; Check the high bit of the pushback BUFFER
0226   CA 35 02               JP   z,nextToken0   ; If high bit clear, nothing pushed back
0229   3A 9A 09               LD   a,(vToken)   ; If high bit set, load the pushed back token type into A
022C   2A 9B 09               LD   hl,(vTokenVal)   ; and token value into HL
022F   CB BF                  RES   7,a   ; Clear the high bit
0231   32 9A 09               LD   (vToken),a   ; Store the character back in the BUFFER
0234   C9                     RET      ; Return with the pushed back character in A
0235                NEXTTOKEN0:      
0235   21 00 00               LD   hl,0   ; Initialize HL with 0
0238                NEXTTOKEN1:      
0238   CD 77 04               CALL   nextChar   ; Get the next character
023B   FE 20                  CP   " "   ; is it space?
023D   28 F9                  JR   z,nextToken1   ; If yes, skip it and get the next character
023F   FE FF                  CP   EOF   ; Is it null (end of input)?
0241   28 04                  JR   z,nextToken1a   
0243   FE 03                  CP   CTRL_C   ; end of text
0245   20 03                  JR   nz,nextToken2   ; If not, continue to the next check
0247                NEXTTOKEN1A:      
0247   3E 45                  LD   a,EOF_   ; If yes, return with EOF token
0249   C9                     RET      
024A                NEXTTOKEN2:      
024A   FE 5C                  CP   $5C   ; Is it a statement separator? "\"
024C   20 0B                  JR   nz,nextToken3   ; If not, continue to the next check
024E   FE 3A                  CP   ":"   ; Is it a statement separator? ":"
0250   20 07                  JR   nz,nextToken3   ; If not, continue to the next check
0252   FE 0A                  CP   "\n"   ; Is it a control char
0254   30 03                  JR   nc,nextToken3   ; If not, continue to the next check
0256   3E 0A                  LD   a,NEWLN_   ; If yes, return with NEWLIN token
0258   C9                     RET      ; Return with newline token
0259                NEXTTOKEN3:      
0259   FE 3B                  CP   ";"   ; Is it a comment?
025B   C4 6A 02               CALL   nz,nextToken5   ; If not, continue to the next check
025E                NEXTTOKEN4:      
025E   CD 77 04               CALL   nextChar   ; Get the next character in the comment
0261   FE 21                  CP   " "+1   ; Loop until the next control character
0263   30 F9                  JR   nc,nextToken4   
0265   CD DC 04               CALL   rewindChar   ; Push back the character
0268   18 CB                  JR   nextToken0   ; return with control char
026A                NEXTTOKEN5:      
026A   FE 5F                  CP   "_"   ; Is it an identifier?
026C   28 05                  JR   z,nextToken6   ; If yes, continue to the next check
026E   CD BA 03               CALL   isAlpha   ; If not, check if it's alphabetic
0271   30 47                  JR   nc,nextToken13   ; If not, continue to the next check
0273                NEXTTOKEN6:      
0273   CD 4E 03               CALL   ident   ; Parse the identifier
0276   FE 3A                  CP   ":"   ; Is it a label?
0278   20 03                  JR   nz,nextToken7   ; If not, continue to the next check
027A   3E 4C                  LD   a,LABEL_   ; If yes, return with LABEL token
027C   C9                     RET      
027D                NEXTTOKEN7:      
027D   CD DC 04               CALL   rewindChar   ; Push back the character
0280   22 A1 09               LD   (vStrPtr),hl   ; Restore string heap pointer to previous location
0283   CD EB 02               CALL   searchOpcode   
0286   30 03                  JR   nc,nextToken8   
0288   3E 43                  LD   a,OPCODE_   ; Return with OPCODE token
028A   C9                     RET      
028B                NEXTTOKEN8:      
028B   11 48 06               LD   de,reg16   ; List of register pairs to search
028E   CD 49 04               CALL   searchStr   
0291   30 03                  JR   nc,nextToken9   
0293   3E 50                  LD   a,REGPAIR_   ; Return with REGPAIR token
0295   C9                     RET      
0296                NEXTTOKEN9:      
0296   11 33 06               LD   de,reg8   ; List of registers to search
0299   CD 49 04               CALL   searchStr   
029C   30 03                  JR   nc,nextToken10   
029E   3E 52                  LD   a,REG_   ; Return with REG token
02A0   C9                     RET      
02A1                NEXTTOKEN10:      
02A1   11 62 06               LD   de,flags   ; List of flags to search
02A4   CD 49 04               CALL   searchStr   
02A7   30 03                  JR   nc,nextToken11   
02A9   3E 46                  LD   a,FLAG_   ; Return with FLAG token
02AB   C9                     RET      
02AC                NEXTTOKEN11:      
02AC   11 62 06               LD   de,flags   ; List of flags to search
02AF   CD 49 04               CALL   searchStr   
02B2   30 03                  JR   nc,nextToken12   
02B4   3E 44                  LD   a,DIRECT_   ; Return with DIRECT token
02B6   C9                     RET      
02B7                NEXTTOKEN12:      
02B7   3E 49                  LD   a,IDENT_   ; Return with IDENT token
02B9   C9                     RET      
02BA                NEXTTOKEN13:      
02BA   21 00 00               LD   hl,0   
02BD   FE 24                  CP   "$"   ; Is it a hexadecimal number?
02BF   20 0F                  JR   nz,nextToken14   ; If not, continue to the next check
02C1   CD 77 04               CALL   nextChar   ; Get the next character
02C4   CD B0 03               CALL   isSpace   ; Check if it's the ASSEMBLY pointer
02C7   CD DC 04               CALL   rewindChar   ; Push back the character (flags unaffected)
02CA   C8                     RET   z   ; Return with the ASSEMBLY pointer token
02CB   CD FA 03               CALL   number_hex   ; Process hexadecimal number
02CE   18 0C                  JR   nextToken16   
02D0                NEXTTOKEN14:      
02D0   FE 2D                  CP   "-"   ; Is it a negative number?
02D2   28 05                  JR   z,nextToken15   ; If yes, continue to the next check
02D4   CD C7 03               CALL   isDigit   ; Check if it's a digit
02D7   30 06                  JR   nc,nextToken17   ; Jump to the next check
02D9                NEXTTOKEN15:      
02D9   CD CE 03               CALL   number   ; Parse the number
02DC                NEXTTOKEN16:      
02DC   3E 39                  LD   a,NUM_   ; Return with NUM token
02DE   C9                     RET      
02DF                NEXTTOKEN17:      
02DF   FE 28                  CP   "("   
02E1   C8                     RET   z   ; Return with the "(" token
02E2   FE 29                  CP   ")"   
02E4   C8                     RET   z   ; Return with the ")" token
02E5   FE 2C                  CP   ","   
02E7   C8                     RET   z   ; Return with the "," token
02E8   3E 55                  LD   a,UNKNOWN_   ; Return with UNKNOWN token
02EA   C9                     RET      
02EB                             ; *****************************************************************************
02EB                             ; Routine: searchOpcode
02EB                             ; 
02EB                             ; Purpose:
02EB                             ;    Searches for a matching opcode in various lists of opcodes.
02EB                             ; 
02EB                             ; Inputs:
02EB                             ;    HL - Points to the string to search for.
02EB                             ; 
02EB                             ; Outputs:
02EB                             ;    CF - Set if a match is found, cleared otherwise.
02EB                             ;    A  - Contains the index of the matching opcode if a match is found,
02EB                             ;         or the last checked index if no match is found.
02EB                             ; 
02EB                             ; Registers Destroyed:
02EB                             ;    A, DE, F
02EB                             ; *****************************************************************************
02EB                SEARCHOPCODE:      
02EB   11 37 05               LD   de,alu_opcodes   ; Point DE to the list of ALU opcodes
02EE   CD 49 04               CALL   searchStr   ; Call searchStr to search for the string in ALU opcodes
02F1   D8                     RET   c   ; If carry flag is set, return (match found)
02F2   11 18 05               LD   de,rot_opcodes   ; Point DE to the list of ROT opcodes
02F5   CD 49 04               CALL   searchStr   ; Call searchStr to search for the string in ROT opcodes
02F8   CB 6F                  BIT   5,a   ; Or 0x20 with register A (flags unaffected)
02FA   D8                     RET   c   ; If carry flag is set, return (match found)
02FB   11 56 05               LD   de,bli_opcodes   ; Point DE to the list of ROT opcodes
02FE   CD 49 04               CALL   searchStr   ; Call searchStr to search for the string in ROT opcodes
0301   CB 77                  BIT   6,a   ; Or 0x40 with register A (flags unaffected)
0303   D8                     RET   c   ; If carry flag is set, return (match found)
0304   11 A1 05               LD   de,gen1_opcodes   ; Point DE to the list of ROT opcodes
0307   CD 49 04               CALL   searchStr   ; Call searchStr to search for the string in ROT opcodes
030A   CB 6F                  BIT   5,a   ; Or 0x60 with register A (flags unaffected)
030C   CB 77                  BIT   6,a   
030E   D8                     RET   c   ; If carry flag is set, return (match found)
030F   11 CA 05               LD   de,gen2_opcodes   ; Point DE to the list of general opcodes
0312   CD 49 04               CALL   searchStr   ; Call searchStr to search for the string in general opcodes
0315   CB 7F                  BIT   7,a   ; Or 0x80 with register A (flags unaffected)
0317   C9                     RET      
0318                SEARCHOPERAND:      
0318   11 37 05               LD   de,alu_opcodes   ; Point DE to the list of ALU opcodes
031B   CD 49 04               CALL   searchStr   ; Call searchStr to search for the string in ALU opcodes
031E   D8                     RET   c   ; If carry flag is set, return (match found)
031F   11 18 05               LD   de,rot_opcodes   ; Point DE to the list of ROT opcodes
0322   CD 49 04               CALL   searchStr   ; Call searchStr to search for the string in ROT opcodes
0325   CB 6F                  BIT   5,a   ; Or 0x20 with register A (flags unaffected)
0327   D8                     RET   c   ; If carry flag is set, return (match found)
0328   11 56 05               LD   de,bli_opcodes   ; Point DE to the list of ROT opcodes
032B   CD 49 04               CALL   searchStr   ; Call searchStr to search for the string in ROT opcodes
032E   CB 77                  BIT   6,a   ; Or 0x40 with register A (flags unaffected)
0330   D8                     RET   c   ; If carry flag is set, return (match found)
0331   11 A1 05               LD   de,gen1_opcodes   ; Point DE to the list of ROT opcodes
0334   CD 49 04               CALL   searchStr   ; Call searchStr to search for the string in ROT opcodes
0337   CB 6F                  BIT   5,a   ; Or 0x60 with register A (flags unaffected)
0339   CB 77                  BIT   6,a   
033B   D8                     RET   c   ; If carry flag is set, return (match found)
033C   11 CA 05               LD   de,gen2_opcodes   ; Point DE to the list of general opcodes
033F   CD 49 04               CALL   searchStr   ; Call searchStr to search for the string in general opcodes
0342   CB 7F                  BIT   7,a   ; Or 0x80 with register A (flags unaffected)
0344   C9                     RET      
0345                             ; *****************************************************************************
0345                             ; Routine: pushBackToken
0345                             ; 
0345                             ; Purpose:
0345                             ;    Pushes back a token into the pushback BUFFER to allow the token to be
0345                             ;    re-read by the nextToken routine.
0345                             ; 
0345                             ; Inputs:
0345                             ;    A  - token type
0345                             ;    HL - token value
0345                             ; 
0345                             ; Outputs:
0345                             ;    None
0345                             ; 
0345                             ; Registers Destroyed:
0345                             ;    A, DE
0345                             ; *****************************************************************************
0345                PUSHBACKTOKEN:      
0345   CB FF                  SET   7,a   ; Set the high bit of the token type (without affecting flags)
0347   32 9A 09               LD   (vToken),a   ; push back the token
034A   22 9B 09               LD   (vTokenVal),hl   ; push back the token value
034D   C9                     RET      
034E                             ; *****************************************************************************
034E                             ; Routine: ident
034E                             ; 
034E                             ; Purpose:
034E                             ;    Reads characters from the input stream until a charcter which is not an
034E                             ;    an underscore or an alphanumeric character is encountered. Writes the chars
034E                             ;    to a Pascal string and updates the top of the STRINGS heap pointer.
034E                             ;    It also calculates the length of the string and stores it at the beginning
034E                             ;    of the string.
034E                             ; 
034E                             ; Inputs:
034E                             ;    A - Current character read from the input stream
034E                             ;    vStrPtr - Address of the top of STRINGS heap pointer
034E                             ; 
034E                             ; Outputs:
034E                             ;    A - last character read from the input stream
034E                             ; 
034E                             ; Registers Destroyed:
034E                             ;    DE, HL
034E                             ; *****************************************************************************
034E                IDENT:       
034E   2A A1 09               LD   hl,(vStrPtr)   ; Load the address of the top of STRINGS heap
0351   54 5D                  LD   de,hl   ; Copy it to DE (DE = HL = top of STRINGS heap)
0353   23                     INC   hl   ; Move to the next byte to skip the length byte
0354                IDENT1:      
0354   77                     LD   (hl),a   ; Write the current character to the string BUFFER
0355   23                     INC   hl   ; Move to the next position in the BUFFER
0356   CD 77 04               CALL   nextChar   ; Get the next character from the input stream
0359   FE 5F                  CP   "_"   ; Compare with underscore character
035B   28 05                  JR   z,ident2   ; If underscore, jump to ident2
035D   CD B6 03               CALL   isAlphanum   ; Check if the character is alphanumeric
0360   30 04                  JR   nc,ident3   ; If not alphanumeric, jump to ident3
0362                IDENT2:      
0362   77                     LD   (hl),a   ; Write the current character to the string BUFFER
0363   23                     INC   hl   ; Move to the next position in the BUFFER
0364   18 EE                  JR   ident1   ; Repeat the process
0366                IDENT3:      
0366   22 A1 09               LD   (vStrPtr),hl   ; Update the top of STRINGS heap pointer
0369   B7                     OR   a   ; Clear carry
036A   ED 52                  SBC   hl,de   ; Calculate the length of the string (HL = length, DE = string)
036C   EB                     EX   de,hl   ; Swap DE and HL (E = length, HL = string)
036D   73                     LD   (hl),e   ; Store the length at the beginning of the string BUFFER
036E   C9                     RET      
036F                             ; *****************************************************************************
036F                             ; Routine: expr
036F                             ; 
036F                             ; Purpose:
036F                             ;    Collects a string until it reaches a right parenthesis, comma, semicolon,
036F                             ;    or newline character. Keeps track of parentheses to ensure correct ending
036F                             ;    of the expression.
036F                             ; 
036F                             ; Inputs:
036F                             ;    None
036F                             ; 
036F                             ; Outputs:
036F                             ;    HL - Points to the collected string.
036F                             ;    A - Contains the length of the collected string.
036F                             ; 
036F                             ; Registers Destroyed:
036F                             ;    A, C, D, E, HL
036F                             ; *****************************************************************************
036F                EXPR:        
036F   2A A1 09               LD   hl,(vStrPtr)   ; Load the address of the top of STRINGS heap
0372   54 5D                  LD   de,hl   ; Copy it to DE (DE = HL = top of STRINGS heap)
0374   23                     INC   hl   ; Move to the next byte to skip the length byte
0375   0E 01                  LD   c,1   ; Initialize parenthesis count to 1
0377                EXPR1:       
0377   77                     LD   (hl),a   ; Write the current character to the string BUFFER
0378   23                     INC   hl   ; Move to the next position in the BUFFER
0379   CD 77 04               CALL   nextChar   ; Get the next character from the input stream
037C   FE 28                  CP   "("   ; Compare with left parenthesis character
037E   28 17                  JR   z,expr2   ; If left parenthesis, increase count
0380   FE 29                  CP   ")"   ; Compare with right parenthesis character
0382   28 16                  JR   z,expr3   ; If right parenthesis, decrease count
0384   FE 2C                  CP   ","   ; Compare with comma character
0386   28 17                  JR   z,expr4   ; If comma, check if parentheses count is zero
0388   FE 3B                  CP   ";"   ; Compare with semicolon character
038A   28 13                  JR   z,expr4   ; If semicolon, check if parentheses count is zero
038C   FE 0A                  CP   "\n"   ; Compare with newline character
038E   28 0F                  JR   z,expr4   ; If newline, check if parentheses count is zero
0390   CD B6 03               CALL   isAlphanum   ; Check if the character is alphanumeric
0393   30 0A                  JR   nc,expr4   ; If not alphanumeric, check if parentheses count is zero
0395   18 E0                  JR   expr1   ; Repeat the process
0397                EXPR2:       
0397   0C                     INC   c   ; Increase parentheses count
0398   18 DD                  JR   expr1   ; Repeat the process
039A                EXPR3:       
039A   0D                     DEC   c   ; Decrease parentheses count
039B   20 DA                  JR   nz,expr1   ; If not zero, continue collecting
039D   18 04                  JR   expr5   ; If zero, end collection
039F                EXPR4:       
039F   AF                     XOR   a   
03A0   B9                     CP   c   ; Check if parentheses count is zero
03A1   20 D4                  JR   nz,expr1   ; If not zero, continue collecting
03A3                EXPR5:       
03A3   CD DC 04               CALL   rewindChar   ; Rewind the input stream by one character
03A6   22 A1 09               LD   (vStrPtr),hl   ; Update the top of STRINGS heap pointer
03A9   B7                     OR   a   ; Clear A register
03AA   ED 52                  SBC   hl,de   ; Calculate the length of the string (HL = length, DE = string)
03AC   EB                     EX   de,hl   ; Swap DE and HL (E = length, HL = string)
03AD   73                     LD   (hl),e   ; Store the length at the beginning of the string BUFFER
03AE   7B                     LD   a,e   ; Load the length into A
03AF   C9                     RET      
03B0                             ; *****************************************************************************
03B0                             ; Routine: isSpace
03B0                             ; 
03B0                             ; Purpose:
03B0                             ;    Checks if the character in the A register is a space or tab character.
03B0                             ; 
03B0                             ; Input:
03B0                             ;    A - Contains the character to be checked.
03B0                             ; 
03B0                             ; Output:
03B0                             ;    A - Contains the character to be checked.
03B0                             ;    CF - Set if the input character was space or tab, cleared otherwise.
03B0                             ; 
03B0                             ; Destroyed:
03B0                             ;    None
03B0                             ; *****************************************************************************
03B0                ISSPACE:      
03B0   FE 20                  CP   " "   ; Compare with space character
03B2   C8                     RET   z   ; Return if it's space
03B3   FE 09                  CP   "\t"   ; Compare with tab character
03B5   C9                     RET      ; Return
03B6                             ; *****************************************************************************
03B6                             ; Routine: isAlphaNum
03B6                             ; 
03B6                             ; Purpose:
03B6                             ;    Checks if the character in the A register is an alphanumeric character
03B6                             ;    (either uppercase or lowercase). If the character is alphabetic, it converts
03B6                             ;    it to uppercase and sets the carry flag. If the character is not alphabetic,
03B6                             ;    it clears the carry flag.
03B6                             ; 
03B6                             ; Input:
03B6                             ;    A - Contains the character to be checked.
03B6                             ; 
03B6                             ; Output:
03B6                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
03B6                             ;    CF - Set if the input character was alphabetic, cleared otherwise.
03B6                             ; 
03B6                             ; Destroyed:
03B6                             ;    C
03B6                             ; *****************************************************************************
03B6                ISALPHANUM:      
03B6   CD C7 03               CALL   isDigit   ; Check if it's a digit
03B9   C8                     RET   z   ; If it's not a digit, continue to isAlpha
03BA                             ; Falls through to isAlpha
03BA                             ; *****************************************************************************
03BA                             ; Routine: isAlpha
03BA                             ; 
03BA                             ; Purpose:
03BA                             ;    Checks if the character in the A register is an alphabetic character
03BA                             ;    (either uppercase or lowercase). If the character is alphabetic, it converts
03BA                             ;    it to uppercase and sets the carry flag.
03BA                             ; 
03BA                             ; Input:
03BA                             ;    A - Contains the character to be checked.
03BA                             ; 
03BA                             ; Output:
03BA                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
03BA                             ;    CF - Set if the input character was alphabetic, cleared otherwise.
03BA                             ; 
03BA                             ; Destroyed:
03BA                             ;    None
03BA                             ; *****************************************************************************
03BA                ISALPHA:      
03BA   FE 61                  CP   "a"   ; Compare with lowercase "a"
03BC   38 02                  JR   c,isAlpha1   ; Jump if it"s lower than "a'
03BE   D6 20                  SUB   $20   ; Convert lowercase to uppercase
03C0                ISALPHA1:      
03C0   FE 5B                  CP   "Z"+1   ; Compare with "Z" + 1
03C2   D0                     RET   nc   ; Return if it's not alphabetic
03C3   FE 41                  CP   "A"   ; Compare with "A"
03C5   3F                     CCF      ; Invert CF to set it if it's alphabetic
03C6   C9                     RET      ; Return
03C7                             ; *****************************************************************************
03C7                             ; Routine: isDigit
03C7                             ; 
03C7                             ; Purpose:
03C7                             ;    Checks if the character in the A register is a decimal digit (0-9). If
03C7                             ;    the character is a decimal digit, it sets the carry flag.
03C7                             ; 
03C7                             ; Input:
03C7                             ;    A - Contains the character to be checked.
03C7                             ; 
03C7                             ; Output:
03C7                             ;    CF - Set if the input character was a digit, cleared otherwise.
03C7                             ; 
03C7                             ; Destroyed:
03C7                             ;    None
03C7                             ; *****************************************************************************
03C7                ISDIGIT:      
03C7   FE 3A                  CP   "9"+1   ; Compare with "9" + 1
03C9   D0                     RET   nc   ; Return if it's not a digit
03CA   FE 30                  CP   "0"   ; Compare with "0"
03CC   3F                     CCF      ; Invert CF to set it if it's a digit
03CD   C9                     RET      ; Return
03CE                             ; *****************************************************************************
03CE                             ; Routine: number
03CE                             ; 
03CE                             ; Purpose:
03CE                             ;    Parse a number from the input. Handles both decimal and hexadecimal
03CE                             ;    numbers, and supports negative numbers.
03CE                             ; 
03CE                             ; Input:
03CE                             ;    None
03CE                             ; 
03CE                             ; Output:
03CE                             ;    HL - Contains the parsed number.
03CE                             ; 
03CE                             ; Destroyed:
03CE                             ;    None
03CE                             ; *****************************************************************************
03CE                NUMBER:      
03CE   FE 2D                  CP   "-"   ; Check if it's a negative number
03D0   3E FF                  LD   a,-1   ; Set sign flag
03D2   28 01                  JR   z,number1   
03D4   3C                     INC   a   ; Set sign flag to positive
03D5                NUMBER1:      
03D5   32 96 09               LD   (vTemp1),a   ; Store the sign flag in vTemp1
03D8   CD 77 04               CALL   nextChar   ; Get the next character
03DB   FE 24                  CP   "$"   ; Check if it's a hexadecimal number
03DD   20 05                  JR   nz,number2   
03DF   CD 03 04               CALL   hex   ; If yes, parse hexadecimal number
03E2   18 06                  JR   number3   
03E4                NUMBER2:      
03E4   CD DC 04               CALL   rewindChar   ; Push back the character
03E7   CD 2E 04               CALL   decimal   ; Parse decimal number
03EA                NUMBER3:      
03EA   3A 96 09               LD   a,(vTemp1)   ; Load the sign from vTemp1
03ED   3C                     INC   a   ; Increment to negate if necessary
03EE   C0                     RET   nz   ; Return if sign is not zero
03EF   EB                     EX   de,hl   ; Negate the value of HL
03F0   21 00 00               LD   hl,0   ; Load zero to clear carry
03F3   B7                     OR   a   ; Clear carry flag
03F4   ED 52                  SBC   hl,de   ; Subtract DE from HL
03F6   CD DC 04               CALL   rewindChar   ; Push back the character
03F9   C9                     RET      ; Return
03FA                NUMBER_HEX:      
03FA   AF                     XOR   a   
03FB   32 96 09               LD   (vTemp1),a   ; Store the sign flag in vTemp1
03FE   CD 03 04               CALL   hex   ; Parse hexadecimal number
0401   18 E7                  JR   number3   
0403                             ; *****************************************************************************
0403                             ; Routine: hex
0403                             ; 
0403                             ; Purpose:
0403                             ;    Parse a hexadecimal number.
0403                             ; 
0403                             ; Input:
0403                             ;    None
0403                             ; 
0403                             ; Output:
0403                             ;    HL - Parsed number.
0403                             ; 
0403                             ; Destroyed:
0403                             ;    A
0403                             ; *****************************************************************************
0403                HEX:         
0403   21 00 00               LD   hl,0   ; Initialize HL to 0
0406                HEX1:        
0406   CD 77 04               CALL   nextChar   ; Get the next character
0409   FE 30                  CP   "0"   ; Compare with ASCII "0"
040B   D8                     RET   c   ; Return if less than "0"
040C   FE 3A                  CP   "9"+1   ; Compare with ASCII "9" + 1
040E   38 0F                  JR   c,valid   ; If less or equal, jump to valid
0410   FE 61                  CP   "a"   ; Compare with ASCII "a"
0412   38 02                  JR   c,hex2   ; If less, jump to hex2
0414   D6 20                  SUB   $20   ; Convert lowercase to uppercase
0416                HEX2:        
0416   FE 41                  CP   "A"   ; Compare with ASCII "A"
0418   D8                     RET   c   ; Return if less than "A"
0419   FE 47                  CP   "F"+1   ; Compare with ASCII "F" + 1
041B   38 00                  JR   c,upper   ; If less or equal, jump to upper
041D                UPPER:       
041D   D6 37                  SUB   $37   ; Convert ASCII to hexadecimal
041F                VALID:       
041F   D6 30                  SUB   "0"   ; Convert ASCII to numeric value
0421   D8                     RET   c   ; Return if less than 0 (not a valid digit)
0422   FE 10                  CP   $10   ; Compare with 16
0424   D0                     RET   nc   ; Return if greater than 16 (not a valid digit)
0425   29                     ADD   hl,hl   ; Multiply by 16
0426   29                     ADD   hl,hl   ; Multiply by 16
0427   29                     ADD   hl,hl   ; Multiply by 16
0428   29                     ADD   hl,hl   ; Multiply by 16
0429   85                     ADD   a,l   ; Add new digit to HL
042A   6F                     LD   l,a   ; Store result back in L
042B   C3 06 04               JP   hex1   ; Jump back to hex1 to process next character
042E                             ; *****************************************************************************
042E                             ; Routine: decimal
042E                             ; 
042E                             ; Purpose:
042E                             ;    Parse a decimal number.
042E                             ; 
042E                             ; Input:
042E                             ;    None
042E                             ; 
042E                             ; Output:
042E                             ;    HL - Parsed number.
042E                             ; 
042E                             ; Destroyed:
042E                             ;    A, DE
042E                             ; *****************************************************************************
042E                DECIMAL:      
042E   21 00 00               LD   hl,0   ; Initialize HL to 0
0431                DECIMAL1:      
0431   CD 77 04               CALL   nextChar   ; Get the next character
0434   D6 30                  SUB   "0"   ; Convert ASCII to binary
0436   D8                     RET   c   ; Return if less than "0"
0437   FE 0A                  CP   10   ; Compare with 10
0439   D0                     RET   nc   ; Return if greater than 10
043A   03                     INC   bc   ; Increment BC to point to next digit
043B   54 5D                  LD   de,hl   ; Copy HL to DE
043D   29                     ADD   hl,hl   ; Multiply HL by 2
043E   29                     ADD   hl,hl   ; Multiply HL by 4
043F   19                     ADD   hl,de   ; Add DE to HL to multiply by 5
0440   29                     ADD   hl,hl   ; Multiply HL by 10
0441   85                     ADD   a,l   ; Add A to HL
0442   6F                     LD   l,a   ; Store result back in L
0443   3E 00                  LD   a,0   ; Clear A
0445   8C                     ADC   a,h   ; Add carry to H
0446   67                     LD   h,a   ; Store result back in H
0447   18 E8                  JR   decimal1   ; Jump back to start of loop
0449                             ; *****************************************************************************
0449                             ; Routine: searchStr
0449                             ; 
0449                             ; Purpose:
0449                             ;    Search through a list of Pascal STRINGS for a match.
0449                             ; 
0449                             ; Inputs:
0449                             ;    HL - Points to the string to search for.
0449                             ;    DE - Points to the start of the list of STRINGS.
0449                             ; 
0449                             ; Outputs:
0449                             ;    CF - True if match, false otherwise.
0449                             ;    A - Index of the matching string if a match is found, or -1 if no match
0449                             ;        is found.
0449                             ;    HL - Points to the string to search for.
0449                             ; 
0449                             ; Destroyed:
0449                             ;    A, B, C, D, E, A", F"
0449                             ; *****************************************************************************
0449                SEARCHSTR:      
0449   EB                     EX   de,hl   ; DE = search string, HL = string list
044A   AF                     XOR   a   ; Initialize index counter, ZF = true, CF = false
044B   08                     EX   af,af'   ; Exchange AF with AF prime
044C                SEARCHSTR1:      
044C   D5                     PUSH   de   ; Store search string
044D   E5                     PUSH   hl   ; Store current string
044E   CD 6C 04               CALL   compareStr   
0451   20 F6                  JR   nz,searchStr   
0453   E1                     POP   hl   ; Discard current string
0454   E1                     POP   hl   ; HL = search string
0455   08                     EX   af,af'   ; Load index of match
0456   3F                     CCF      ; If match, CF = true
0457   C9                     RET      
0458                SEARCHSTR3:      
0458   E1                     POP   hl   ; Restore current string
0459   D1                     POP   de   ; Restore search string
045A   7E                     LD   a,(hl)   ; Load length of current string
045B   3C                     INC   a   ; A = length byte plus length of string
045C   4F                     LD   c,a   ; BC = A
045D   06 00                  LD   b,0   
045F   09                     ADD   hl,bc   ; HL += BC, move to next string
0460   D5                     PUSH   de   ; Store search string
0461   E5                     PUSH   hl   ; Store current string
0462   08                     EX   af,af'   ; Increment index counter, ZF = false, CF = false
0463   3C                     INC   a   
0464   08                     EX   af,af'   
0465   7E                     LD   a,(hl)   ; A = length of next string
0466   B7                     OR   a   ; If A != 0, continue searching
0467   20 E3                  JR   nz,searchStr1   
0469   3D                     DEC   a   ; A = NO_MATCH (i.e., -1), ZF = false
046A   3F                     CCF      ; CF = false
046B   C9                     RET      
046C                             ; *****************************************************************************
046C                             ; Routine: compareStr
046C                             ; 
046C                             ; Purpose:
046C                             ;    Compares two Pascal strings. The comparison includes
046C                             ;    the length byte and continues until all characters are compared or a
046C                             ;    mismatch is found.
046C                             ; 
046C                             ; Inputs:
046C                             ;    DE - Points to the start of string1
046C                             ;    HL - Points to the start of string2
046C                             ; 
046C                             ; Outputs:
046C                             ;    ZF - Set if the strings are equal
046C                             ; 
046C                             ; Registers Destroyed:
046C                             ;    A, B, DE, HL
046C                             ; *****************************************************************************
046C                COMPARESTR:      
046C   1A                     LD   a,(de)   ; Load length of search string
046D   47                     LD   b,a   ; Copy length to B for looping
046E   04                     INC   b   ; Increase to include length byte
046F                COMPARESTR2:      
046F   1A                     LD   a,(de)   ; Load next character from search string
0470   BE                     CP   (hl)   ; Compare with next character in current string
0471   C0                     RET   nz   ; Return if characters are not equal
0472   13                     INC   de   ; Move to next character in search string
0473   23                     INC   hl   ; Move to next character in current string
0474   10 F9                  DJNZ   compareStr2   ; Loop until all characters compared or mismatch
0476                COMPARESTR3:      
0476   C9                     RET      ; Return with ZF set if strings are equal
0477                             ; *****************************************************************************
0477                             ; Routine: nextChar
0477                             ; 
0477                             ; Purpose:
0477                             ;    Fetches the next character from the BUFFER. If the BUFFER is empty or
0477                             ;    contains a null character (0), it refills the BUFFER by calling nextLine.
0477                             ; 
0477                             ; Inputs:
0477                             ;    None
0477                             ; 
0477                             ; Outputs:
0477                             ;    A - The next character from the BUFFER
0477                             ; 
0477                             ; Registers Destroyed:
0477                             ;    A, D, E, HL
0477                             ; *****************************************************************************
0477                NEXTCHAR:      
0477   21 9D 09               LD   hl,vBufferPos   ; Load the offset of BUFFER position variable
047A   7E                     LD   a,(hl)   ; Load the current position offset in the BUFFER into A
047B   FE 80                  CP   BUFFER_SIZE   ; Compare with BUFFER size
047D   CA 8E 04               JP   z,nextLine   ; Jump to nextLine if end of BUFFER
0480   11 00 08               LD   de,BUFFER   ; Load the MSB of the BUFFER's address into D
0483   83                     ADD   a,e   ; de += a
0484   5F                     LD   e,a   
0485   3E 00                  LD   a,0   
0487   8A                     ADC   a,d   
0488   57                     LD   d,a   
0489   1A                     LD   a,(de)   ; Load the character at the current BUFFER position into A
048A   34                     INC   (hl)   ; Increment the BUFFER position offset
048B   FE 0A                  CP   "\n"   ; if a != null return else load a new line into buffer
048D   C0                     RET   nz   
048E                NEXTLINE:      
048E   21 00 08               LD   hl,BUFFER   ; Start of the BUFFER
0491   06 80                  LD   b,BUFFER_SIZE   ; Number of bytes to fill
0493                NEXTLINE1:      
0493   CD 81 00               CALL   getchar   ; Get a character from getchar
0496   FE FF                  CP   EOF   ; is it EOF
0498   28 30                  JR   z,nextLine6   
049A   B7                     OR   a   ; is it NULL?
049B   28 04                  JR   z,nextLine2   
049D   FE 03                  CP   CTRL_C   ; is it ctrl-C ?
049F   20 04                  JR   nz,nextLine3   
04A1                NEXTLINE2:      
04A1   3E FF                  LD   a,EOF   
04A3   18 25                  JR   nextLine6   
04A5                NEXTLINE3:      
04A5   FE 08                  CP   "\b"   ; Check if character is backspace
04A7   20 10                  JR   nz,nextLine4   ; If not, proceed to store the character
04A9   3E 80                  LD   a,BUFFER_SIZE   
04AB   90                     SUB   b   ; Check if at the start of the buffer
04AC   28 E5                  JR   z,nextLine1   ; If at the start, ignore backspace
04AE   2B                     DEC   hl   ; Move back in the buffer
04AF   04                     INC   b   ; Adjust buffer size counter
04B0   CD F9 04               CALL   print   ; Erase the character at the current cursor position
04B3   1B 5B 50 00            .CSTR   ESC,"[P"   ; Escape sequence for erasing character
04B7   18 DA                  JR   nextLine1   
04B9                NEXTLINE4:      
04B9   CD 87 00               CALL   putchar   ; Echo character to terminal
04BC   FE 09                  CP   "\t"   
04BE   20 04                  JR   nz,nextLine5   ; if a == CR or NL replace with null
04C0   3E 20                  LD   a," "   
04C2   18 06                  JR   nextLine6   
04C4                NEXTLINE5:      
04C4   FE 0D                  CP   "\r"   ; Check if character is carriage return
04C6   20 02                  JR   nz,nextLine6   
04C8   3E 0A                  LD   a,"\n"   
04CA                NEXTLINE6:      
04CA   77                     LD   (hl),a   ; Store the character in the BUFFER
04CB   23                     INC   hl   ; Move to the next position in the BUFFER
04CC   FE FF                  CP   EOF   ; Break loop if character is end of line
04CE   28 06                  JR   z,nextLine7   
04D0   FE 0A                  CP   "\n"   ; Break loop if character is end of line
04D2   28 02                  JR   z,nextLine7   
04D4   10 BD                  DJNZ   nextLine1   ; Repeat until BUFFER is full
04D6                NEXTLINE7:      
04D6   21 9D 09               LD   hl,vBufferPos   
04D9   36 00                  LD   (hl),0   
04DB   C9                     RET      
04DC                             ; *****************************************************************************
04DC                             ; Routine: rewindChar
04DC                             ; 
04DC                             ; Purpose:
04DC                             ;    Rewinds the BUFFER position by one character, effectively pushing back the
04DC                             ;    BUFFER position by one character in the input stream.
04DC                             ; 
04DC                             ; Inputs:
04DC                             ;    None
04DC                             ; 
04DC                             ; Outputs:
04DC                             ;    None
04DC                             ; 
04DC                             ; Registers Destroyed:
04DC                             ;    A
04DC                             ; *****************************************************************************
04DC                REWINDCHAR:      
04DC   21 9D 09               LD   hl,vBufferPos   ; Load the address of BUFFER position variable
04DF   7E                     LD   a,(hl)   ; Load the current position in the BUFFER into A
04E0   B7                     OR   a   ; Check if the BUFFER position is zero
04E1   C8                     RET   z   ; If zero, nothing to push back, return
04E2   35                     DEC   (hl)   ; Decrement the BUFFER position
04E3   C9                     RET      ; Return
04E4                             ; *****************************************************************************
04E4                             ; Routine: prompt
04E4                             ; 
04E4                             ; Purpose:
04E4                             ;    Prints a prompt symbol ("> ") to indicate readiness for user input.
04E4                             ; 
04E4                             ; Inputs:
04E4                             ;    None
04E4                             ; 
04E4                             ; Outputs:
04E4                             ;    None
04E4                             ; 
04E4                             ; Registers Destroyed:
04E4                             ;    A, HL
04E4                             ; *****************************************************************************
04E4                PROMPT:      
04E4   CD F9 04               CALL   print   ; Print the null-terminated string (prompt message)
04E7   0D 0A 3E 20 00         .CSTR   "\r\n> "   ; Define the prompt message
04EC   C9                     RET      ; Return to the caller
04ED                             ; *****************************************************************************
04ED                             ; Routine: crlf
04ED                             ; 
04ED                             ; Purpose:
04ED                             ;    Prints a carriage return and line feed (new line) to the output.
04ED                             ; 
04ED                             ; Inputs:
04ED                             ;    None
04ED                             ; 
04ED                             ; Outputs:
04ED                             ;    None
04ED                             ; 
04ED                             ; Registers Destroyed:
04ED                             ;    A, HL
04ED                             ; *****************************************************************************
04ED                CRLF:        
04ED   CD F9 04               CALL   print   ; Print the null-terminated string (carriage return and line feed)
04F0   0D 0A 00               .CSTR   "\r\n"   ; Define the carriage return and line feed message
04F3   C9                     RET      ; Return to the caller
04F4                             ; *****************************************************************************
04F4                             ; Routine: error
04F4                             ; 
04F4                             ; Purpose:
04F4                             ;    Prints an error message and halts execution.
04F4                             ; 
04F4                             ; Inputs:
04F4                             ;    (Stack) - The address of the error message to be printed
04F4                             ; 
04F4                             ; Outputs:
04F4                             ;    None
04F4                             ; 
04F4                             ; Registers Destroyed:
04F4                             ;    A, HL
04F4                             ; *****************************************************************************
04F4                ERROR:       
04F4   E1                     POP   hl   ; Retrieve the "return" address which is the address of the error message
04F5   CD 00 05               CALL   printStr   ; Call the routine to print the null-terminated string
04F8   76                     HALT      ; Halt the CPU
04F9                             ; *****************************************************************************
04F9                             ; Routine: print
04F9                             ; 
04F9                             ; Purpose:
04F9                             ;    Prints a null-terminated string starting from the address in HL.
04F9                             ; 
04F9                             ; Inputs:
04F9                             ;    HL - Points to the start of the string to be printed
04F9                             ; 
04F9                             ; Outputs:
04F9                             ;    None
04F9                             ; 
04F9                             ; Registers Destroyed:
04F9                             ;    None
04F9                             ; *****************************************************************************
04F9                PRINT:       
04F9   E3                     EX   (sp),hl   ; Swap HL with the value on the stack to preserve HL
04FA   CD 0D 05               CALL   printZStr   ; Call the routine to print the null-terminated string
04FD   23                     INC   hl   ; Increment HL to skip the null terminator
04FE   E3                     EX   (sp),hl   ; Restore the original value of HL from the stack
04FF   C9                     RET      ; Return to the caller
0500                             ; *****************************************************************************
0500                             ; Routine: printStr
0500                             ; 
0500                             ; Purpose:
0500                             ;    Prints a Pascal string stored in memory.
0500                             ; 
0500                             ; Inputs:
0500                             ;    HL - Points to the start of the string (first byte is the length)
0500                             ; 
0500                             ; Outputs:
0500                             ;    None
0500                             ; 
0500                             ; Registers Destroyed:
0500                             ;    A, B, HL
0500                             ; *****************************************************************************
0500                PRINTSTR:      
0500   7E                     LD   a,(hl)   ; Load the length of the string
0501   B7                     OR   a   ; Check if the length is zero
0502   C8                     RET   z   ; If zero, return immediately
0503   23                     INC   hl   ; Move HL to the start of the string data
0504   47                     LD   b,a   ; Copy the length to B for looping
0505                PRINTSTR1:      
0505   7E                     LD   a,(hl)   ; Load the next character
0506   CD 87 00               CALL   putchar   ; Call a routine that prints a single character
0509   23                     INC   hl   ; Move to the next character
050A   10 F9                  DJNZ   printStr1   ; Decrement B and jump if not zero
050C   C9                     RET      ; Return from the routine
050D                             ; *****************************************************************************
050D                             ; Routine: printZStr
050D                             ; 
050D                             ; Purpose:
050D                             ;    Prints a null-terminated string stored in memory.
050D                             ; 
050D                             ; Inputs:
050D                             ;    HL - Points to the start of the string to be printed
050D                             ; 
050D                             ; Outputs:
050D                             ;    None
050D                             ; 
050D                             ; Registers Destroyed:
050D                             ;    A, HL
050D                             ; *****************************************************************************
050D                PRINTZSTR:      
050D   18 04                  JR   printZStr2   ; Jump to the loop condition
050F                PRINTZSTR1:      
050F   CD 87 00               CALL   putchar   ; Print the current character
0512   23                     INC   hl   ; Move to the next character
0513                PRINTZSTR2:      
0513   7E                     LD   a,(hl)   ; Load the current character
0514   B7                     OR   a   ; Check if the character is null
0515   20 F8                  JR   nz,printZStr1   ; If not null, continue printing
0517   C9                     RET      ; Return when null character is encountered
0518                             ; *******************************************************************************
0518                             ; *********  END OF MAIN   ******************************************************
0518                             ; *******************************************************************************
0518                ROT_OPCODES:      
0518   03 52 4C 43            .PSTR   "RLC"   
051C   03 52 52 43            .PSTR   "RRC"   
0520   02 52 4C               .PSTR   "RL"   
0523   02 52 52               .PSTR   "RR"   
0526   03 53 4C 41            .PSTR   "SLA"   
052A   03 53 52 41            .PSTR   "SRA"   
052E   03 53 4C 4C            .PSTR   "SLL"   
0532   03 53 52 4C            .PSTR   "SRL"   
0536   00                     .PSTR   ""   ; terminate list with a string of zero length
0537                ALU_OPCODES:      
0537   03 41 44 44            .PSTR   "ADD"   
053B   03 41 44 43            .PSTR   "ADC"   
053F   03 53 55 42            .PSTR   "SUB"   
0543   03 53 42 43            .PSTR   "SBC"   
0547   03 41 4E 44            .PSTR   "AND"   
054B   03 58 4F 52            .PSTR   "XOR"   
054F   02 4F 52               .PSTR   "OR"   
0552   02 43 50               .PSTR   "CP"   
0555   00                     .PSTR   ""   ; terminate list with a string of zero length
0556                BLI_OPCODES:      
0556   03 4C 44 49            .PSTR   "LDI"   
055A   03 43 50 49            .PSTR   "CPI"   
055E   03 49 4E 49            .PSTR   "INI"   
0562   04 4F 55 54 49         .PSTR   "OUTI"   
0567   03 4C 44 44            .PSTR   "LDD"   
056B   03 43 50 44            .PSTR   "CPD"   
056F   03 49 4E 44            .PSTR   "IND"   
0573   04 4F 55 54 44         .PSTR   "OUTD"   
0578   04 4C 44 49 52         .PSTR   "LDIR"   
057D   04 43 50 49 52         .PSTR   "CPIR"   
0582   04 49 4E 49 52         .PSTR   "INIR"   
0587   04 4F 54 49 52         .PSTR   "OTIR"   
058C   04 4C 44 44 52         .PSTR   "LDDR"   
0591   04 43 50 44 52         .PSTR   "CPDR"   
0596   04 49 4E 44 52         .PSTR   "INDR"   
059B   04 4F 54 44 52         .PSTR   "OTDR"   
05A0   00                     .PSTR   ""   ; terminate list with a string of zero length
05A1                GEN1_OPCODES:      
05A1   03 43 43 46            .PSTR   "CCF"   
05A5   03 43 50 4C            .PSTR   "CPL"   
05A9   03 44 41 41            .PSTR   "DAA"   
05AD   02 44 49               .PSTR   "DI"   
05B0   02 45 49               .PSTR   "EI"   
05B3   04 48 41 4C 54         .PSTR   "HALT"   
05B8   03 4E 4F 50            .PSTR   "NOP"   
05BC   04 52 4C 43 41         .PSTR   "RLCA"   
05C1   03 52 53 54            .PSTR   "RST"   
05C5   03 53 43 46            .PSTR   "SCF"   
05C9   00                     .PSTR   ""   ; terminate list with a string of zero length
05CA                GEN2_OPCODES:      
05CA   03 42 49 54            .PSTR   "BIT"   
05CE   04 43 41 4C 4C         .PSTR   "CALL"   
05D3   03 44 45 43            .PSTR   "DEC"   
05D7   04 44 4A 4E 5A         .PSTR   "DJNZ"   
05DC   02 45 58               .PSTR   "EX"   
05DF   03 45 58 58            .PSTR   "EXX"   
05E3   02 49 4D               .PSTR   "IM"   
05E6   02 49 4E               .PSTR   "IN"   
05E9   03 49 4E 43            .PSTR   "INC"   
05ED   02 4A 50               .PSTR   "JP"   
05F0   02 4A 52               .PSTR   "JR"   
05F3   02 4C 44               .PSTR   "LD"   
05F6   03 4E 45 47            .PSTR   "NEG"   
05FA   03 4F 55 54            .PSTR   "OUT"   
05FE   03 50 4F 50            .PSTR   "POP"   
0602   04 50 55 53 48         .PSTR   "PUSH"   
0607   03 52 45 53            .PSTR   "RES"   
060B   03 52 45 54            .PSTR   "RET"   
060F   04 52 45 54 49         .PSTR   "RETI"   
0614   04 52 45 54 4E         .PSTR   "RETN"   
0619   03 52 4C 41            .PSTR   "RLA"   
061D   03 52 4C 44            .PSTR   "RLD"   
0621   03 52 52 41            .PSTR   "RRA"   
0625   04 52 52 43 41         .PSTR   "RRCA"   
062A   03 52 52 44            .PSTR   "RRD"   
062E   03 53 45 54            .PSTR   "SET"   
0632   00                     .PSTR   ""   ; terminate list with a string of zero length
0633                REG8:        
0633   01 42                  .PSTR   "B"   
0635   01 43                  .PSTR   "C"   
0637   01 44                  .PSTR   "D"   
0639   01 45                  .PSTR   "E"   
063B   01 48                  .PSTR   "H"   
063D   01 4C                  .PSTR   "L"   
063F   01 20                  .PSTR   " "   ; don't match, stand-in for (HL)
0641   01 41                  .PSTR   "A"   
0643   01 49                  .PSTR   "I"   
0645   01 52                  .PSTR   "R"   
0647   00                     .PSTR   ""   ; terminate list with a string of zero length
0648                REG16:       
0648   02 42 43               .PSTR   "BC"   
064B   02 44 45               .PSTR   "DE"   
064E   02 48 4C               .PSTR   "HL"   
0651   02 53 50               .PSTR   "SP"   
0654   02 49 58               .PSTR   "IX"   
0657   02 49 59               .PSTR   "IY"   
065A   03 41 46 27            .PSTR   "AF'"   
065E   02 41 46               .PSTR   "AF"   ; NOTE: AF has the same code as SP in some instructions
0661   00                     .PSTR   ""   ; terminate list with a string of zero length
0662                FLAGS:       
0662   02 4E 5A               .PSTR   "NZ"   
0665   01 5A                  .PSTR   "Z"   
0667   02 4E 43               .PSTR   "NC"   
066A   01 43                  .PSTR   "C"   
066C   02 50 4F               .PSTR   "PO"   
066F   02 50 45               .PSTR   "PE"   
0672   01 50                  .PSTR   "P"   
0674   01 4D                  .PSTR   "M"   
0676   00                     .PSTR   ""   ; terminate list with a string of zero length
0677                DIRECTIVES:      
0677   06 2E 41 4C 49 47 4E   .PSTR   ".ALIGN"   
067E   03 2E 44 42            .PSTR   ".DB"   
0682   04 2E 4F 52 47         .PSTR   ".ORG"   
0687   04 2E 53 45 54         .PSTR   ".SET"   
068C   00                     .PSTR   ""   ; terminate list with a string of zero length
068D                             ; *******************************************************************************
068D                             ; *********  END OF DATA   ******************************************************
068D                             ; *******************************************************************************
0800                          .ORG   RAMSTART   
0800                          ALIGN   $100   
0800                BUFFER:   DS   BUFFER_SIZE   ; line BUFFER, page aligned
0880                          DS   $100   
0980                STACK:       ; grows down
0980                RST08:    DS   2   
0982                RST10:    DS   2   
0984                RST18:    DS   2   
0986                RST20:    DS   2   
0988                RST28:    DS   2   
098A                RST30:    DS   2   ; 
098C                BAUD:     DS   2   ; 
098E                INTVEC:   DS   2   ; 
0990                NMIVEC:   DS   2   ; 
0992                GETCVEC:   DS   2   ; 
0994                PUTCVEC:   DS   2   ; 
0996                VTEMP1:   DS   2   ; temp var 1
0998                VTEMP2:   DS   2   ; temp var 2
099A                VTOKEN:   DS   1   ; BUFFER for pushed back token
099B                VTOKENVAL:   DS   2   ; BUFFER for pushed back token value
099D                VBUFFERPOS:   DS   2   ; pointer to char position into input BUFFER
099F                VASMPTR:   DS   2   ; pointer to ASSEMBLY point
09A1                VSTRPTR:   DS   2   ; pointer to string STACK
09A3                VSYMPTR:   DS   2   ; pointer to symbol STACK
09A5                VEXPRPTR:   DS   2   ; pointer to expression STACK
09A7                STRINGS:   DS   $100   ; string heap - grows up
0AA7                SYMBOLS:   DS   $100   ; symbol heap - grows up
0BA7                EXPRS:    DS   $100   ; expression heap - grows up
0CA7                ASSEMBLY:      


ROMSTART:           0000 DEFINED AT LINE 1 IN constants.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 116 IN IOSerial.asm
                    > USED AT LINE 122 IN IOSerial.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 134 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 146 IN IOSerial.asm
                    > USED AT LINE 152 IN IOSerial.asm
                    > USED AT LINE 158 IN IOSerial.asm
                    > USED AT LINE 200 IN IOSerial.asm
                    > USED AT LINE 17 IN MAIN.asm
RAMSTART:           0800 DEFINED AT LINE 2 IN constants.asm
                    > USED AT LINE 1 IN ram.asm
ROMSIZE:            0800 DEFINED AT LINE 3 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 4 IN constants.asm
EOF:                00-1 DEFINED AT LINE 6 IN constants.asm
                    > USED AT LINE 236 IN MAIN.asm
                    > USED AT LINE 923 IN MAIN.asm
                    > USED AT LINE 931 IN MAIN.asm
                    > USED AT LINE 963 IN MAIN.asm
NULL:               0000 DEFINED AT LINE 7 IN constants.asm
CTRL_C:             0003 DEFINED AT LINE 8 IN constants.asm
                    > USED AT LINE 238 IN MAIN.asm
                    > USED AT LINE 927 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 9 IN constants.asm
ESC:                001B DEFINED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 944 IN MAIN.asm
NO_MATCH:           00-1 DEFINED AT LINE 11 IN constants.asm
BUFFER_SIZE:        0080 DEFINED AT LINE 12 IN constants.asm
                    > USED AT LINE 904 IN MAIN.asm
                    > USED AT LINE 919 IN MAIN.asm
                    > USED AT LINE 937 IN MAIN.asm
                    > USED AT LINE 5 IN ram.asm
TOKENS:             0000 DEFINED AT LINE 14 IN constants.asm
COLON_:             000: DEFINED AT LINE 16 IN constants.asm
COMMA_:             000, DEFINED AT LINE 17 IN constants.asm
                    > USED AT LINE 181 IN MAIN.asm
DIRECT_:            000D DEFINED AT LINE 18 IN constants.asm
                    > USED AT LINE 156 IN MAIN.asm
                    > USED AT LINE 312 IN MAIN.asm
DOLLAR_:            000$ DEFINED AT LINE 19 IN constants.asm
EOF_:               000E DEFINED AT LINE 20 IN constants.asm
                    > USED AT LINE 119 IN MAIN.asm
                    > USED AT LINE 163 IN MAIN.asm
                    > USED AT LINE 174 IN MAIN.asm
                    > USED AT LINE 241 IN MAIN.asm
FLAG_:              000F DEFINED AT LINE 21 IN constants.asm
                    > USED AT LINE 304 IN MAIN.asm
IDENT_:             000I DEFINED AT LINE 22 IN constants.asm
                    > USED AT LINE 316 IN MAIN.asm
LABEL_:             000L DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 145 IN MAIN.asm
                    > USED AT LINE 275 IN MAIN.asm
LPAREN_:            000( DEFINED AT LINE 24 IN constants.asm
NEWLN_:             000
 DEFINED AT LINE 25 IN constants.asm
                    > USED AT LINE 161 IN MAIN.asm
                    > USED AT LINE 172 IN MAIN.asm
                    > USED AT LINE 251 IN MAIN.asm
NUM_:               0009 DEFINED AT LINE 26 IN constants.asm
                    > USED AT LINE 340 IN MAIN.asm
OPCODE_:            000C DEFINED AT LINE 27 IN constants.asm
                    > USED AT LINE 150 IN MAIN.asm
                    > USED AT LINE 283 IN MAIN.asm
REG_:               000R DEFINED AT LINE 28 IN constants.asm
                    > USED AT LINE 297 IN MAIN.asm
REGPAIR_:           000P DEFINED AT LINE 29 IN constants.asm
                    > USED AT LINE 290 IN MAIN.asm
RPAREN_:            000) DEFINED AT LINE 30 IN constants.asm
UNKNOWN_:           000U DEFINED AT LINE 31 IN constants.asm
                    > USED AT LINE 350 IN MAIN.asm
ALU_CODE:           0000 DEFINED AT LINE 33 IN constants.asm
                    > USED AT LINE 41 IN constants.asm
                    > USED AT LINE 42 IN constants.asm
                    > USED AT LINE 43 IN constants.asm
                    > USED AT LINE 44 IN constants.asm
                    > USED AT LINE 45 IN constants.asm
                    > USED AT LINE 46 IN constants.asm
                    > USED AT LINE 47 IN constants.asm
                    > USED AT LINE 48 IN constants.asm
ROT_CODE:           0020 DEFINED AT LINE 34 IN constants.asm
                    > USED AT LINE 52 IN constants.asm
                    > USED AT LINE 53 IN constants.asm
                    > USED AT LINE 54 IN constants.asm
                    > USED AT LINE 55 IN constants.asm
                    > USED AT LINE 56 IN constants.asm
                    > USED AT LINE 57 IN constants.asm
                    > USED AT LINE 58 IN constants.asm
                    > USED AT LINE 59 IN constants.asm
BLI_CODE:           0040 DEFINED AT LINE 35 IN constants.asm
                    > USED AT LINE 63 IN constants.asm
                    > USED AT LINE 64 IN constants.asm
                    > USED AT LINE 65 IN constants.asm
                    > USED AT LINE 66 IN constants.asm
                    > USED AT LINE 67 IN constants.asm
                    > USED AT LINE 68 IN constants.asm
                    > USED AT LINE 69 IN constants.asm
                    > USED AT LINE 70 IN constants.asm
                    > USED AT LINE 71 IN constants.asm
                    > USED AT LINE 72 IN constants.asm
                    > USED AT LINE 73 IN constants.asm
                    > USED AT LINE 74 IN constants.asm
                    > USED AT LINE 75 IN constants.asm
                    > USED AT LINE 76 IN constants.asm
                    > USED AT LINE 77 IN constants.asm
                    > USED AT LINE 78 IN constants.asm
GEN1_CODE:          0060 DEFINED AT LINE 36 IN constants.asm
                    > USED AT LINE 82 IN constants.asm
                    > USED AT LINE 83 IN constants.asm
                    > USED AT LINE 84 IN constants.asm
                    > USED AT LINE 85 IN constants.asm
                    > USED AT LINE 86 IN constants.asm
                    > USED AT LINE 87 IN constants.asm
                    > USED AT LINE 88 IN constants.asm
                    > USED AT LINE 89 IN constants.asm
                    > USED AT LINE 91 IN constants.asm
GEN2_CODE:          0080 DEFINED AT LINE 37 IN constants.asm
                    > USED AT LINE 90 IN constants.asm
                    > USED AT LINE 95 IN constants.asm
                    > USED AT LINE 96 IN constants.asm
                    > USED AT LINE 97 IN constants.asm
                    > USED AT LINE 98 IN constants.asm
                    > USED AT LINE 99 IN constants.asm
                    > USED AT LINE 100 IN constants.asm
                    > USED AT LINE 101 IN constants.asm
                    > USED AT LINE 102 IN constants.asm
                    > USED AT LINE 103 IN constants.asm
                    > USED AT LINE 104 IN constants.asm
                    > USED AT LINE 105 IN constants.asm
                    > USED AT LINE 106 IN constants.asm
                    > USED AT LINE 107 IN constants.asm
                    > USED AT LINE 108 IN constants.asm
                    > USED AT LINE 109 IN constants.asm
                    > USED AT LINE 110 IN constants.asm
                    > USED AT LINE 111 IN constants.asm
                    > USED AT LINE 112 IN constants.asm
                    > USED AT LINE 113 IN constants.asm
                    > USED AT LINE 114 IN constants.asm
                    > USED AT LINE 115 IN constants.asm
                    > USED AT LINE 116 IN constants.asm
                    > USED AT LINE 117 IN constants.asm
                    > USED AT LINE 118 IN constants.asm
                    > USED AT LINE 119 IN constants.asm
                    > USED AT LINE 120 IN constants.asm
ALU_IDX:            0000 DEFINED AT LINE 39 IN constants.asm
ADD_:               0000 DEFINED AT LINE 41 IN constants.asm
ADC_:               0001 DEFINED AT LINE 42 IN constants.asm
SUB_:               0002 DEFINED AT LINE 43 IN constants.asm
SBC_:               0003 DEFINED AT LINE 44 IN constants.asm
AND_:               0004 DEFINED AT LINE 45 IN constants.asm
XOR_:               0005 DEFINED AT LINE 46 IN constants.asm
OR_:                0006 DEFINED AT LINE 47 IN constants.asm
CP_:                0007 DEFINED AT LINE 48 IN constants.asm
ROT_IDX:            0000 DEFINED AT LINE 50 IN constants.asm
RLC_:               0020 DEFINED AT LINE 52 IN constants.asm
RRC_:               0021 DEFINED AT LINE 53 IN constants.asm
RL_:                0022 DEFINED AT LINE 54 IN constants.asm
RR_:                0023 DEFINED AT LINE 55 IN constants.asm
SLA_:               0024 DEFINED AT LINE 56 IN constants.asm
SRA_:               0025 DEFINED AT LINE 57 IN constants.asm
SLL_:               0026 DEFINED AT LINE 58 IN constants.asm
SRL_:               0027 DEFINED AT LINE 59 IN constants.asm
BLI_IDX:            0000 DEFINED AT LINE 61 IN constants.asm
LDI_:               0040 DEFINED AT LINE 63 IN constants.asm
CPI_:               0041 DEFINED AT LINE 64 IN constants.asm
INI_:               0042 DEFINED AT LINE 65 IN constants.asm
OUTI_:              0043 DEFINED AT LINE 66 IN constants.asm
LDD_:               0044 DEFINED AT LINE 67 IN constants.asm
CPD_:               0045 DEFINED AT LINE 68 IN constants.asm
IND_:               0046 DEFINED AT LINE 69 IN constants.asm
OUTD_:              0047 DEFINED AT LINE 70 IN constants.asm
LDIR_:              0048 DEFINED AT LINE 71 IN constants.asm
CPIR_:              0049 DEFINED AT LINE 72 IN constants.asm
INIR_:              004A DEFINED AT LINE 73 IN constants.asm
OTIR_:              004B DEFINED AT LINE 74 IN constants.asm
LDDR_:              004C DEFINED AT LINE 75 IN constants.asm
CPDR_:              004D DEFINED AT LINE 76 IN constants.asm
INDR_:              004E DEFINED AT LINE 77 IN constants.asm
OTDR_:              004F DEFINED AT LINE 78 IN constants.asm
GEN1_IDX:           0000 DEFINED AT LINE 80 IN constants.asm
CCF_:               0060 DEFINED AT LINE 82 IN constants.asm
CPL_:               0061 DEFINED AT LINE 83 IN constants.asm
DAA_:               0062 DEFINED AT LINE 84 IN constants.asm
DI_:                0063 DEFINED AT LINE 85 IN constants.asm
EI_:                0064 DEFINED AT LINE 86 IN constants.asm
HALT_:              0065 DEFINED AT LINE 87 IN constants.asm
NOP_:               0066 DEFINED AT LINE 88 IN constants.asm
RLCA_:              0067 DEFINED AT LINE 89 IN constants.asm
RST_:               0088 DEFINED AT LINE 90 IN constants.asm
SCF_:               0069 DEFINED AT LINE 91 IN constants.asm
GEN2_IDX:           0000 DEFINED AT LINE 93 IN constants.asm
BIT_:               0080 DEFINED AT LINE 95 IN constants.asm
CALL_:              0081 DEFINED AT LINE 96 IN constants.asm
DEC_:               0082 DEFINED AT LINE 97 IN constants.asm
DJNZ_:              0083 DEFINED AT LINE 98 IN constants.asm
EX_:                0084 DEFINED AT LINE 99 IN constants.asm
EXX_:               0085 DEFINED AT LINE 100 IN constants.asm
IM_:                0086 DEFINED AT LINE 101 IN constants.asm
IN_:                0087 DEFINED AT LINE 102 IN constants.asm
INC_:               0088 DEFINED AT LINE 103 IN constants.asm
JP_:                0089 DEFINED AT LINE 104 IN constants.asm
JR_:                008A DEFINED AT LINE 105 IN constants.asm
LD_:                008B DEFINED AT LINE 106 IN constants.asm
NEG_:               008C DEFINED AT LINE 107 IN constants.asm
OUT_:               008D DEFINED AT LINE 108 IN constants.asm
POP_:               008E DEFINED AT LINE 109 IN constants.asm
PUSH_:              008F DEFINED AT LINE 110 IN constants.asm
RES_:               0090 DEFINED AT LINE 111 IN constants.asm
RET_:               0091 DEFINED AT LINE 112 IN constants.asm
RETI_:              0092 DEFINED AT LINE 113 IN constants.asm
RETN_:              0093 DEFINED AT LINE 114 IN constants.asm
RLA_:               0094 DEFINED AT LINE 115 IN constants.asm
RLD_:               0095 DEFINED AT LINE 116 IN constants.asm
RRA_:               0096 DEFINED AT LINE 117 IN constants.asm
RRCA_:              0097 DEFINED AT LINE 118 IN constants.asm
RRD_:               0098 DEFINED AT LINE 119 IN constants.asm
SET_:               0003 DEFINED AT LINE 169 IN constants.asm
FLAG_CODE:          0008 DEFINED AT LINE 122 IN constants.asm
REG_CODE:           0010 DEFINED AT LINE 123 IN constants.asm
IMMED_CODE:         0018 DEFINED AT LINE 124 IN constants.asm
I16_CODE:           0020 DEFINED AT LINE 125 IN constants.asm
MEM_CODE:           0040 DEFINED AT LINE 126 IN constants.asm
NA_CODE:            0080 DEFINED AT LINE 127 IN constants.asm
REG8_IDX:           0000 DEFINED AT LINE 129 IN constants.asm
B_:                 0000 DEFINED AT LINE 131 IN constants.asm
C_:                 0003 DEFINED AT LINE 158 IN constants.asm
D_:                 0002 DEFINED AT LINE 133 IN constants.asm
E_:                 0003 DEFINED AT LINE 134 IN constants.asm
H_:                 0004 DEFINED AT LINE 135 IN constants.asm
L_:                 0005 DEFINED AT LINE 136 IN constants.asm
MHL_:               0006 DEFINED AT LINE 137 IN constants.asm
A_:                 0007 DEFINED AT LINE 138 IN constants.asm
I_:                 0008 DEFINED AT LINE 139 IN constants.asm
R_:                 0009 DEFINED AT LINE 140 IN constants.asm
REG16_IDX:          0000 DEFINED AT LINE 142 IN constants.asm
BC_:                0000 DEFINED AT LINE 144 IN constants.asm
DE_:                0001 DEFINED AT LINE 145 IN constants.asm
HL_:                0002 DEFINED AT LINE 146 IN constants.asm
SP_:                0003 DEFINED AT LINE 147 IN constants.asm
IX_:                0005 DEFINED AT LINE 148 IN constants.asm
IY_:                0006 DEFINED AT LINE 149 IN constants.asm
AFP_:               0004 DEFINED AT LINE 150 IN constants.asm
AF_:                0007 DEFINED AT LINE 151 IN constants.asm
FLAG_IDX:           0000 DEFINED AT LINE 153 IN constants.asm
NZ_:                0000 DEFINED AT LINE 155 IN constants.asm
Z_:                 0001 DEFINED AT LINE 156 IN constants.asm
NC_:                0002 DEFINED AT LINE 157 IN constants.asm
PO_:                0004 DEFINED AT LINE 159 IN constants.asm
PE_:                0005 DEFINED AT LINE 160 IN constants.asm
P_:                 0006 DEFINED AT LINE 161 IN constants.asm
M_:                 0007 DEFINED AT LINE 162 IN constants.asm
DIRECTIVE_IDX:      0000 DEFINED AT LINE 164 IN constants.asm
ALIGN_:             0000 DEFINED AT LINE 166 IN constants.asm
DB_:                0001 DEFINED AT LINE 167 IN constants.asm
ORG_:               0002 DEFINED AT LINE 168 IN constants.asm
TEC_1:              0001 DEFINED AT LINE 173 IN constants.asm
RC2014:             0000 DEFINED AT LINE 174 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 176 IN constants.asm
LOADER:             0000 DEFINED AT LINE 178 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 179 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 33 IN IOSerial.asm
                    > USED AT LINE 478 IN IOSerial.asm
                    > USED AT LINE 500 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 34 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 322 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 36 IN IOSerial.asm
                    > USED AT LINE 326 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 477 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 46 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 50 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 51 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 52 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 53 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 54 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 55 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 56 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 57 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 61 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 62 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 63 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 64 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 68 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 72 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 73 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 74 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 75 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 76 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 77 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 78 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 79 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 87 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 88 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 89 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 90 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 91 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 92 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 93 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 94 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 108 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 109 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 113 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 163 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 483 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 187 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 193 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 196 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 471 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 305 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 308 IN IOSerial.asm
                    > USED AT LINE 312 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 320 IN IOSerial.asm
                    > USED AT LINE 469 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 321 IN IOSerial.asm
                    > USED AT LINE 325 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 445 IN IOSerial.asm
                    > USED AT LINE 922 IN MAIN.asm
PUTCHAR:            0087 DEFINED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 948 IN MAIN.asm
                    > USED AT LINE 1109 IN MAIN.asm
                    > USED AT LINE 1134 IN MAIN.asm
RESET:              008D DEFINED AT LINE 457 IN IOSerial.asm
                    > USED AT LINE 114 IN IOSerial.asm
START:              0180 DEFINED AT LINE 37 IN MAIN.asm
                    > USED AT LINE 6
INIT:               0198 DEFINED AT LINE 60 IN MAIN.asm
                    > USED AT LINE 39 IN MAIN.asm
PARSE:              01C0 DEFINED AT LINE 94 IN MAIN.asm
                    > USED AT LINE 42 IN MAIN.asm
STATEMENTLIST:      01E7 DEFINED AT LINE 117 IN MAIN.asm
                    > USED AT LINE 95 IN MAIN.asm
                    > USED AT LINE 122 IN MAIN.asm
STATEMENT:          01F2 DEFINED AT LINE 141 IN MAIN.asm
                    > USED AT LINE 121 IN MAIN.asm
STATEMENT10:        01F9 DEFINED AT LINE 149 IN MAIN.asm
                    > USED AT LINE 146 IN MAIN.asm
STATEMENT1:         01FD DEFINED AT LINE 155 IN MAIN.asm
                    > USED AT LINE 151 IN MAIN.asm
STATEMENT2:         0201 DEFINED AT LINE 160 IN MAIN.asm
                    > USED AT LINE 157 IN MAIN.asm
INSTRUCTION:        0208 DEFINED AT LINE 168 IN MAIN.asm
INSTRUCTION1:       0213 DEFINED AT LINE 176 IN MAIN.asm
                    > USED AT LINE 173 IN MAIN.asm
INSTRUCTION2:       0216 DEFINED AT LINE 178 IN MAIN.asm
                    > USED AT LINE 175 IN MAIN.asm
FIRSTOPERAND:       0224 DEFINED AT LINE 185 IN MAIN.asm
                    > USED AT LINE 179 IN MAIN.asm
SECONDOPERAND:      0224 DEFINED AT LINE 186 IN MAIN.asm
                    > USED AT LINE 183 IN MAIN.asm
DIRECTIVE:          0224 DEFINED AT LINE 188 IN MAIN.asm
NEXTTOKEN:          0224 DEFINED AT LINE 220 IN MAIN.asm
                    > USED AT LINE 118 IN MAIN.asm
                    > USED AT LINE 148 IN MAIN.asm
                    > USED AT LINE 171 IN MAIN.asm
                    > USED AT LINE 180 IN MAIN.asm
                    > USED AT LINE 182 IN MAIN.asm
NEXTTOKEN0:         0235 DEFINED AT LINE 229 IN MAIN.asm
                    > USED AT LINE 222 IN MAIN.asm
                    > USED AT LINE 263 IN MAIN.asm
NEXTTOKEN1:         0238 DEFINED AT LINE 232 IN MAIN.asm
                    > USED AT LINE 235 IN MAIN.asm
NEXTTOKEN1A:        0247 DEFINED AT LINE 240 IN MAIN.asm
                    > USED AT LINE 237 IN MAIN.asm
NEXTTOKEN2:         024A DEFINED AT LINE 244 IN MAIN.asm
                    > USED AT LINE 239 IN MAIN.asm
NEXTTOKEN3:         0259 DEFINED AT LINE 254 IN MAIN.asm
                    > USED AT LINE 246 IN MAIN.asm
                    > USED AT LINE 248 IN MAIN.asm
                    > USED AT LINE 250 IN MAIN.asm
NEXTTOKEN4:         025E DEFINED AT LINE 258 IN MAIN.asm
                    > USED AT LINE 261 IN MAIN.asm
NEXTTOKEN5:         026A DEFINED AT LINE 265 IN MAIN.asm
                    > USED AT LINE 256 IN MAIN.asm
NEXTTOKEN6:         0273 DEFINED AT LINE 271 IN MAIN.asm
                    > USED AT LINE 267 IN MAIN.asm
NEXTTOKEN7:         027D DEFINED AT LINE 278 IN MAIN.asm
                    > USED AT LINE 274 IN MAIN.asm
NEXTTOKEN8:         028B DEFINED AT LINE 286 IN MAIN.asm
                    > USED AT LINE 282 IN MAIN.asm
NEXTTOKEN9:         0296 DEFINED AT LINE 293 IN MAIN.asm
                    > USED AT LINE 289 IN MAIN.asm
NEXTTOKEN10:        02A1 DEFINED AT LINE 300 IN MAIN.asm
                    > USED AT LINE 296 IN MAIN.asm
NEXTTOKEN11:        02AC DEFINED AT LINE 307 IN MAIN.asm
                    > USED AT LINE 303 IN MAIN.asm
NEXTTOKEN12:        02B7 DEFINED AT LINE 315 IN MAIN.asm
                    > USED AT LINE 310 IN MAIN.asm
NEXTTOKEN13:        02BA DEFINED AT LINE 319 IN MAIN.asm
                    > USED AT LINE 269 IN MAIN.asm
NEXTTOKEN14:        02D0 DEFINED AT LINE 330 IN MAIN.asm
                    > USED AT LINE 322 IN MAIN.asm
NEXTTOKEN15:        02D9 DEFINED AT LINE 336 IN MAIN.asm
                    > USED AT LINE 332 IN MAIN.asm
NEXTTOKEN16:        02DC DEFINED AT LINE 339 IN MAIN.asm
                    > USED AT LINE 328 IN MAIN.asm
NEXTTOKEN17:        02DF DEFINED AT LINE 343 IN MAIN.asm
                    > USED AT LINE 334 IN MAIN.asm
SEARCHOPCODE:       02EB DEFINED AT LINE 371 IN MAIN.asm
                    > USED AT LINE 281 IN MAIN.asm
SEARCHOPERAND:      0318 DEFINED AT LINE 397 IN MAIN.asm
PUSHBACKTOKEN:      0345 DEFINED AT LINE 442 IN MAIN.asm
                    > USED AT LINE 177 IN MAIN.asm
IDENT:              034E DEFINED AT LINE 470 IN MAIN.asm
                    > USED AT LINE 272 IN MAIN.asm
IDENT1:             0354 DEFINED AT LINE 474 IN MAIN.asm
                    > USED AT LINE 485 IN MAIN.asm
IDENT2:             0362 DEFINED AT LINE 482 IN MAIN.asm
                    > USED AT LINE 479 IN MAIN.asm
IDENT3:             0366 DEFINED AT LINE 486 IN MAIN.asm
                    > USED AT LINE 481 IN MAIN.asm
EXPR:               036F DEFINED AT LINE 513 IN MAIN.asm
EXPR1:              0377 DEFINED AT LINE 518 IN MAIN.asm
                    > USED AT LINE 534 IN MAIN.asm
                    > USED AT LINE 537 IN MAIN.asm
                    > USED AT LINE 540 IN MAIN.asm
                    > USED AT LINE 545 IN MAIN.asm
EXPR2:              0397 DEFINED AT LINE 535 IN MAIN.asm
                    > USED AT LINE 523 IN MAIN.asm
EXPR3:              039A DEFINED AT LINE 538 IN MAIN.asm
                    > USED AT LINE 525 IN MAIN.asm
EXPR4:              039F DEFINED AT LINE 542 IN MAIN.asm
                    > USED AT LINE 527 IN MAIN.asm
                    > USED AT LINE 529 IN MAIN.asm
                    > USED AT LINE 531 IN MAIN.asm
                    > USED AT LINE 533 IN MAIN.asm
EXPR5:              03A3 DEFINED AT LINE 546 IN MAIN.asm
                    > USED AT LINE 541 IN MAIN.asm
ISSPACE:            03B0 DEFINED AT LINE 573 IN MAIN.asm
                    > USED AT LINE 324 IN MAIN.asm
ISALPHANUM:         03B6 DEFINED AT LINE 599 IN MAIN.asm
                    > USED AT LINE 480 IN MAIN.asm
                    > USED AT LINE 532 IN MAIN.asm
ISALPHA:            03BA DEFINED AT LINE 623 IN MAIN.asm
                    > USED AT LINE 268 IN MAIN.asm
ISALPHA1:           03C0 DEFINED AT LINE 627 IN MAIN.asm
                    > USED AT LINE 625 IN MAIN.asm
ISDIGIT:            03C7 DEFINED AT LINE 651 IN MAIN.asm
                    > USED AT LINE 333 IN MAIN.asm
                    > USED AT LINE 600 IN MAIN.asm
NUMBER:             03CE DEFINED AT LINE 675 IN MAIN.asm
                    > USED AT LINE 337 IN MAIN.asm
NUMBER1:            03D5 DEFINED AT LINE 680 IN MAIN.asm
                    > USED AT LINE 678 IN MAIN.asm
NUMBER2:            03E4 DEFINED AT LINE 687 IN MAIN.asm
                    > USED AT LINE 684 IN MAIN.asm
NUMBER3:            03EA DEFINED AT LINE 690 IN MAIN.asm
                    > USED AT LINE 686 IN MAIN.asm
                    > USED AT LINE 705 IN MAIN.asm
NUMBER_HEX:         03FA DEFINED AT LINE 701 IN MAIN.asm
                    > USED AT LINE 327 IN MAIN.asm
HEX:                0403 DEFINED AT LINE 723 IN MAIN.asm
                    > USED AT LINE 685 IN MAIN.asm
                    > USED AT LINE 704 IN MAIN.asm
HEX1:               0406 DEFINED AT LINE 725 IN MAIN.asm
                    > USED AT LINE 752 IN MAIN.asm
HEX2:               0416 DEFINED AT LINE 734 IN MAIN.asm
                    > USED AT LINE 732 IN MAIN.asm
UPPER:              041D DEFINED AT LINE 739 IN MAIN.asm
                    > USED AT LINE 738 IN MAIN.asm
VALID:              041F DEFINED AT LINE 741 IN MAIN.asm
                    > USED AT LINE 730 IN MAIN.asm
DECIMAL:            042E DEFINED AT LINE 770 IN MAIN.asm
                    > USED AT LINE 689 IN MAIN.asm
DECIMAL1:           0431 DEFINED AT LINE 772 IN MAIN.asm
                    > USED AT LINE 789 IN MAIN.asm
SEARCHSTR:          0449 DEFINED AT LINE 812 IN MAIN.asm
                    > USED AT LINE 288 IN MAIN.asm
                    > USED AT LINE 295 IN MAIN.asm
                    > USED AT LINE 302 IN MAIN.asm
                    > USED AT LINE 309 IN MAIN.asm
                    > USED AT LINE 373 IN MAIN.asm
                    > USED AT LINE 377 IN MAIN.asm
                    > USED AT LINE 382 IN MAIN.asm
                    > USED AT LINE 387 IN MAIN.asm
                    > USED AT LINE 393 IN MAIN.asm
                    > USED AT LINE 399 IN MAIN.asm
                    > USED AT LINE 403 IN MAIN.asm
                    > USED AT LINE 408 IN MAIN.asm
                    > USED AT LINE 413 IN MAIN.asm
                    > USED AT LINE 419 IN MAIN.asm
                    > USED AT LINE 821 IN MAIN.asm
SEARCHSTR1:         044C DEFINED AT LINE 817 IN MAIN.asm
                    > USED AT LINE 843 IN MAIN.asm
SEARCHSTR3:         0458 DEFINED AT LINE 828 IN MAIN.asm
COMPARESTR:         046C DEFINED AT LINE 868 IN MAIN.asm
                    > USED AT LINE 820 IN MAIN.asm
COMPARESTR2:        046F DEFINED AT LINE 873 IN MAIN.asm
                    > USED AT LINE 879 IN MAIN.asm
COMPARESTR3:        0476 DEFINED AT LINE 881 IN MAIN.asm
NEXTCHAR:           0477 DEFINED AT LINE 901 IN MAIN.asm
                    > USED AT LINE 233 IN MAIN.asm
                    > USED AT LINE 259 IN MAIN.asm
                    > USED AT LINE 323 IN MAIN.asm
                    > USED AT LINE 477 IN MAIN.asm
                    > USED AT LINE 521 IN MAIN.asm
                    > USED AT LINE 682 IN MAIN.asm
                    > USED AT LINE 726 IN MAIN.asm
                    > USED AT LINE 773 IN MAIN.asm
NEXTLINE:           048E DEFINED AT LINE 917 IN MAIN.asm
                    > USED AT LINE 905 IN MAIN.asm
NEXTLINE1:          0493 DEFINED AT LINE 921 IN MAIN.asm
                    > USED AT LINE 939 IN MAIN.asm
                    > USED AT LINE 945 IN MAIN.asm
                    > USED AT LINE 967 IN MAIN.asm
NEXTLINE2:          04A1 DEFINED AT LINE 930 IN MAIN.asm
                    > USED AT LINE 926 IN MAIN.asm
NEXTLINE3:          04A5 DEFINED AT LINE 934 IN MAIN.asm
                    > USED AT LINE 928 IN MAIN.asm
NEXTLINE4:          04B9 DEFINED AT LINE 947 IN MAIN.asm
                    > USED AT LINE 936 IN MAIN.asm
NEXTLINE5:          04C4 DEFINED AT LINE 955 IN MAIN.asm
                    > USED AT LINE 951 IN MAIN.asm
NEXTLINE6:          04CA DEFINED AT LINE 960 IN MAIN.asm
                    > USED AT LINE 924 IN MAIN.asm
                    > USED AT LINE 932 IN MAIN.asm
                    > USED AT LINE 953 IN MAIN.asm
                    > USED AT LINE 957 IN MAIN.asm
NEXTLINE7:          04D6 DEFINED AT LINE 969 IN MAIN.asm
                    > USED AT LINE 964 IN MAIN.asm
                    > USED AT LINE 966 IN MAIN.asm
REWINDCHAR:         04DC DEFINED AT LINE 991 IN MAIN.asm
                    > USED AT LINE 262 IN MAIN.asm
                    > USED AT LINE 279 IN MAIN.asm
                    > USED AT LINE 325 IN MAIN.asm
                    > USED AT LINE 547 IN MAIN.asm
                    > USED AT LINE 688 IN MAIN.asm
                    > USED AT LINE 698 IN MAIN.asm
PROMPT:             04E4 DEFINED AT LINE 1015 IN MAIN.asm
CRLF:               04ED DEFINED AT LINE 1036 IN MAIN.asm
ERROR:              04F4 DEFINED AT LINE 1057 IN MAIN.asm
PRINT:              04F9 DEFINED AT LINE 1078 IN MAIN.asm
                    > USED AT LINE 40 IN MAIN.asm
                    > USED AT LINE 96 IN MAIN.asm
                    > USED AT LINE 943 IN MAIN.asm
                    > USED AT LINE 1016 IN MAIN.asm
                    > USED AT LINE 1037 IN MAIN.asm
PRINTSTR:           0500 DEFINED AT LINE 1101 IN MAIN.asm
                    > USED AT LINE 1059 IN MAIN.asm
PRINTSTR1:          0505 DEFINED AT LINE 1107 IN MAIN.asm
                    > USED AT LINE 1111 IN MAIN.asm
PRINTZSTR:          050D DEFINED AT LINE 1130 IN MAIN.asm
                    > USED AT LINE 1080 IN MAIN.asm
PRINTZSTR1:         050F DEFINED AT LINE 1133 IN MAIN.asm
                    > USED AT LINE 1140 IN MAIN.asm
PRINTZSTR2:         0513 DEFINED AT LINE 1137 IN MAIN.asm
                    > USED AT LINE 1131 IN MAIN.asm
ROT_OPCODES:        0518 DEFINED AT LINE 1 IN data.asm
                    > USED AT LINE 376 IN MAIN.asm
                    > USED AT LINE 402 IN MAIN.asm
ALU_OPCODES:        0537 DEFINED AT LINE 13 IN data.asm
                    > USED AT LINE 372 IN MAIN.asm
                    > USED AT LINE 398 IN MAIN.asm
BLI_OPCODES:        0556 DEFINED AT LINE 25 IN data.asm
                    > USED AT LINE 381 IN MAIN.asm
                    > USED AT LINE 407 IN MAIN.asm
GEN1_OPCODES:       05A1 DEFINED AT LINE 45 IN data.asm
                    > USED AT LINE 386 IN MAIN.asm
                    > USED AT LINE 412 IN MAIN.asm
GEN2_OPCODES:       05CA DEFINED AT LINE 59 IN data.asm
                    > USED AT LINE 392 IN MAIN.asm
                    > USED AT LINE 418 IN MAIN.asm
REG8:               0633 DEFINED AT LINE 89 IN data.asm
                    > USED AT LINE 294 IN MAIN.asm
REG16:              0648 DEFINED AT LINE 103 IN data.asm
                    > USED AT LINE 287 IN MAIN.asm
FLAGS:              0662 DEFINED AT LINE 115 IN data.asm
                    > USED AT LINE 301 IN MAIN.asm
                    > USED AT LINE 308 IN MAIN.asm
DIRECTIVES:         0677 DEFINED AT LINE 127 IN data.asm
BUFFER:             0800 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 65 IN MAIN.asm
                    > USED AT LINE 906 IN MAIN.asm
                    > USED AT LINE 918 IN MAIN.asm
STACK:              0980 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 458 IN IOSerial.asm
                    > USED AT LINE 38 IN MAIN.asm
RST08:              0980 DEFINED AT LINE 9 IN ram.asm
                    > USED AT LINE 118 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
RST10:              0982 DEFINED AT LINE 10 IN ram.asm
                    > USED AT LINE 124 IN IOSerial.asm
                    > USED AT LINE 461 IN IOSerial.asm
RST18:              0984 DEFINED AT LINE 11 IN ram.asm
                    > USED AT LINE 130 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RST20:              0986 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 136 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
RST28:              0988 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
RST30:              098A DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 148 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
BAUD:               098C DEFINED AT LINE 15 IN ram.asm
INTVEC:             098E DEFINED AT LINE 16 IN ram.asm
                    > USED AT LINE 154 IN IOSerial.asm
                    > USED AT LINE 466 IN IOSerial.asm
NMIVEC:             0990 DEFINED AT LINE 17 IN ram.asm
                    > USED AT LINE 202 IN IOSerial.asm
                    > USED AT LINE 467 IN IOSerial.asm
GETCVEC:            0992 DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 447 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
PUTCVEC:            0994 DEFINED AT LINE 19 IN ram.asm
                    > USED AT LINE 453 IN IOSerial.asm
                    > USED AT LINE 472 IN IOSerial.asm
VTEMP1:             0996 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 681 IN MAIN.asm
                    > USED AT LINE 691 IN MAIN.asm
                    > USED AT LINE 703 IN MAIN.asm
VTEMP2:             0998 DEFINED AT LINE 22 IN ram.asm
VTOKEN:             099A DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 62 IN MAIN.asm
                    > USED AT LINE 221 IN MAIN.asm
                    > USED AT LINE 223 IN MAIN.asm
                    > USED AT LINE 226 IN MAIN.asm
                    > USED AT LINE 444 IN MAIN.asm
VTOKENVAL:          099B DEFINED AT LINE 25 IN ram.asm
                    > USED AT LINE 70 IN MAIN.asm
                    > USED AT LINE 224 IN MAIN.asm
                    > USED AT LINE 445 IN MAIN.asm
VBUFFERPOS:         099D DEFINED AT LINE 26 IN ram.asm
                    > USED AT LINE 63 IN MAIN.asm
                    > USED AT LINE 902 IN MAIN.asm
                    > USED AT LINE 970 IN MAIN.asm
                    > USED AT LINE 992 IN MAIN.asm
VASMPTR:            099F DEFINED AT LINE 27 IN ram.asm
                    > USED AT LINE 67 IN MAIN.asm
VSTRPTR:            09A1 DEFINED AT LINE 28 IN ram.asm
                    > USED AT LINE 69 IN MAIN.asm
                    > USED AT LINE 280 IN MAIN.asm
                    > USED AT LINE 471 IN MAIN.asm
                    > USED AT LINE 487 IN MAIN.asm
                    > USED AT LINE 514 IN MAIN.asm
                    > USED AT LINE 548 IN MAIN.asm
VSYMPTR:            09A3 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 72 IN MAIN.asm
VEXPRPTR:           09A5 DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 74 IN MAIN.asm
STRINGS:            09A7 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 68 IN MAIN.asm
SYMBOLS:            0AA7 DEFINED AT LINE 33 IN ram.asm
                    > USED AT LINE 71 IN MAIN.asm
EXPRS:              0BA7 DEFINED AT LINE 34 IN ram.asm
                    > USED AT LINE 73 IN MAIN.asm
ASSEMBLY:           0CA7 DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 66 IN MAIN.asm
