0000                          .ENGINE   mycomputer   
0000                             ; 
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                          IF   RC2014   
                                 ; Configuration for RC2014
                    ROMSTART:   EQU   $8000   
                    RAMSTART:   EQU   $8800   
                    LOADER:   EQU   0   
                    BITBANG:   EQU   0   
0000                          ENDIF      
0000                          IF   TEC_1   
0000                             ; Configuration for TEC-1
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $0800   
0000                ROMSIZE:   EQU   $0800   
0000                RAMSIZE:   EQU   $0800   
0000                             ;TEC-1D SC 8k rom/ram
0000                             ; ROMSTART .equ $0000
0000                             ; RAMSTART .equ $2000
0000                             ; ROMSIZE  .equ 8192
0000                             ; RAMSIZE  .equ 8192
0000                          ENDIF      
0000                             ; *************************************************************************
0000                             ; 
0000                             ;       Serial routines 
0000                             ; 
0000                             ;       written by Craig Jones 
0000                             ; 
0000                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
0000                             ; 
0000                             ;       see the LICENSE file in this repo for more information 
0000                             ; 
0000                             ; *****************************************************************************
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8B 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 00 08               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 02 08               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 04 08               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A 06 08               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A 08 08               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A 0A 08               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A 0E 08               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A 10 08               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   2A 12 08               LD   HL,(GETCVEC)   
0084   E9                     JP   (HL)   
0085                             ; 
0085                PUTCHAR:      
0085   E5                     PUSH   HL   
0086   2A 14 08               LD   HL,(PUTCVEC)   
0089   E3                     EX   (SP),HL   
008A   C9                     RET      
008B                             ; 
008B                RESET:       
008B   31 28 0A               LD   SP,stack   
008E   21 5F 00               LD   HL,IntRet   
0091   22 00 08               LD   (RST08),HL   
0094   22 02 08               LD   (RST10),HL   
0097   22 04 08               LD   (RST18),HL   
009A   22 06 08               LD   (RST20),HL   
009D   22 08 08               LD   (RST28),HL   
00A0   22 0A 08               LD   (RST30),HL   
00A3   22 0E 08               LD   (INTVEC),HL   
00A6   22 10 08               LD   (NMIVEC),HL   
00A9                             ; 
00A9   21 78 00               LD   HL,RXDATA   
00AC   22 12 08               LD   (GETCVEC),HL   
00AF   21 6B 00               LD   HL,TXDATA   
00B2   22 14 08               LD   (PUTCVEC),HL   
00B5                             ; 
00B5                          IF   TEC_1   
00B5                          IF   BITBANG = 0   
00B5                             ; 
00B5   3E 03                  LD   a,MRESET   
00B7   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B9                             ; 
00B9                          ENDIF      
00B9                          ENDIF      
00B9                             ; 
00B9   CD 50 00               CALL   PWRUP   
00BC   ED 56                  IM   1   
00BE   FB                     EI      
00BF                             ; 
00BF                          IF   TEC_1   
00BF                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00BF                          ELSE      ;6850      
00BF                             ; 
00BF   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C1   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C3                             ; 
00C3                          ENDIF      
00C3                          ENDIF      
00C3                             ; 
00C3                             ; 
00C3                             ; 
00C3   C3 93 02               JP   start   ; into #180 of the prog
00C6                             ; 
00C6                             ; *************************************************************************
00C6                             ; 
00C6                             ;       TecM8 1.0 Assembler for the Tec-1
00C6                             ; 
00C6                             ;       by John Hardy
00C6                             ; 
00C6                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
00C6                             ; 
00C6                             ;       see the LICENSE file in this repo for more information
00C6                             ; 
00C6                             ; *****************************************************************************
00C6                             ; **************************************************************************
00C6                             ; Constants
00C6                             ; **************************************************************************
00C6                TRUE:     EQU   -1   
00C6                FALSE:    EQU   0   
00C6                CTRL_C:   EQU   3   
00C6                CTRL_H:   EQU   8   
00C6                             ; **************************************************************************
00C6                             ; Page 0  Initialisation
00C6                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put TecM8 code from here	
0180                EOF_:     EQU   0   
0180                NEWLN_:   EQU   1   
0180                COMMENT_:   EQU   2   
0180                NUM_:     EQU   3   
0180                LABEL_:   EQU   4   
0180                IDENT_:   EQU   5   
0180                END_:     EQU   6   
0180                DIR_:     EQU   7   
0180                SYM_:     EQU   8   
0180                OPCODES:      
0180   03 41 44 43  ADC_:     .PSTR   "ADC"   
0184   03 41 44 44  ADD_:     .PSTR   "ADD"   
0188   03 41 4E 44  AND_:     .PSTR   "AND"   
018C   03 42 49 54  BIT_:     .PSTR   "BIT"   
0190   04 43 41 4C 4C CALL_:   .PSTR   "CALL"   
0195   03 43 43 46  CCF_:     .PSTR   "CCF"   
0199   02 43 50     CP_:      .PSTR   "CP"   
019C   03 43 50 44  CPD_:     .PSTR   "CPD"   
01A0   04 43 50 44 52 CPDR_:   .PSTR   "CPDR"   
01A5   03 43 50 49  CPI_:     .PSTR   "CPI"   
01A9   04 43 50 49 52 CPIR_:   .PSTR   "CPIR"   
01AE   03 43 50 4C  CPL_:     .PSTR   "CPL"   
01B2   03 44 41 41  DAA_:     .PSTR   "DAA"   
01B6   03 44 45 43  DEC_:     .PSTR   "DEC"   
01BA   02 44 49     DI_:      .PSTR   "DI"   
01BD   04 44 4A 4E 5A DJNZ_:   .PSTR   "DJNZ"   
01C2   02 45 49     EI_:      .PSTR   "EI"   
01C5   02 45 58     EX_:      .PSTR   "EX"   
01C8   03 45 58 58  EXX_:     .PSTR   "EXX"   
01CC   04 48 41 4C 54 HALT_:   .PSTR   "HALT"   
01D1   02 49 4D     IM_:      .PSTR   "IM"   
01D4   02 49 4E     IN_:      .PSTR   "IN"   
01D7   03 49 4E 43  INC_:     .PSTR   "INC"   
01DB   03 49 4E 44  IND_:     .PSTR   "IND"   
01DF   04 49 4E 44 52 INDR_:   .PSTR   "INDR"   
01E4   03 49 4E 49  INI_:     .PSTR   "INI"   
01E8   04 49 4E 49 52 INIR_:   .PSTR   "INIR"   
01ED   02 4A 50     JP_:      .PSTR   "JP"   
01F0   02 4A 52     JR_:      .PSTR   "JR"   
01F3   02 4C 44     LD_:      .PSTR   "LD"   
01F6   03 4C 44 44  LDD_:     .PSTR   "LDD"   
01FA   04 4C 44 44 52 LDDR_:   .PSTR   "LDDR"   
01FF   03 4C 44 49  LDI_:     .PSTR   "LDI"   
0203   04 4C 44 49 52 LDIR_:   .PSTR   "LDIR"   
0208   03 4E 45 47  NEG_:     .PSTR   "NEG"   
020C   03 4E 4F 50  NOP_:     .PSTR   "NOP"   
0210   02 4F 52     OR_:      .PSTR   "OR"   
0213   04 4F 54 44 52 OTDR_:   .PSTR   "OTDR"   
0218   04 4F 54 49 52 OTIR_:   .PSTR   "OTIR"   
021D   03 4F 55 54  OUT_:     .PSTR   "OUT"   
0221   04 4F 55 54 44 OUTD_:   .PSTR   "OUTD"   
0226   04 4F 55 54 49 OUTI_:   .PSTR   "OUTI"   
022B   03 50 4F 50  POP_:     .PSTR   "POP"   
022F   04 50 55 53 48 PUSH_:   .PSTR   "PUSH"   
0234   03 52 45 53  RES_:     .PSTR   "RES"   
0238   03 52 45 54  RET_:     .PSTR   "RET"   
023C   04 52 45 54 49 RETI_:   .PSTR   "RETI"   
0241   04 52 45 54 4E RETN_:   .PSTR   "RETN"   
0246   02 52 4C     RL_:      .PSTR   "RL"   
0249   03 52 4C 41  RLA_:     .PSTR   "RLA"   
024D   03 52 4C 43  RLC_:     .PSTR   "RLC"   
0251   04 52 4C 43 41 RLCA_:   .PSTR   "RLCA"   
0256   03 52 4C 44  RLD_:     .PSTR   "RLD"   
025A   02 52 52     RR_:      .PSTR   "RR"   
025D   03 52 52 41  RRA_:     .PSTR   "RRA"   
0261   03 52 52 43  RRC_:     .PSTR   "RRC"   
0265   04 52 52 43 41 RRCA_:   .PSTR   "RRCA"   
026A   03 52 52 44  RRD_:     .PSTR   "RRD"   
026E   03 52 53 54  RST_:     .PSTR   "RST"   
0272   03 53 42 43  SBC_:     .PSTR   "SBC"   
0276   03 53 43 46  SCF_:     .PSTR   "SCF"   
027A   03 53 45 54  SET_:     .PSTR   "SET"   
027E   03 53 4C 41  SLA_:     .PSTR   "SLA"   
0282   03 53 52 41  SRA_:     .PSTR   "SRA"   
0286   03 53 52 4C  SRL_:     .PSTR   "SRL"   
028A   03 53 55 42  SUB_:     .PSTR   "SUB"   
028E   03 58 4F 52  XOR_:     .PSTR   "XOR"   
0292   00                     DB   0   
0293                START:       ; entry point of TecM8
0293   31 28 0A               LD   sp,STACK   
0296   CD AB 02               CALL   init   
0299   CD 7B 04               CALL   printStr   
029C   54 65 63 4D 38 20 30 2E 30 0D 0A 00 .CSTR   "TecM8 0.0\r\n"   
02A8   C3 D4 02               JP   parse   
02AB                INIT:        
02AB   AF                     XOR   a   
02AC   32 1A 08               LD   (vPushBack),a   ; nothing in push back buffer
02AF   32 1B 08               LD   (vToken),a   ; NUL_ token
02B2   21 28 08               LD   hl,chars   
02B5   22 1E 08               LD   (vCharPtr),hl   
02B8   21 28 0D               LD   hl,assembly   
02BB   22 20 08               LD   (vAsmPtr),hl   
02BE   21 28 0A               LD   hl,strings   
02C1   22 22 08               LD   (vStrPtr),hl   
02C4   22 1C 08               LD   (vTokenVal),hl   
02C7   21 28 0B               LD   hl,symbols   
02CA   22 24 08               LD   (vSymPtr),hl   
02CD   21 28 0C               LD   hl,exprs   
02D0   22 26 08               LD   (vExprPtr),hl   
02D3   C9                     RET      
02D4                PARSE:       
02D4   CD FB 02               CALL   statementList   
02D7   CD 7B 04               CALL   printStr   
02DA   50 61 72 73 69 6E 67 20 63 6F 6D 70 6C 65 74 65 64 20 73 75 63 63 65 73 73 66 75 6C 6C 79 2E 00 .CSTR   "Parsing completed successfully."   ; 
02FA   76                     HALT      
02FB                STATEMENTLIST:      
02FB   3A 1B 08               LD   a,(vToken)   
02FE   FE 00                  CP   EOF_   
0300   C8                     RET   z   
0301   CD 1F 03               CALL   statement   
0304   FE 06                  CP   END_   
0306   CD 20 03               CALL   match   
0309   28 F0                  JR   z,statementList   
030B   CD 81 04               CALL   error   
030E   45 78 70 65 63 74 65 64 20 6E 65 77 6C 69 6E 65 00 .CSTR   "Expected newline"   
031F                STATEMENT:      
031F   C9                     RET      
0320                MATCH:       
0320   C0                     RET   nz   
0321   F5                     PUSH   af   
0322   CD 29 03               CALL   nextToken   
0325   6F                     LD   l,a   
0326   F1                     POP   af   
0327   7D                     LD   a,l   
0328   C9                     RET      
0329                             ; nextToken is a lexer function that reads characters from the input and classifies
0329                             ; them into different token types. It handles whitespace, end of input, newlines,
0329                             ; comments, identifiers, labels, directives, hexadecimal numbers, and other symbols.
0329                             ; Input: None
0329                             ; Output:
0329                             ; a: contains the type of the next token.
0329                             ; hl: contains the value associated with the next token.
0329                             ; Destroyed: None
0329                NEXTTOKEN:      
0329   21 00 00               LD   hl,0   
032C                NEXTTOKEN1:      
032C   CD 57 04               CALL   nextChar   ; Get the next character
032F   FE 20                  CP   " "   ; Is it a space?
0331   28 F9                  JR   z,nextToken1   ; If yes, skip it and get the next character
0333   FE 09                  CP   "\t"   ; Is it a tab?
0335   28 F5                  JR   z,nextToken1   ; If yes, skip it and get the next character
0337   B7                     OR   a   ; Is it null (end of input)?
0338   20 03                  JR   nz,nextToken2   ; If not, continue to the next check
033A   3E 00                  LD   a,EOF_   ; If yes, return with EOF token
033C   C9                     RET      
033D                NEXTTOKEN2:      
033D   FE 0A                  CP   "\n"   ; Is it a newline?
033F   20 03                  JR   nz,nextToken2x   ; If not, continue to the next check
0341   3E 01                  LD   a,NEWLN_   ; If yes, return with NEWLN token
0343   C9                     RET      
0344                NEXTTOKEN2X:      
0344   FE 3B                  CP   ";"   ; Is it a comment?
0346   C4 53 03               CALL   nz,nextToken4   ; If not, continue to the next check
0349                NEXTTOKEN3:      
0349   CD 57 04               CALL   nextChar   ; Get the next character in the comment
034C   FE 21                  CP   " "+1   ; Loop until the next control character
034E   30 F9                  JR   nc,nextToken3   
0350   3E 02                  LD   a,COMMENT_   ; Return with COMMENT token
0352   C9                     RET      
0353                NEXTTOKEN4:      
0353   FE 5F                  CP   "_"   ; Is it an identifier?
0355   28 05                  JR   z,nextToken5   ; If yes, continue to the next check
0357   CD C9 03               CALL   isAlphaNum   ; If not, check if it's alphanumeric
035A   30 13                  JR   nc,nextToken7x   ; If not, continue to the next check
035C                NEXTTOKEN5:      
035C   CD A5 03               CALL   ident   ; Parse the identifier
035F   CD 57 04               CALL   nextChar   ; Get the next character
0362   FE 3A                  CP   ":"   ; Is it a label?
0364   20 03                  JR   nz,nextToken6   ; If not, continue to the next check
0366   3E 04                  LD   a,LABEL_   ; If yes, return with LABEL token
0368   C9                     RET      
0369                NEXTTOKEN6:      
0369   C4 65 04               CALL   nz,pushBackChar   ; Push back the character if it's not null
036C   3E 05                  LD   a,IDENT_   ; Return with IDENT token
036E   C9                     RET      
036F                NEXTTOKEN7X:      
036F   FE 2E                  CP   "."   ; Is it a directive?
0371   20 06                  JR   nz,nextToken7   ; If not, continue to the next check
0373   CD C5 03               CALL   directive   ; Parse the directive
0376   3E 07                  LD   a,DIR_   ; Return with DIR token
0378   C9                     RET      
0379                NEXTTOKEN7:      
0379   FE 24                  CP   "$"   ; Is it a hexadecimal number?
037B   20 0D                  JR   nz,nextToken8   ; If not, continue to the next check
037D   CD 57 04               CALL   nextChar   ; Get the next character
0380   CD DB 03               CALL   isHexDigit   ; Check if it's a hexadecimal digit
0383   38 05                  JR   c,nextToken8   ; If not, continue to the next check
0385   CD 65 04               CALL   pushBackChar   ; Push back the character
0388   18 15                  JR   nextToken10   ; Jump to the next check
038A                NEXTTOKEN8:      
038A   CD 11 04               CALL   hex   ; Parse the hexadecimal number
038D   3E 03                  LD   a,NUM_   ; Return with NUM token
038F   C9                     RET      
0390   FE 2D                  CP   "-"   ; Is it a negative number?
0392   28 05                  JR   z,nextToken9   ; If yes, continue to the next check
0394   CD E1 03               CALL   isDigit   ; Check if it's a digit
0397   18 06                  JR   nextToken10   ; Jump to the next check
0399                NEXTTOKEN9:      
0399   CD E8 03               CALL   number   ; Parse the number
039C   3E 03                  LD   a,NUM_   ; Return with NUM token
039E   C9                     RET      
039F                NEXTTOKEN10:      
039F   6F                     LD   l,a   ; Load the token into L
03A0   26 00                  LD   h,0   ; Clear H
03A2   3E 08                  LD   a,SYM_   ; Return with SYM token
03A4   C9                     RET      
03A5                             ; collects adds ident to string heap
03A5                             ; returns hl = ptr to ident
03A5                             ; destroys a,d,e,h,l
03A5                             ; updates vStrPtr
03A5                IDENT:       
03A5   2A 22 08               LD   hl,(vStrPtr)   ; hl = top of strings heap
03A8   23                     INC   hl   ; skip length byte
03A9                IDENT1:      
03A9   77                     LD   (hl),a   ; write char
03AA   23                     INC   hl   
03AB   CD 57 04               CALL   nextChar   
03AE   FE 5F                  CP   "_"   
03B0   28 F7                  JR   z,ident1   
03B2   CD C9 03               CALL   isAlphanum   
03B5   CD 65 04               CALL   pushBackChar   
03B8   ED 5B 22 08            LD   de,(vStrPtr)   ; de = string start
03BC   22 22 08               LD   (vStrPtr),hl   ; update top of strings heap
03BF   B7                     OR   a   
03C0   ED 52                  SBC   hl,de   ; hl = length, de = strPtr
03C2   EB                     EX   de,hl   ; e = len, hl = strPtr
03C3   73                     LD   (hl),e   ; save lsb(length)
03C4   C9                     RET      
03C5                DIRECTIVE:      
03C5   21 00 00               LD   hl,0   
03C8   C9                     RET      
03C9                             ;     jr c,ident1                     ; loop while alpha numeric
03C9                             ;     cp ":"
03C9                             ;     jr nz,ident2
03C9                             ;     call endStr
03C9                             ;     scf
03C9                             ;     ret
03C9                             ; ident2:
03C9                             ;     call endStr
03C9                             ;     scf                             ; clear carry flag
03C9                             ;     ccf
03C9                             ;     ret
03C9                             ;     ld (hl),a                       ; write char
03C9                             ;     inc hl
03C9                             ;     call nextChar
03C9                             ; ident3:
03C9                             ;     cp " "                          ; is it a control char? \0 \r \n ?
03C9                             ;     jr c,ident5
03C9                             ;     cp ","                          ; is it end of arg?
03C9                             ;     jr z,ident5
03C9                             ;     cp ";"                          ; is it a comment at end of line
03C9                             ;     jr z,ident5
03C9                             ;     cp ")"                          ; todo: check nesting
03C9                             ;     jr z,ident5
03C9                             ; ident4:
03C9                             ;     call endStr
03C9                             ;     scf                             ; clear carry flag
03C9                             ;     ccf
03C9                             ;     ret
03C9                             ; ident5:
03C9                             ;     call pushBackChar               ; push the char back to input
03C9                             ;     jr ident4
03C9                             ; endStr: completes adding a string to the strings heap area
03C9                             ; and stores the length at the start of the string.
03C9                             ; Input:
03C9                             ; hl: points to the end of the string.
03C9                             ; Output:
03C9                             ; hl: points to the start of the string.
03C9                             ; vStrPtr: is updated to pointer to memory after the string
03C9                             ; Destroyed: None
03C9                             ; endStr:
03C9                             ;     ld de,(vStrPtr)                 ; de = string start
03C9                             ;     ld (vStrPtr),hl                 ; update top of strings heap
03C9                             ;     or a
03C9                             ;     sbc hl,de                       ; hl = length, de = strPtr
03C9                             ;     ex de,hl                        ; e = len, hl = strPtr
03C9                             ;     ld (hl),e                       ; save lsb(length)
03C9                             ;     ret
03C9                             ; isAlphaNum checks if the character in the a register is an alphanumeric character
03C9                             ; (either uppercase or lowercase).
03C9                             ; If the character is alphabetic, it converts it to uppercase and sets the carry flag.
03C9                             ; If the character is not alphabetic, it clears the carry flag.
03C9                             ; Input:
03C9                             ; a: Contains the character to be checked.
03C9                             ; Output:
03C9                             ; a: Contains the uppercase version of the input character if it was alphabetic.
03C9                             ; cf: Set if the input character was alphabetic, cleared otherwise.
03C9                             ; Destroyed: c
03C9                ISALPHANUM:      
03C9   CD E1 03               CALL   isDigit   
03CC   C8                     RET   z   ; falls thru to isAlpha
03CD                             ; isAlpha: checks if the character in the a register is an alphabetic character
03CD                             ; (either uppercase or lowercase).
03CD                             ; If the character is alphabetic, it converts it to uppercase and sets the carry flag.
03CD                             ; Input:
03CD                             ; a: Contains the character to be checked.
03CD                             ; Output:
03CD                             ; a: Contains the uppercase version of the input character if it was alphabetic.
03CD                             ; cf: Set if the input character was alphabetic, cleared otherwise.
03CD                             ; Destroyed: c
03CD                ISALPHA:      
03CD   0E 5B                  LD   c,"Z"+1   ; last uppercase letter
03CF                ISALPHA0:      
03CF   FE 61                  CP   "a"   ; is char lowercase?
03D1   38 02                  JR   c,isAlpha1   
03D3   D6 20                  SUB   $20   ; yes, convert a to uppercase
03D5                ISALPHA1:      
03D5   B9                     CP   c   ; is char > last letter?
03D6   D0                     RET   nc   ; yes, exit with cf cleared
03D7   FE 41                  CP   "A"   ; is char an uppercase letter ?
03D9   3F                     CCF      ; invert cf
03DA   C9                     RET      
03DB                             ; isHexDigit: checks if the character in the a register is a hexadecimal
03DB                             ; digit (0-9,A-F,a-f). If the character is a hex digit, it sets the carry flag.
03DB                             ; Input:
03DB                             ; a: Contains the character to be checked.
03DB                             ; Output:
03DB                             ; cf: Set if the input character was a digit, cleared otherwise.
03DB                             ; Destroyed: none
03DB                ISHEXDIGIT:      
03DB   0E 47                  LD   c,"F"+1   
03DD   CD CF 03               CALL   isAlpha0   
03E0   C8                     RET   z   ; fall thru to isDigit
03E1                             ; isDigit: checks if the character in the a register is a decimal
03E1                             ; digit (0-9). If the character is a decimal digit, it sets the carry flag.
03E1                             ; Input:
03E1                             ; a: Contains the character to be checked.
03E1                             ; Output:
03E1                             ; cf: Set if the input character was a digit, cleared otherwise.
03E1                             ; Destroyed: none
03E1                ISDIGIT:      
03E1   FE 3A                  CP   "9"+1   ; is char > "9"?
03E3   D0                     RET   nc   ; yes, exit with cf cleared
03E4   FE 30                  CP   "0"   ; is char a decimal digit ?
03E6   3F                     CCF      ; invert cf
03E7   C9                     RET      
03E8                             ; number: parse a number from the input. It handles both decimal and hexadecimal
03E8                             ; numbers, and also supports negative numbers.
03E8                             ; Input: None
03E8                             ; Output:
03E8                             ; hl: Contains the parsed number.
03E8                             ; Destroyed: None
03E8                             ; vTemp1: A temporary memory location used to store the sign of the number.
03E8                NUMBER:      
03E8   FE 2D                  CP   "-"   ; Is it a negative number?
03EA   3E FF                  LD   a,-1   ; a = sign flag
03EC   28 01                  JR   z,num1   
03EE   3C                     INC   a   
03EF                NUM1:        
03EF   32 16 08               LD   (vTemp1),a   ; Store the sign flag in vTemp1
03F2   CD 57 04               CALL   nextChar   ; Get the next character
03F5   FE 24                  CP   "$"   ; Is it a hexadecimal number?
03F7   20 05                  JR   nz,num2   
03F9   CD 11 04               CALL   hex   ; If yes, parse the hexadecimal number
03FC   18 06                  JR   num3   
03FE                NUM2:        
03FE   CD 65 04               CALL   pushBackChar   ; Push back the character
0401   CD 3C 04               CALL   decimal   ; Parse the decimal number
0404                NUM3:        
0404   3A 16 08               LD   a,(vTemp1)   ; Load the sign from vTemp1
0407   3C                     INC   a   ; Increment a
0408   C0                     RET   nz   
0409   EB                     EX   de,hl   ; negate the value of HL
040A   21 00 00               LD   hl,0   
040D   B7                     OR   a   
040E   ED 52                  SBC   hl,de   
0410   C9                     RET      
0411                             ; hex: parses a hexadecimal number
0411                             ; Input: none
0411                             ; Output:
0411                             ; hl: parsed number
0411                             ; Destroyed: a
0411                HEX:         
0411   21 00 00               LD   hl,0   ; Initialize HL to 0 to hold the result
0414                HEX1:        
0414   CD 57 04               CALL   nextChar   
0417   FE 30                  CP   "0"   ; Compare with ASCII "0"
0419   D8                     RET   c   ; If less, exit
041A   FE 3A                  CP   "9"+1   ; Compare with ASCII "9"
041C   38 0F                  JR   c,valid   ; If less or equal, jump to valid
041E   FE 61                  CP   "a"   ; is char lowercase letter?
0420   38 02                  JR   c,hex2   
0422   D6 20                  SUB   $20   ; yes, convert a to uppercase
0424                HEX2:        
0424   FE 41                  CP   "A"   ; Compare with ASCII "A"
0426   D8                     RET   c   ; If less, exit invalid
0427   FE 47                  CP   "F"+1   ; Compare with ASCII "F"
0429   38 00                  JR   c,upper   ; If less or equal, jump to upper
042B                UPPER:       
042B   D6 37                  SUB   $37   ; Convert from ASCII to hex
042D                VALID:       
042D   D6 30                  SUB   "0"   ; Convert from ASCII to numeric value
042F   D8                     RET   c   ; If the result is negative, the character was not a valid hexadecimal digit, so return
0430   FE 10                  CP   $10   ; Compare the result with $10
0432   D0                     RET   nc   ; If the result is $10 or more, the character was not a valid hexadecimal digit, so return
0433   29                     ADD   hl,hl   ; Multiply the number in HL by 16 by shifting it left 4 times
0434   29                     ADD   hl,hl   ; This is done because each hexadecimal digit represents 16^n where n is the position of the digit from the right
0435   29                     ADD   hl,hl   
0436   29                     ADD   hl,hl   
0437   85                     ADD   a,l   ; Add the new digit to the number in HL
0438   6F                     LD   l,a   ; Store the result back in L
0439   C3 14 04               JP   hex1   ; Jump back to hex1 to process the next character
043C                             ; decimal: parses a decimal number
043C                             ; Input: none
043C                             ; Output:
043C                             ; hl: parsed number.
043C                             ; Destroyed registers:
043C                             ; A: Used for temporary storage and calculations.
043C                             ; DE: Used for temporary storage and calculations.
043C                DECIMAL:      
043C   21 00 00               LD   hl,0   ; Initialize HL to 0 to hold the result
043F                DECIMAL1:      
043F   CD 57 04               CALL   nextChar   
0442   D6 30                  SUB   "0"   ; Subtract ASCII "0" to convert from ASCII to binary
0444   D8                     RET   c   ; If the result is negative, the character was not a digit; return
0445   FE 0A                  CP   10   ; Compare the result with 10
0447   D0                     RET   nc   ; If the result is 10 or more, the character was not a digit; return
0448   03                     INC   bc   ; Increment BC to point to the next digit
0449   54 5D                  LD   de,hl   ; Copy HL to DE
044B   29                     ADD   hl,hl   ; Multiply HL by 2
044C   29                     ADD   hl,hl   ; Multiply HL by 4
044D   19                     ADD   hl,de   ; Add DE to HL to multiply HL by 5
044E   29                     ADD   hl,hl   ; Multiply HL by 10
044F   85                     ADD   a,l   ; Add the digit in A to the low byte of HL
0450   6F                     LD   l,a   ; Store the result in the low byte of HL
0451   3E 00                  LD   a,0   ; Clear A
0453   8C                     ADC   a,h   ; Add the carry from the previous addition to the high byte of HL
0454   67                     LD   h,a   ; Store the result in the high byte of HL
0455   18 E8                  JR   decimal1   ; Jump back to the start of the loop
0457                             ; nextChar: checks if there is a character that has been pushed back for re-reading.
0457                             ; If there is, it retrieves that character, otherwise it fetches a new character
0457                             ; from the input.
0457                             ; Input: none
0457                             ; Output:
0457                             ; a: Contains the next character to be processed, either retrieved from the
0457                             ; pushback buffer or fetched from the input.
0457                             ; Destroyed: None.
0457                NEXTCHAR:      
0457   CB 77                  BIT   7,(vPushBack)   ; Check the high bit of the pushback buffer
0459   CA 81 00               JP   z,getchar   ; If the high bit is 0, jump to getchar
045C   3A 1A 08               LD   a,(vPushBack)   ; If the high bit is 1, load the pushed back character into A
045F   E6 7F                  AND   0x7F   ; Clear the high bit
0461   32 1A 08               LD   (vPushBack),a   ; Store the character back in the buffer
0464   C9                     RET      ; Return with the pushed back character in A
0465                             ; pushBackChar: push back a character for re-reading. It sets the high bit of the
0465                             ; character as a flag to indicate that this character has been pushed back, and
0465                             ; stores the character in the pushback buffer.
0465                             ; Input:
0465                             ; a: Contains the character to be pushed back.
0465                             ; Output: None.
0465                             ; Destroyed: None.
0465                PUSHBACKCHAR:      
0465   F6 80                  OR   0x80   ; Set the high bit of the character to be pushed back
0467   32 1A 08               LD   (vPushBack),a   ; Store the character in the pushback buffer
046A   C9                     RET      
046B                             ;     ld bc,(vCharPtr)
046B                             ;     ld a,(bc)
046B                             ;     inc bc
046B                             ;     ld (vCharPtr),bc
046B                             ;     or a
046B                             ;     ret nz
046B                             ;     call nextLine
046B                             ;     jr nextChar
046B                             ; nextLine:
046B                             ;     call prompt
046B                             ;     ld bc,chars             ; load bc with start of chars buffer
046B                             ; nextLine2:
046B                             ;     call getchar            ; get character from serial port
046B                             ;     cp $20			        ; compare to space
046B                             ;     jr c,nextLine3		
046B                             ;     ld (bc),A               ; store the character in textbuf
046B                             ;     inc bc
046B                             ;     call putchar            ; echo character to screen
046B                             ;     jr nextLine2            ; wait for next character
046B                             ; nextLine3:                  ; control char
046B                             ;     cp "\r"                 ; carriage return? ascii 13
046B                             ;     jr Z,nextLine4		    ; if anything else its control char
046B                             ;     cp "\n"                 ; carriage return? ascii 13
046B                             ;     jr Z,nextLine4		    ; if anything else its control char
046B                             ;     cp CTRL_H               ; backSpace ?
046B                             ;     jr nz,nextLine2         ; no, ignore
046B                             ;     ld hl,chars             ; is bc already at start of chars buffer
046B                             ;     or a
046B                             ;     sbc hl,bc
046B                             ;     ld a,h
046B                             ;     or l
046B                             ;     jr z, nextLine2         ; if so, ignore backspace
046B                             ;     dec bc
046B                             ;     call printStr           ; backspace over previous letter
046B                             ;     .cstr "\b \b"           ; erase letter
046B                             ;     jr nextLine2
046B                             ; nextLine4:
046B                             ;     xor a                   ; store null in text buffer
046B                             ;     ld (bc),a
046B                             ;     call crlf               ; echo newline to screen
046B                             ;     ld bc,chars             ; Instructions stored on heap at address HERE, we pressed enter
046B                             ;     ld (vCharPtr),bc        ; point vCharPtr to start of chars buffer
046B                             ;     ret
046B                             ; *******************************************************************************
046B                             ; *********  END OF MAIN   ******************************************************
046B                             ; *******************************************************************************
046B                             ; next:
046B                             ;     inc bc                  ; Increment the IP
046B                             ;     ld a,(bc)               ; Get the next character and dispatch
046B                             ;     or a                    ; is it NUL?
046B                             ;     jr z,exit
046B                             ;     cp "\n"                 ; is it newline?
046B                             ;     jr z,interpret
046B                             ;     cp "0"
046B                             ;     ld d,"!"
046B                             ;     jr c,op
046B                             ;     cp "9"+1
046B                             ;     jr c,num
046B                             ;     cp "A"
046B                             ;     ld d,"!"+10
046B                             ;     jr c,op
046B                             ;     cp "Z"+1
046B                             ;     jr c,callx
046B                             ;     cp "a"
046B                             ;     ld d,"!"+10+26
046B                             ;     jr c,op
046B                             ;     cp "z"+1
046B                             ;     jp c,var
046B                             ;     ld d,"!"+10+26+26
046B                             ; op:
046B                             ;     sub d
046B                             ;     jr c,next
046B                             ;     add a,lsb(opcodes)
046B                             ;     ld l,A                      ; Index into table
046B                             ;     ld h,msb(opcodes)           ; Start address of jump table
046B                             ;     ld l,(hl)                   ; get low jump address
046B                             ;     inc h                       ; msb on next page
046B                             ;     jp (hl)                     ; Jump to routine
046B                             ; exit:
046B                             ;     inc bc			; store offests into a table of bytes, smaller
046B                             ;     ld de,bc
046B                             ;     ld ix,(vBasePtr)        ;
046B                             ;     call rpop               ; Restore old base pointer
046B                             ;     ld (vBasePtr),hl
046B                             ;     call rpop               ; Restore Instruction pointer
046B                             ;     ld bc,hl
046B                             ;     EX de,hl
046B                             ;     jp (hl)
046B                             ; num:
046B                             ; 	ld hl,$0000				    ; Clear hl to accept the number
046B                             ;     cp "-"
046B                             ;     jr nz,num0
046B                             ;     inc bc                      ; move to next char, no flags affected
046B                             ; num0:
046B                             ;     ex af,af'                   ; save zero flag = 0 for later
046B                             ; num1:
046B                             ;     ld a,(bc)                   ; read digit
046B                             ;     sub "0"                     ; less than 0?
046B                             ;     jr c, num2                  ; not a digit, exit loop
046B                             ;     cp 10                       ; greater that 9?
046B                             ;     jr nc, num2                 ; not a digit, exit loop
046B                             ;     inc bc                      ; inc IP
046B                             ;     ld de,hl                    ; multiply hl * 10
046B                             ;     add hl,hl
046B                             ;     add hl,hl
046B                             ;     add hl,de
046B                             ;     add hl,hl
046B                             ;     add a,l                     ; add digit in a to hl
046B                             ;     ld l,a
046B                             ;     ld a,0
046B                             ;     adc a,h
046B                             ;     ld h,a
046B                             ;     jr num1
046B                             ; num2:
046B                             ;     dec bc
046B                             ;     ex af,af'                   ; restore zero flag
046B                             ;     jr nz, num3
046B                             ;     ex de,hl                    ; negate the value of hl
046B                             ;     ld hl,0
046B                             ;     or a                        ; jump to sub2
046B                             ;     sbc hl,de
046B                             ; num3:
046B                             ;     push hl                     ; Put the number on the stack
046B                             ;     jp (iy)                     ; and process the next character
046B                             ; callx:
046B                             ;     call lookupRef0
046B                             ;     ld E,(hl)
046B                             ;     inc hl
046B                             ;     ld D,(hl)
046B                             ;     ld a,D                      ; skip if destination address is null
046B                             ;     or E
046B                             ;     jr Z,call2
046B                             ;     ld hl,bc
046B                             ;     inc bc                      ; read next char from source
046B                             ;     ld a,(bc)                   ; if ; to tail call optimise
046B                             ;     cp ";"                      ; by jumping to rather than calling destination
046B                             ;     jr Z,call1
046B                             ;     call rpush                  ; save Instruction Pointer
046B                             ;     ld hl,(vBasePtr)
046B                             ;     call rpush
046B                             ;     ld (vBasePtr),ix
046B                             ; call1:
046B                             ;     ld bc,de
046B                             ;     dec bc
046B                             ; call2:
046B                             ;     jp (iy)
046B                             ; var:
046B                             ;     ld hl,vars
046B                             ;     call lookupRef
046B                             ; var1:
046B                             ;     ld (vPointer),hl
046B                             ;     ld d,0
046B                             ;     ld e,(hl)
046B                             ;     ld a,(vByteMode)
046B                             ;     inc a                       ; is it byte?
046B                             ;     jr z,var2
046B                             ;     inc hl
046B                             ;     ld d,(hl)
046B                             ; var2:
046B                             ;     push de
046B                             ;     jp (iy)
046B                             ; lookupRef0:
046B                             ;     ld hl,defs
046B                             ;     sub "A"
046B                             ;     jr lookupRef1
046B                             ; lookupRef:
046B                             ;     sub "a"
046B                             ; lookupRef1:
046B                             ;     add a,a
046B                             ;     add a,l
046B                             ;     ld l,a
046B                             ;     ld a,0
046B                             ;     ADC a,h
046B                             ;     ld h,a
046B                             ;     XOR a
046B                             ;     or e                        ; sets Z flag if A-Z
046B                             ;     ret
046B                PROMPT:      
046B   CD 7B 04               CALL   printStr   
046E   0D 0A 3E 20 00         .CSTR   "\r\n> "   
0473   C9                     RET      
0474                CRLF:        
0474   CD 7B 04               CALL   printStr   
0477   0D 0A 00               .CSTR   "\r\n"   
047A   C9                     RET      
047B                             ; printStr:
047B                             ;     EX (sp),hl		                ; swap			
047B                             ;     call putStr		
047B                             ;     inc hl			                ; inc past null
047B                             ;     EX (sp),hl		                ; put it back	
047B                             ;     ret
047B                PRINTSTR:      
047B   E1                     POP   hl   ; "return" address is address of string			
047C   CD 8A 04               CALL   putStr   
047F   23                     INC   hl   ; inc past null
0480   E9                     JP   (hl)   ; put it back	
0481                ERROR:       
0481   E1                     POP   hl   
0482   CD 8A 04               CALL   putStr   
0485   76                     HALT      
0486                PUTSTR0:      
0486   CD 85 00               CALL   putchar   
0489   23                     INC   hl   
048A                PUTSTR:      
048A   7E                     LD   a,(hl)   
048B   B7                     OR   A   
048C   20 F8                  JR   nz,putStr0   
048E   C9                     RET      
048F                RPUSH:       
048F   DD 2B                  DEC   ix   
0491   DD 74 00               LD   (ix+0),H   
0494   DD 2B                  DEC   ix   
0496   DD 75 00               LD   (ix+0),L   
0499   C9                     RET      
049A                RPOP:        
049A   DD 6E 00               LD   L,(ix+0)   
049D   DD 23                  INC   ix   
049F   DD 66 00               LD   H,(ix+0)   
04A2   DD 23                  INC   ix   
04A4                RPOP2:       
04A4   C9                     RET      
04A5                             ; enter:
04A5                             ;     ld hl,bc
04A5                             ;     call rpush                      ; save Instruction Pointer
04A5                             ;     ld hl,(vBasePtr)
04A5                             ;     call rpush
04A5                             ;     ld (vBasePtr),ix
04A5                             ;     pop bc
04A5                             ;     dec bc
04A5                             ;     jp (iy)
04A5                             ; hl = value
04A5                PRINTDEC:      
04A5   CB 7C                  BIT   7,h   
04A7   28 0B                  JR   z,printDec2   
04A9   3E 2D                  LD   a,"-"   
04AB   CD 85 00               CALL   putchar   
04AE   AF                     XOR   a   
04AF   95                     SUB   l   
04B0   6F                     LD   l,a   
04B1   9F                     SBC   a,a   
04B2   94                     SUB   h   
04B3   67                     LD   h,a   
04B4                PRINTDEC2:      
04B4   C5                     PUSH   bc   
04B5   0E 00                  LD   c,0   ; leading zeros flag = false
04B7   11 F0 D8               LD   de,-10000   
04BA   CD D6 04               CALL   printDec4   
04BD   11 18 FC               LD   de,-1000   
04C0   CD D6 04               CALL   printDec4   
04C3   11 9C FF               LD   de,-100   
04C6   CD D6 04               CALL   printDec4   
04C9   1E F6                  LD   e,-10   
04CB   CD D6 04               CALL   printDec4   
04CE   0C                     INC   c   ; flag = true for at least digit
04CF   1E FF                  LD   e,-1   
04D1   CD D6 04               CALL   printDec4   
04D4   C1                     POP   bc   
04D5   C9                     RET      
04D6                PRINTDEC4:      
04D6   06 2F                  LD   b,"0"-1   
04D8                PRINTDEC5:      
04D8   04                     INC   b   
04D9   19                     ADD   hl,de   
04DA   38 FC                  JR   c,printDec5   
04DC   ED 52                  SBC   hl,de   
04DE   3E 30                  LD   a,"0"   
04E0   B8                     CP   b   
04E1   20 05                  JR   nz,printDec6   
04E3   AF                     XOR   a   
04E4   B1                     OR   c   
04E5   C8                     RET   z   
04E6   18 01                  JR   printDec7   
04E8                PRINTDEC6:      
04E8   0C                     INC   c   
04E9                PRINTDEC7:      
04E9   78                     LD   a,b   
04EA   C3 85 00               JP   putchar   
04ED                             ; def:                                ; Create a colon definition
04ED                             ;     inc bc
04ED                             ;     ld  a,(bc)                  ; Get the next character
04ED                             ;     cp ":"                      ; is it anonymouse
04ED                             ;     jr nz,def0
04ED                             ;     inc bc
04ED                             ;     ld de,(vHeapPtr)            ; return start of definition
04ED                             ;     push de
04ED                             ;     jr def1
04ED                             ; def0:
04ED                             ;     call lookupRef0
04ED                             ;     ld de,(vHeapPtr)            ; start of defintion
04ED                             ;     ld (hl),E                   ; Save low byte of address in CFA
04ED                             ;     inc hl
04ED                             ;     ld (hl),D                   ; Save high byte of address in CFA+1
04ED                             ;     inc bc
04ED                             ; def1:                               ; Skip to end of definition
04ED                             ;     ld a,(bc)                   ; Get the next character
04ED                             ;     inc bc                      ; Point to next character
04ED                             ;     ld (de),A
04ED                             ;     inc de
04ED                             ;     cp ";"                      ; Is it a semicolon
04ED                             ;     jr Z, def2                  ; end the definition
04ED                             ;     jr  def1                    ; get the next element
04ED                             ; def2:
04ED                             ;     dec bc
04ED                             ; def3:
04ED                             ;     ld (vHeapPtr),de            ; bump heap ptr to after definiton
04ED                             ;     jp (iy)
04ED                             ; opcodes:
04ED                             ;     db    lsb(bang_)        ;   !
04ED                             ;     db    lsb(dquote_)      ;   "
04ED                             ;     db    lsb(hash_)        ;   #
04ED                             ;     db    lsb(dollar_)      ;   $
04ED                             ;     db    lsb(percent_)     ;   %
04ED                             ;     db    lsb(amper_)       ;   &
04ED                             ;     db    lsb(quote_)       ;   '
04ED                             ;     db    lsb(lparen_)      ;   (
04ED                             ;     db    lsb(rparen_)      ;   )
04ED                             ;     db    lsb(star_)        ;   *
04ED                             ;     db    lsb(plus_)        ;   +
04ED                             ;     db    lsb(comma_)       ;   ,
04ED                             ;     db    lsb(minus_)       ;   -
04ED                             ;     db    lsb(dot_)         ;   .
04ED                             ;     db    lsb(slash_)       ;   /	
04ED                             ;     db    lsb(colon_)       ;    :
04ED                             ;     db    lsb(semi_)        ;    ;
04ED                             ;     db    lsb(lt_)          ;    <
04ED                             ;     db    lsb(eq_)          ;    =
04ED                             ;     db    lsb(gt_)          ;    >
04ED                             ;     db    lsb(question_)    ;    ?
04ED                             ;     db    lsb(at_)          ;    @
04ED                             ;     db    lsb(lbrack_)      ;    [
04ED                             ;     db    lsb(bslash_)      ;    \
04ED                             ;     db    lsb(rbrack_)      ;    ]
04ED                             ;     db    lsb(caret_)       ;    ^
04ED                             ;     db    lsb(underscore_)  ;    _
04ED                             ;     db    lsb(grave_)       ;    `
04ED                             ;     db    lsb(lbrace_)      ;    {
04ED                             ;     db    lsb(pipe_)        ;    |
04ED                             ;     db    lsb(rbrace_)      ;    }
04ED                             ;     db    lsb(tilde_)       ;    ~
04ED                             ; .align $100
04ED                             ; nop_:
04ED                             ; bslash_:
04ED                             ; quote_:                          ; Discard the top member of the stack
04ED                             ; at_:
04ED                             ; underscore_:
04ED                             ; percent_:
04ED                             ; amper_:
04ED                             ; pipe_: 		
04ED                             ; caret_:		
04ED                             ; tilde_:
04ED                             ; invert:				        ; Bitwise INVert the top member of the stack
04ED                             ; dquote_:
04ED                             ; comma_:                          ; print hexadecimal
04ED                             ; lbrace_:
04ED                             ; rbrace_:
04ED                             ; dollar_:
04ED                             ; minus_:       		        ; Subtract the value 2nd on stack from top of stack
04ED                             ; eq_:
04ED                             ; gt_:
04ED                             ; lt_:
04ED                             ; grave_:
04ED                             ; rparen_:
04ED                             ; lbrack_:
04ED                             ; rbrack_:
04ED                             ; lparen_:
04ED                             ; slash_:
04ED                             ; question_:
04ED                             ; hash_:
04ED                             ; star_:
04ED                             ;     jp (iy)
04ED                             ; bang_:                      ; Store the value at the address placed on the top of the stack
04ED                             ; plus_:                           ; add the top 2 members of the stack
04ED                             ; dot_:
04ED                             ; semi_:
04ED                             ; colon_:
0800                          .ORG   RAMSTART   
0800                RST08:    DS   2   
0802                RST10:    DS   2   
0804                RST18:    DS   2   
0806                RST20:    DS   2   
0808                RST28:    DS   2   
080A                RST30:    DS   2   ; 
080C                BAUD:     DS   2   ; 
080E                INTVEC:   DS   2   ; 
0810                NMIVEC:   DS   2   ; 
0812                GETCVEC:   DS   2   ; 
0814                PUTCVEC:   DS   2   ; 
0816                VTEMP1:   DS   2   ; temp var 1
0818                VTEMP2:   DS   2   ; temp var 2
081A                VPUSHBACK:   DS   1   ; buffer for pushed back character on input
081B                VTOKEN:   DS   1   ; byte containing enum of token type
081C                VTOKENVAL:   DS   2   ; pointer to start of token value
081E                VCHARPTR:   DS   2   ; pointer to char position into input buffer
0820                VASMPTR:   DS   2   ; pointer to assembly point
0822                VSTRPTR:   DS   2   ; pointer to string stack
0824                VSYMPTR:   DS   2   ; pointer to symbol stack
0826                VEXPRPTR:   DS   2   ; pointer to expression stack
0828                CHARS:    DS   $100   ; page aligned, 256 bytes , a long line!
0928                          DS   $100   
0A28                STACK:       ; grows down
0A28                STRINGS:   DS   $100   ; string heap - grows up
0B28                SYMBOLS:   DS   $100   ; symbol heap - grows up
0C28                EXPRS:    DS   $100   ; expression heap - grows up
0D28                ASSEMBLY:      


TEC_1:              0001 DEFINED AT LINE 1 IN constants.asm
RC2014:             0000 DEFINED AT LINE 2 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 4 IN constants.asm
LOADER:             0000 DEFINED AT LINE 20 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 21 IN constants.asm
ROMSTART:           0000 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 116 IN IOSerial.asm
                    > USED AT LINE 122 IN IOSerial.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 134 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 146 IN IOSerial.asm
                    > USED AT LINE 152 IN IOSerial.asm
                    > USED AT LINE 158 IN IOSerial.asm
                    > USED AT LINE 200 IN IOSerial.asm
                    > USED AT LINE 26 IN MAIN.asm
RAMSTART:           0800 DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 1 IN ram.asm
ROMSIZE:            0800 DEFINED AT LINE 25 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 26 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 33 IN IOSerial.asm
                    > USED AT LINE 476 IN IOSerial.asm
                    > USED AT LINE 498 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 34 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 322 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 36 IN IOSerial.asm
                    > USED AT LINE 326 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 475 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 46 IN IOSerial.asm
                    > USED AT LINE 497 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 50 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 51 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 52 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 53 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 54 IN IOSerial.asm
                    > USED AT LINE 497 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 55 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 56 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 57 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 61 IN IOSerial.asm
                    > USED AT LINE 497 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 62 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 63 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 64 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 68 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 72 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 73 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 74 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 75 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 76 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 77 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 78 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 79 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 87 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 88 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 89 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 90 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 91 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 92 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 93 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 94 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 107 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 108 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 109 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 113 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 163 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 481 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 187 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 193 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 196 IN IOSerial.asm
                    > USED AT LINE 457 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 469 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 305 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 308 IN IOSerial.asm
                    > USED AT LINE 312 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 320 IN IOSerial.asm
                    > USED AT LINE 467 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 321 IN IOSerial.asm
                    > USED AT LINE 325 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 445 IN IOSerial.asm
                    > USED AT LINE 536 IN MAIN.asm
PUTCHAR:            0085 DEFINED AT LINE 449 IN IOSerial.asm
                    > USED AT LINE 789 IN MAIN.asm
                    > USED AT LINE 827 IN MAIN.asm
                    > USED AT LINE 868 IN MAIN.asm
RESET:              008B DEFINED AT LINE 455 IN IOSerial.asm
                    > USED AT LINE 114 IN IOSerial.asm
TRUE:               00-1 DEFINED AT LINE 17 IN MAIN.asm
FALSE:              0000 DEFINED AT LINE 18 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 19 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 20 IN MAIN.asm
EOF_:               0000 DEFINED AT LINE 29 IN MAIN.asm
                    > USED AT LINE 142 IN MAIN.asm
                    > USED AT LINE 185 IN MAIN.asm
NEWLN_:             0001 DEFINED AT LINE 30 IN MAIN.asm
                    > USED AT LINE 190 IN MAIN.asm
COMMENT_:           0002 DEFINED AT LINE 31 IN MAIN.asm
                    > USED AT LINE 199 IN MAIN.asm
NUM_:               0003 DEFINED AT LINE 32 IN MAIN.asm
                    > USED AT LINE 233 IN MAIN.asm
                    > USED AT LINE 241 IN MAIN.asm
LABEL_:             0004 DEFINED AT LINE 33 IN MAIN.asm
                    > USED AT LINE 211 IN MAIN.asm
IDENT_:             0005 DEFINED AT LINE 34 IN MAIN.asm
                    > USED AT LINE 215 IN MAIN.asm
END_:               0006 DEFINED AT LINE 35 IN MAIN.asm
                    > USED AT LINE 145 IN MAIN.asm
DIR_:               0007 DEFINED AT LINE 36 IN MAIN.asm
                    > USED AT LINE 221 IN MAIN.asm
SYM_:               0008 DEFINED AT LINE 37 IN MAIN.asm
                    > USED AT LINE 246 IN MAIN.asm
OPCODES:            0180 DEFINED AT LINE 39 IN MAIN.asm
ADC_:               0180 DEFINED AT LINE 41 IN MAIN.asm
ADD_:               0184 DEFINED AT LINE 42 IN MAIN.asm
AND_:               0188 DEFINED AT LINE 43 IN MAIN.asm
BIT_:               018C DEFINED AT LINE 44 IN MAIN.asm
CALL_:              0190 DEFINED AT LINE 45 IN MAIN.asm
CCF_:               0195 DEFINED AT LINE 46 IN MAIN.asm
CP_:                0199 DEFINED AT LINE 47 IN MAIN.asm
CPD_:               019C DEFINED AT LINE 48 IN MAIN.asm
CPDR_:              01A0 DEFINED AT LINE 49 IN MAIN.asm
CPI_:               01A5 DEFINED AT LINE 50 IN MAIN.asm
CPIR_:              01A9 DEFINED AT LINE 51 IN MAIN.asm
CPL_:               01AE DEFINED AT LINE 52 IN MAIN.asm
DAA_:               01B2 DEFINED AT LINE 53 IN MAIN.asm
DEC_:               01B6 DEFINED AT LINE 54 IN MAIN.asm
DI_:                01BA DEFINED AT LINE 55 IN MAIN.asm
DJNZ_:              01BD DEFINED AT LINE 56 IN MAIN.asm
EI_:                01C2 DEFINED AT LINE 57 IN MAIN.asm
EX_:                01C5 DEFINED AT LINE 58 IN MAIN.asm
EXX_:               01C8 DEFINED AT LINE 59 IN MAIN.asm
HALT_:              01CC DEFINED AT LINE 60 IN MAIN.asm
IM_:                01D1 DEFINED AT LINE 61 IN MAIN.asm
IN_:                01D4 DEFINED AT LINE 62 IN MAIN.asm
INC_:               01D7 DEFINED AT LINE 63 IN MAIN.asm
IND_:               01DB DEFINED AT LINE 64 IN MAIN.asm
INDR_:              01DF DEFINED AT LINE 65 IN MAIN.asm
INI_:               01E4 DEFINED AT LINE 66 IN MAIN.asm
INIR_:              01E8 DEFINED AT LINE 67 IN MAIN.asm
JP_:                01ED DEFINED AT LINE 68 IN MAIN.asm
JR_:                01F0 DEFINED AT LINE 69 IN MAIN.asm
LD_:                01F3 DEFINED AT LINE 70 IN MAIN.asm
LDD_:               01F6 DEFINED AT LINE 71 IN MAIN.asm
LDDR_:              01FA DEFINED AT LINE 72 IN MAIN.asm
LDI_:               01FF DEFINED AT LINE 73 IN MAIN.asm
LDIR_:              0203 DEFINED AT LINE 74 IN MAIN.asm
NEG_:               0208 DEFINED AT LINE 75 IN MAIN.asm
NOP_:               020C DEFINED AT LINE 76 IN MAIN.asm
OR_:                0210 DEFINED AT LINE 77 IN MAIN.asm
OTDR_:              0213 DEFINED AT LINE 78 IN MAIN.asm
OTIR_:              0218 DEFINED AT LINE 79 IN MAIN.asm
OUT_:               021D DEFINED AT LINE 80 IN MAIN.asm
OUTD_:              0221 DEFINED AT LINE 81 IN MAIN.asm
OUTI_:              0226 DEFINED AT LINE 82 IN MAIN.asm
POP_:               022B DEFINED AT LINE 83 IN MAIN.asm
PUSH_:              022F DEFINED AT LINE 84 IN MAIN.asm
RES_:               0234 DEFINED AT LINE 85 IN MAIN.asm
RET_:               0238 DEFINED AT LINE 86 IN MAIN.asm
RETI_:              023C DEFINED AT LINE 87 IN MAIN.asm
RETN_:              0241 DEFINED AT LINE 88 IN MAIN.asm
RL_:                0246 DEFINED AT LINE 89 IN MAIN.asm
RLA_:               0249 DEFINED AT LINE 90 IN MAIN.asm
RLC_:               024D DEFINED AT LINE 91 IN MAIN.asm
RLCA_:              0251 DEFINED AT LINE 92 IN MAIN.asm
RLD_:               0256 DEFINED AT LINE 93 IN MAIN.asm
RR_:                025A DEFINED AT LINE 94 IN MAIN.asm
RRA_:               025D DEFINED AT LINE 95 IN MAIN.asm
RRC_:               0261 DEFINED AT LINE 96 IN MAIN.asm
RRCA_:              0265 DEFINED AT LINE 97 IN MAIN.asm
RRD_:               026A DEFINED AT LINE 98 IN MAIN.asm
RST_:               026E DEFINED AT LINE 99 IN MAIN.asm
SBC_:               0272 DEFINED AT LINE 100 IN MAIN.asm
SCF_:               0276 DEFINED AT LINE 101 IN MAIN.asm
SET_:               027A DEFINED AT LINE 102 IN MAIN.asm
SLA_:               027E DEFINED AT LINE 103 IN MAIN.asm
SRA_:               0282 DEFINED AT LINE 104 IN MAIN.asm
SRL_:               0286 DEFINED AT LINE 105 IN MAIN.asm
SUB_:               028A DEFINED AT LINE 106 IN MAIN.asm
XOR_:               028E DEFINED AT LINE 107 IN MAIN.asm
START:              0293 DEFINED AT LINE 110 IN MAIN.asm
                    > USED AT LINE 6
INIT:               02AB DEFINED AT LINE 117 IN MAIN.asm
                    > USED AT LINE 112 IN MAIN.asm
PARSE:              02D4 DEFINED AT LINE 134 IN MAIN.asm
                    > USED AT LINE 115 IN MAIN.asm
STATEMENTLIST:      02FB DEFINED AT LINE 140 IN MAIN.asm
                    > USED AT LINE 135 IN MAIN.asm
                    > USED AT LINE 147 IN MAIN.asm
STATEMENT:          031F DEFINED AT LINE 151 IN MAIN.asm
                    > USED AT LINE 144 IN MAIN.asm
MATCH:              0320 DEFINED AT LINE 154 IN MAIN.asm
                    > USED AT LINE 146 IN MAIN.asm
NEXTTOKEN:          0329 DEFINED AT LINE 175 IN MAIN.asm
                    > USED AT LINE 157 IN MAIN.asm
NEXTTOKEN1:         032C DEFINED AT LINE 177 IN MAIN.asm
                    > USED AT LINE 180 IN MAIN.asm
                    > USED AT LINE 182 IN MAIN.asm
NEXTTOKEN2:         033D DEFINED AT LINE 187 IN MAIN.asm
                    > USED AT LINE 184 IN MAIN.asm
NEXTTOKEN2X:        0344 DEFINED AT LINE 192 IN MAIN.asm
                    > USED AT LINE 189 IN MAIN.asm
NEXTTOKEN3:         0349 DEFINED AT LINE 195 IN MAIN.asm
                    > USED AT LINE 198 IN MAIN.asm
NEXTTOKEN4:         0353 DEFINED AT LINE 201 IN MAIN.asm
                    > USED AT LINE 194 IN MAIN.asm
NEXTTOKEN5:         035C DEFINED AT LINE 206 IN MAIN.asm
                    > USED AT LINE 203 IN MAIN.asm
NEXTTOKEN6:         0369 DEFINED AT LINE 213 IN MAIN.asm
                    > USED AT LINE 210 IN MAIN.asm
NEXTTOKEN7X:        036F DEFINED AT LINE 217 IN MAIN.asm
                    > USED AT LINE 205 IN MAIN.asm
NEXTTOKEN7:         0379 DEFINED AT LINE 223 IN MAIN.asm
                    > USED AT LINE 219 IN MAIN.asm
NEXTTOKEN8:         038A DEFINED AT LINE 231 IN MAIN.asm
                    > USED AT LINE 225 IN MAIN.asm
                    > USED AT LINE 228 IN MAIN.asm
NEXTTOKEN9:         0399 DEFINED AT LINE 239 IN MAIN.asm
                    > USED AT LINE 236 IN MAIN.asm
NEXTTOKEN10:        039F DEFINED AT LINE 243 IN MAIN.asm
                    > USED AT LINE 230 IN MAIN.asm
                    > USED AT LINE 238 IN MAIN.asm
IDENT:              03A5 DEFINED AT LINE 253 IN MAIN.asm
                    > USED AT LINE 207 IN MAIN.asm
IDENT1:             03A9 DEFINED AT LINE 256 IN MAIN.asm
                    > USED AT LINE 261 IN MAIN.asm
DIRECTIVE:          03C5 DEFINED AT LINE 272 IN MAIN.asm
                    > USED AT LINE 220 IN MAIN.asm
ISALPHANUM:         03C9 DEFINED AT LINE 348 IN MAIN.asm
                    > USED AT LINE 204 IN MAIN.asm
                    > USED AT LINE 262 IN MAIN.asm
ISALPHA:            03CD DEFINED AT LINE 365 IN MAIN.asm
ISALPHA0:           03CF DEFINED AT LINE 367 IN MAIN.asm
                    > USED AT LINE 391 IN MAIN.asm
ISALPHA1:           03D5 DEFINED AT LINE 371 IN MAIN.asm
                    > USED AT LINE 369 IN MAIN.asm
ISHEXDIGIT:         03DB DEFINED AT LINE 389 IN MAIN.asm
                    > USED AT LINE 227 IN MAIN.asm
ISDIGIT:            03E1 DEFINED AT LINE 405 IN MAIN.asm
                    > USED AT LINE 237 IN MAIN.asm
                    > USED AT LINE 349 IN MAIN.asm
NUMBER:             03E8 DEFINED AT LINE 424 IN MAIN.asm
                    > USED AT LINE 240 IN MAIN.asm
NUM1:               03EF DEFINED AT LINE 429 IN MAIN.asm
                    > USED AT LINE 427 IN MAIN.asm
NUM2:               03FE DEFINED AT LINE 436 IN MAIN.asm
                    > USED AT LINE 433 IN MAIN.asm
NUM3:               0404 DEFINED AT LINE 439 IN MAIN.asm
                    > USED AT LINE 435 IN MAIN.asm
HEX:                0411 DEFINED AT LINE 458 IN MAIN.asm
                    > USED AT LINE 232 IN MAIN.asm
                    > USED AT LINE 434 IN MAIN.asm
HEX1:               0414 DEFINED AT LINE 460 IN MAIN.asm
                    > USED AT LINE 487 IN MAIN.asm
HEX2:               0424 DEFINED AT LINE 469 IN MAIN.asm
                    > USED AT LINE 467 IN MAIN.asm
UPPER:              042B DEFINED AT LINE 474 IN MAIN.asm
                    > USED AT LINE 473 IN MAIN.asm
VALID:              042D DEFINED AT LINE 476 IN MAIN.asm
                    > USED AT LINE 465 IN MAIN.asm
DECIMAL:            043C DEFINED AT LINE 501 IN MAIN.asm
                    > USED AT LINE 438 IN MAIN.asm
DECIMAL1:           043F DEFINED AT LINE 503 IN MAIN.asm
                    > USED AT LINE 520 IN MAIN.asm
NEXTCHAR:           0457 DEFINED AT LINE 534 IN MAIN.asm
                    > USED AT LINE 178 IN MAIN.asm
                    > USED AT LINE 196 IN MAIN.asm
                    > USED AT LINE 208 IN MAIN.asm
                    > USED AT LINE 226 IN MAIN.asm
                    > USED AT LINE 259 IN MAIN.asm
                    > USED AT LINE 431 IN MAIN.asm
                    > USED AT LINE 461 IN MAIN.asm
                    > USED AT LINE 504 IN MAIN.asm
PUSHBACKCHAR:       0465 DEFINED AT LINE 553 IN MAIN.asm
                    > USED AT LINE 214 IN MAIN.asm
                    > USED AT LINE 229 IN MAIN.asm
                    > USED AT LINE 263 IN MAIN.asm
                    > USED AT LINE 437 IN MAIN.asm
PROMPT:             046B DEFINED AT LINE 760 IN MAIN.asm
CRLF:               0474 DEFINED AT LINE 765 IN MAIN.asm
PRINTSTR:           047B DEFINED AT LINE 777 IN MAIN.asm
                    > USED AT LINE 113 IN MAIN.asm
                    > USED AT LINE 136 IN MAIN.asm
                    > USED AT LINE 761 IN MAIN.asm
                    > USED AT LINE 766 IN MAIN.asm
ERROR:              0481 DEFINED AT LINE 783 IN MAIN.asm
                    > USED AT LINE 148 IN MAIN.asm
PUTSTR0:            0486 DEFINED AT LINE 788 IN MAIN.asm
                    > USED AT LINE 794 IN MAIN.asm
PUTSTR:             048A DEFINED AT LINE 791 IN MAIN.asm
                    > USED AT LINE 779 IN MAIN.asm
                    > USED AT LINE 785 IN MAIN.asm
RPUSH:              048F DEFINED AT LINE 797 IN MAIN.asm
RPOP:               049A DEFINED AT LINE 804 IN MAIN.asm
RPOP2:              04A4 DEFINED AT LINE 809 IN MAIN.asm
PRINTDEC:           04A5 DEFINED AT LINE 823 IN MAIN.asm
PRINTDEC2:          04B4 DEFINED AT LINE 834 IN MAIN.asm
                    > USED AT LINE 825 IN MAIN.asm
PRINTDEC4:          04D6 DEFINED AT LINE 850 IN MAIN.asm
                    > USED AT LINE 838 IN MAIN.asm
                    > USED AT LINE 840 IN MAIN.asm
                    > USED AT LINE 842 IN MAIN.asm
                    > USED AT LINE 844 IN MAIN.asm
                    > USED AT LINE 847 IN MAIN.asm
PRINTDEC5:          04D8 DEFINED AT LINE 852 IN MAIN.asm
                    > USED AT LINE 855 IN MAIN.asm
PRINTDEC6:          04E8 DEFINED AT LINE 864 IN MAIN.asm
                    > USED AT LINE 859 IN MAIN.asm
PRINTDEC7:          04E9 DEFINED AT LINE 866 IN MAIN.asm
                    > USED AT LINE 863 IN MAIN.asm
RST08:              0800 DEFINED AT LINE 3 IN ram.asm
                    > USED AT LINE 118 IN IOSerial.asm
                    > USED AT LINE 458 IN IOSerial.asm
RST10:              0802 DEFINED AT LINE 4 IN ram.asm
                    > USED AT LINE 124 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
RST18:              0804 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 130 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
RST20:              0806 DEFINED AT LINE 6 IN ram.asm
                    > USED AT LINE 136 IN IOSerial.asm
                    > USED AT LINE 461 IN IOSerial.asm
RST28:              0808 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RST30:              080A DEFINED AT LINE 8 IN ram.asm
                    > USED AT LINE 148 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
BAUD:               080C DEFINED AT LINE 9 IN ram.asm
INTVEC:             080E DEFINED AT LINE 10 IN ram.asm
                    > USED AT LINE 154 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
NMIVEC:             0810 DEFINED AT LINE 11 IN ram.asm
                    > USED AT LINE 202 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
GETCVEC:            0812 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 446 IN IOSerial.asm
                    > USED AT LINE 468 IN IOSerial.asm
PUTCVEC:            0814 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
VTEMP1:             0816 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 430 IN MAIN.asm
                    > USED AT LINE 440 IN MAIN.asm
VTEMP2:             0818 DEFINED AT LINE 16 IN ram.asm
VPUSHBACK:          081A DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 119 IN MAIN.asm
                    > USED AT LINE 535 IN MAIN.asm
                    > USED AT LINE 537 IN MAIN.asm
                    > USED AT LINE 539 IN MAIN.asm
                    > USED AT LINE 555 IN MAIN.asm
VTOKEN:             081B DEFINED AT LINE 19 IN ram.asm
                    > USED AT LINE 120 IN MAIN.asm
                    > USED AT LINE 141 IN MAIN.asm
VTOKENVAL:          081C DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 127 IN MAIN.asm
VCHARPTR:           081E DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 122 IN MAIN.asm
VASMPTR:            0820 DEFINED AT LINE 22 IN ram.asm
                    > USED AT LINE 124 IN MAIN.asm
VSTRPTR:            0822 DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 126 IN MAIN.asm
                    > USED AT LINE 254 IN MAIN.asm
                    > USED AT LINE 264 IN MAIN.asm
                    > USED AT LINE 265 IN MAIN.asm
VSYMPTR:            0824 DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 129 IN MAIN.asm
VEXPRPTR:           0826 DEFINED AT LINE 25 IN ram.asm
                    > USED AT LINE 131 IN MAIN.asm
CHARS:              0828 DEFINED AT LINE 27 IN ram.asm
                    > USED AT LINE 121 IN MAIN.asm
STACK:              0A28 DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 456 IN IOSerial.asm
                    > USED AT LINE 111 IN MAIN.asm
STRINGS:            0A28 DEFINED AT LINE 31 IN ram.asm
                    > USED AT LINE 125 IN MAIN.asm
SYMBOLS:            0B28 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 128 IN MAIN.asm
EXPRS:              0C28 DEFINED AT LINE 33 IN ram.asm
                    > USED AT LINE 130 IN MAIN.asm
ASSEMBLY:           0D28 DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 123 IN MAIN.asm
