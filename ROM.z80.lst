0000                          .ENGINE   mycomputer   
0000                             ; 
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $0800   
0000                ROMSIZE:   EQU   $0800   
0000                RAMSIZE:   EQU   $0800   
0000                NO_MATCH:   EQU   -1   
0000                CTRL_H:   EQU   8   
0000                BUFFER_SIZE:   EQU   80   
0000                TOKENS:      
0000                COLON_:   EQU   ":"   
0000                COMMA_:   EQU   ","   
0000                DIRECT_:   EQU   "D"   
0000                DOLLAR_:   EQU   "$"   
0000                EOF_:     EQU   "E"   
0000                FLAG_:    EQU   "F"   
0000                IDENT_:   EQU   "I"   
0000                LABEL_:   EQU   "L"   
0000                LPAREN_:   EQU   "("   
0000                NEWLN_:   EQU   "\n"   
0000                NUM_:     EQU   "9"   
0000                OPCODE_:   EQU   "C"   
0000                REG_:     EQU   "R"   
0000                REGPAIR_:   EQU   "P"   
0000                RPAREN_:   EQU   ")"   
0000                UNKNOWN_:   EQU   "U"   
0000                ALU_IDX:      
0000                ADD_:     EQU   0   
0000                ADC_:     EQU   1   
0000                SUB_:     EQU   2   
0000                SBC_:     EQU   3   
0000                AND_:     EQU   4   
0000                XOR_:     EQU   5   
0000                OR_:      EQU   6   
0000                CP_:      EQU   7   
0000                ROT_IDX:      
0000                RLC_:     EQU   0 | 0x10   
0000                RRC_:     EQU   1 | 0x10   
0000                RL_:      EQU   2 | 0x10   
0000                RR_:      EQU   3 | 0x10   
0000                SLA_:     EQU   4 | 0x10   
0000                SRA_:     EQU   5 | 0x10   
0000                SLL_:     EQU   6 | 0x10   
0000                SRL_:     EQU   7 | 0x10   
0000                GEN_IDX:      
0000                             ; Opcode values
0000                BIT_:     EQU   0  | 0x40   
0000                CALL_:    EQU   1  | 0x40   
0000                CCF_:     EQU   2  | 0x40   
0000                CPD_:     EQU   3  | 0x40   
0000                CPDR_:    EQU   4  | 0x40   
0000                CPI_:     EQU   5  | 0x40   
0000                CPIR_:    EQU   6  | 0x40   
0000                CPL_:     EQU   7  | 0x40   
0000                DAA_:     EQU   8  | 0x40   
0000                DEC_:     EQU   9  | 0x40   
0000                DI_:      EQU   10 | 0x40   
0000                DJNZ_:    EQU   11 | 0x40   
0000                EI_:      EQU   12 | 0x40   
0000                EX_:      EQU   13 | 0x40   
0000                EXX_:     EQU   14 | 0x40   
0000                HALT_:    EQU   15 | 0x40   
0000                IM_:      EQU   16 | 0x40   
0000                IN_:      EQU   17 | 0x40   
0000                INC_:     EQU   18 | 0x40   
0000                IND_:     EQU   19 | 0x40   
0000                INDR_:    EQU   20 | 0x40   
0000                INI_:     EQU   21 | 0x40   
0000                INIR_:    EQU   22 | 0x40   
0000                JP_:      EQU   23 | 0x40   
0000                JR_:      EQU   24 | 0x40   
0000                LD_:      EQU   25 | 0x40   
0000                LDD_:     EQU   26 | 0x40   
0000                LDDR_:    EQU   27 | 0x40   
0000                LDI_:     EQU   28 | 0x40   
0000                LDIR_:    EQU   29 | 0x40   
0000                NEG_:     EQU   30 | 0x40   
0000                NOP_:     EQU   31 | 0x40   
0000                OTDR_:    EQU   32 | 0x40   
0000                OTIR_:    EQU   33 | 0x40   
0000                OUT_:     EQU   34 | 0x40   
0000                OUTD_:    EQU   35 | 0x40   
0000                OUTI_:    EQU   36 | 0x40   
0000                POP_:     EQU   37 | 0x40   
0000                PUSH_:    EQU   38 | 0x40   
0000                RES_:     EQU   39 | 0x40   
0000                RET_:     EQU   40 | 0x40   
0000                RETI_:    EQU   41 | 0x40   
0000                RETN_:    EQU   42 | 0x40   
0000                RLA_:     EQU   43 | 0x40   
0000                RLCA_:    EQU   44 | 0x40   
0000                RLD_:     EQU   45 | 0x40   
0000                RRA_:     EQU   46 | 0x40   
0000                RRCA_:    EQU   47 | 0x40   
0000                RRD_:     EQU   48 | 0x40   
0000                RST_:     EQU   49 | 0x40   
0000                SCF_:     EQU   50 | 0x40   
0000                SET_:     EQU   51 | 0x40   
0000                REG_IDX:      
0000                B_:       EQU   0   ; B
0000                C_:       EQU   1   ; C
0000                D_:       EQU   2   ; D
0000                E_:       EQU   3   ; E
0000                H_:       EQU   4   ; H
0000                L_:       EQU   5   ; L
0000                MHL_:     EQU   6   ; (HL)
0000                A_:       EQU   7   ; A
0000                I_:       EQU   8   ; I
0000                R_:       EQU   9   ; R
0000                REG_PAIR_IDX:      
0000                BC_:      EQU   0   
0000                DE_:      EQU   1   
0000                HL_:      EQU   2   
0000                SP_:      EQU   3   
0000                AF_:      EQU   4   ; NOTE: AF has the same code as SP in some instructions
0000                IX_:      EQU   5   
0000                IY_:      EQU   6   
0000                AFP_:     EQU   7   ; AF' (prime)
0000                FLAG_IDX:      
0000                NZ_:      EQU   0   
0000                Z_:       EQU   1   
0000                NC_:      EQU   2   
0000                C_:       EQU   3   
0000                PO_:      EQU   4   
0000                PE_:      EQU   5   
0000                P_:       EQU   6   
0000                M_:       EQU   7   
0000                DIRECTIVE_IDX:      
0000                ALIGN_:   EQU   0   
0000                DB_:      EQU   1   
0000                ORG_:     EQU   2   
0000                SET_:     EQU   3   
0000                             ; -----------------------------------------------------------------------------------------------
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                             ; *************************************************************************
0000                             ; 
0000                             ;       Serial routines 
0000                             ; 
0000                             ;       written by Craig Jones 
0000                             ; 
0000                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
0000                             ; 
0000                             ;       see the LICENSE file in this repo for more information 
0000                             ; 
0000                             ; *****************************************************************************
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8B 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 50 09               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 52 09               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 54 09               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A 56 09               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A 58 09               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A 5A 09               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A 5E 09               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A 60 09               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   2A 62 09               LD   HL,(GETCVEC)   
0084   E9                     JP   (HL)   
0085                             ; 
0085                PUTCHAR:      
0085   E5                     PUSH   HL   
0086   2A 64 09               LD   HL,(PUTCVEC)   
0089   E3                     EX   (SP),HL   
008A   C9                     RET      
008B                             ; 
008B                RESET:       
008B   31 50 09               LD   SP,stack   
008E   21 5F 00               LD   HL,IntRet   
0091   22 50 09               LD   (RST08),HL   
0094   22 52 09               LD   (RST10),HL   
0097   22 54 09               LD   (RST18),HL   
009A   22 56 09               LD   (RST20),HL   
009D   22 58 09               LD   (RST28),HL   
00A0   22 5A 09               LD   (RST30),HL   
00A3   22 5E 09               LD   (INTVEC),HL   
00A6   22 60 09               LD   (NMIVEC),HL   
00A9                             ; 
00A9   21 78 00               LD   HL,RXDATA   
00AC   22 62 09               LD   (GETCVEC),HL   
00AF   21 6B 00               LD   HL,TXDATA   
00B2   22 64 09               LD   (PUTCVEC),HL   
00B5                             ; 
00B5                          IF   TEC_1   
00B5                          IF   BITBANG = 0   
00B5                             ; 
00B5   3E 03                  LD   a,MRESET   
00B7   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B9                             ; 
00B9                          ENDIF      
00B9                          ENDIF      
00B9                             ; 
00B9   CD 50 00               CALL   PWRUP   
00BC   ED 56                  IM   1   
00BE   FB                     EI      
00BF                             ; 
00BF                          IF   TEC_1   
00BF                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00BF                          ELSE      ;6850      
00BF                             ; 
00BF   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C1   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C3                             ; 
00C3                          ENDIF      
00C3                          ENDIF      
00C3                             ; 
00C3                             ; 
00C3                             ; 
00C3   C3 80 01               JP   start   
00C6                             ; 
00C6                             ; *************************************************************************
00C6                             ; 
00C6                             ;       TecM8 1.0 Assembler for the Tec-1
00C6                             ; 
00C6                             ;       by John Hardy
00C6                             ; 
00C6                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
00C6                             ; 
00C6                             ;       see the LICENSE file in this repo for more information
00C6                             ; 
00C6                             ; *****************************************************************************
00C6                             ; **************************************************************************
00C6                             ; Page 0  Initialisation
00C6                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put TecM8 code from here	
0180                             ; *****************************************************************************
0180                             ; Routine: start
0180                             ; 
0180                             ; Purpose:
0180                             ;    Entry point of TecM8. Initializes the stack pointer, calls the initialization
0180                             ;    routine, prints TecM8 version information, and jumps to the parsing routine.
0180                             ; 
0180                             ; Inputs:
0180                             ;    None
0180                             ; 
0180                             ; Outputs:
0180                             ;    None
0180                             ; 
0180                             ; Registers Destroyed:
0180                             ;    A, HL
0180                             ; *****************************************************************************
0180                START:       
0180   31 50 09               LD   sp,STACK   ; Initialize stack pointer
0183   CD 98 01               CALL   init   ; Call initialization routine
0186   CD 70 04               CALL   print   ; Print TecM8 version information
0189   0B 54 65 63 4D 38 20 30 2E 30 0D 0A .PSTR   "TecM8 0.0\r\n"   
0195   C3 BB 01               JP   parse   ; Jump to the parsing routine
0198                             ; *****************************************************************************
0198                             ; Routine: init
0198                             ; 
0198                             ; Purpose:
0198                             ;    Initializes various pointers and variables used by TecM8.
0198                             ; 
0198                             ; Inputs:
0198                             ;    None
0198                             ; 
0198                             ; Outputs:
0198                             ;    None
0198                             ; 
0198                             ; Registers Destroyed:
0198                             ;    A, HL
0198                             ; *****************************************************************************
0198                INIT:        
0198   AF                     XOR   a   ; Clear A register
0199   32 6C 09               LD   (vToken),a   ; Initialize vToken with NUL_ token
019C   32 6A 09               LD   (vBufferPos),a   ; Initialize buffer position
019F   21 77 0C               LD   hl,assembly   ; Load assembly pointer
01A2   22 6F 09               LD   (vAsmPtr),hl   ; Store in vAsmPtr
01A5   21 77 09               LD   hl,strings   ; Load strings pointer
01A8   22 71 09               LD   (vStrPtr),hl   ; Store in vStrPtr
01AB   22 6D 09               LD   (vTokenVal),hl   ; Initialize token value pointer
01AE   21 77 0A               LD   hl,symbols   ; Load symbols pointer
01B1   22 73 09               LD   (vSymPtr),hl   ; Store in vSymPtr
01B4   21 77 0B               LD   hl,exprs   ; Load expressions pointer
01B7   22 75 09               LD   (vExprPtr),hl   ; Store in vExprPtr
01BA   C9                     RET      ; Return
01BB                             ; *****************************************************************************
01BB                             ; Routine: parse
01BB                             ; 
01BB                             ; Purpose:
01BB                             ;    Parses the input program, calling the statementList routine, printing the
01BB                             ;    completion message, and halting the system.
01BB                             ; 
01BB                             ; Inputs:
01BB                             ;    None
01BB                             ; 
01BB                             ; Outputs:
01BB                             ;    None
01BB                             ; 
01BB                             ; Registers Destroyed:
01BB                             ;    None
01BB                             ; *****************************************************************************
01BB                PARSE:       
01BB   CD E2 01               CALL   statementList   ; Parse the input program
01BE   CD 70 04               CALL   print   ; Print completion message
01C1   1F 50 61 72 73 69 6E 67 20 63 6F 6D 70 6C 65 74 65 64 20 73 75 63 63 65 73 73 66 75 6C 6C 79 2E .PSTR   "Parsing completed successfully."   
01E1   76                     HALT      ; Halt the system
01E2                             ; *****************************************************************************
01E2                             ; Routine: statementList
01E2                             ; 
01E2                             ; Purpose:
01E2                             ;    Parses a list of statements, repeatedly calling the statement routine until
01E2                             ;    the end of file (EOF) token is encountered.
01E2                             ; 
01E2                             ; Inputs:
01E2                             ;    None
01E2                             ; 
01E2                             ; Outputs:
01E2                             ;    None
01E2                             ; 
01E2                             ; Registers Destroyed:
01E2                             ;    A
01E2                             ; *****************************************************************************
01E2                STATEMENTLIST:      
01E2   CD 1F 02               CALL   nextToken   ; Get the next token
01E5   FE 45                  CP   EOF_   ; Check if it's the end of file
01E7   C8                     RET   z   ; If yes, return
01E8   CD ED 01               CALL   statement   ; Parse a statement
01EB   18 F5                  JR   statementList   ; Repeat for the next statement
01ED                             ; *****************************************************************************
01ED                             ; Routine: statement
01ED                             ; 
01ED                             ; Purpose:
01ED                             ;    Parses a single statement, checking its type (label, opcode, or directive)
01ED                             ;    and performing corresponding actions.
01ED                             ; 
01ED                             ; Inputs:
01ED                             ;    None
01ED                             ; 
01ED                             ; Outputs:
01ED                             ;    None
01ED                             ; 
01ED                             ; Registers Destroyed:
01ED                             ;    A
01ED                             ; *****************************************************************************
01ED                STATEMENT:      
01ED                             ; setOpcode null
01ED                             ; setOperand1 null
01ED                             ; setOperand2 null
01ED   FE 4C                  CP   LABEL_   ; Check if it's a label
01EF   20 03                  JR   nz,statement10   ; If not, jump to statement10
01F1                             ; call addLabel            ; Add label to symbol table
01F1   CD 1F 02               CALL   nextToken   ; Get the next token
01F4                STATEMENT10:      
01F4   FE 43                  CP   OPCODE_   ; Check if it's an opcode
01F6   20 00                  JR   nz,statement1   
01F8                             ; call instruction      ; Jump to parseInstruction routine
01F8                             ; call nextToken
01F8                             ; jr statement2
01F8                STATEMENT1:      
01F8   FE 44                  CP   DIRECT_   ; Check if it's a directive
01FA   20 00                  JR   nz,statement2   
01FC                             ; jp directive        ; Jump to parseDirective routine
01FC                             ; call nextToken
01FC                STATEMENT2:      
01FC   FE 0A                  CP   NEWLN_   
01FE   C8                     RET   z   
01FF   FE 45                  CP   EOF_   
0201   C8                     RET   z   
0202                             ; throw error, expected NEWLN or EOF
0202   C9                     RET      
0203                INSTRUCTION:      
0203                             ; check if Opcode has been set
0203                             ; setOpcode a
0203   CD 1F 02               CALL   nextToken   
0206   FE 0A                  CP   NEWLN_   
0208   28 04                  JR   z,instruction1   
020A   FE 45                  CP   EOF_   
020C   28 03                  JR   z,instruction2   
020E                INSTRUCTION1:      
020E   CD F6 02               CALL   pushBackToken   
0211                INSTRUCTION2:      
0211   CD 1F 02               CALL   firstOperand   
0214   CD 1F 02               CALL   nextToken   
0217   FE 2C                  CP   COMMA_   
0219   CD 1F 02               CALL   nextToken   
021C   CD 1F 02               CALL   secondOperand   
021F                FIRSTOPERAND:      
021F                SECONDOPERAND:      
021F                DIRECTIVE:      
021F                             ; nextToken is a lexer function that reads characters from the input and classifies
021F                             ; them into different token types. It handles whitespace, end of input, newlines,
021F                             ; comments, identifiers, labels, directives, hexadecimal numbers, and other symbols.
021F                             ; Input: None
021F                             ; Output:
021F                             ; a: contains the type of the next token.
021F                             ; hl: contains the value associated with the next token.
021F                             ; Destroyed: None
021F                             ; *****************************************************************************
021F                             ; Routine: nextToken
021F                             ; 
021F                             ; Purpose:
021F                             ;    Parses the next token from the input stream, identifying various types of
021F                             ;    tokens such as identifiers, labels, opcodes, registers, flags, numbers,
021F                             ;    and special characters.
021F                             ; 
021F                             ; Inputs:
021F                             ;    None
021F                             ; 
021F                             ; Outputs:
021F                             ;    A - Token representing the type of the parsed element
021F                             ; 
021F                             ; Registers Destroyed:
021F                             ;    A, BC, DE, HL
021F                             ; *****************************************************************************
021F                NEXTTOKEN:      
021F   CB 77                  BIT   7,(vToken)   ; Check the high bit of the pushback buffer
0221   CA 30 02               JP   z,nextToken0   ; If high bit clear, nothing pushed back
0224   3A 6C 09               LD   a,(vToken)   ; If high bit set, load the pushed back token type into A
0227   2A 6D 09               LD   hl,(vTokenVal)   ; and token value into HL
022A   CB BF                  RES   7,a   ; Clear the high bit
022C   32 6C 09               LD   (vToken),a   ; Store the character back in the buffer
022F   C9                     RET      ; Return with the pushed back character in A
0230                NEXTTOKEN0:      
0230   21 00 00               LD   hl,0   ; Initialize HL with 0
0233                NEXTTOKEN1:      
0233   CD 2B 04               CALL   nextChar   ; Get the next character
0236   CD 65 03               CALL   isSpace   ; Check if it's a space
0239   28 F8                  JR   z,nextToken1   ; If yes, skip it and get the next character
023B   B7                     OR   a   ; Is it null (end of input)?
023C   20 03                  JR   nz,nextToken2   ; If not, continue to the next check
023E   3E 45                  LD   a,EOF_   ; If yes, return with EOF token
0240   C9                     RET      
0241                NEXTTOKEN2:      
0241   FE 0A                  CP   "\n"   ; Is it a newline?
0243   20 03                  JR   nz,nextToken3   ; If not, continue to the next check
0245   3E 45                  LD   a,EOF_   ; If yes, return with EOF token
0247   C9                     RET      ; Return with newline token
0248                NEXTTOKEN3:      
0248   FE 3B                  CP   ";"   ; Is it a comment?
024A   C4 59 02               CALL   nz,nextToken5   ; If not, continue to the next check
024D                NEXTTOKEN4:      
024D   CD 2B 04               CALL   nextChar   ; Get the next character in the comment
0250   FE 21                  CP   " "+1   ; Loop until the next control character
0252   30 F9                  JR   nc,nextToken4   
0254   CD 53 04               CALL   rewindChar   ; Push back the character
0257   18 D7                  JR   nextToken0   ; return with control char
0259                NEXTTOKEN5:      
0259   FE 5F                  CP   "_"   ; Is it an identifier?
025B   28 05                  JR   z,nextToken6   ; If yes, continue to the next check
025D   CD 6B 03               CALL   isAlphaNum   ; If not, check if it's alphanumeric
0260   30 4A                  JR   nc,nextToken13   ; If not, continue to the next check
0262                NEXTTOKEN6:      
0262   CD FF 02               CALL   ident   ; Parse the identifier
0265   CD 2B 04               CALL   nextChar   ; Get the next character
0268   FE 3A                  CP   ":"   ; Is it a label?
026A   20 03                  JR   nz,nextToken7   ; If not, continue to the next check
026C   3E 4C                  LD   a,LABEL_   ; If yes, return with LABEL token
026E   C9                     RET      
026F                NEXTTOKEN7:      
026F   CD 53 04               CALL   rewindChar   ; Push back the character
0272   22 71 09               LD   (vStrPtr),hl   ; Restore string heap pointer to previous location
0275   CD DD 02               CALL   searchOpcode   
0278   30 03                  JR   nc,nextToken8   
027A   3E 43                  LD   a,OPCODE_   ; Return with OPCODE token
027C   C9                     RET      
027D                NEXTTOKEN8:      
027D   11 B0 05               LD   de,reg_pairs   ; List of register pairs to search
0280   CD FE 03               CALL   searchStr   
0283   30 03                  JR   nc,nextToken9   
0285   3E 50                  LD   a,REGPAIR_   ; Return with REGPAIR token
0287   C9                     RET      
0288                NEXTTOKEN9:      
0288   11 9B 05               LD   de,registers   ; List of registers to search
028B   CD FE 03               CALL   searchStr   
028E   30 03                  JR   nc,nextToken10   
0290   3E 52                  LD   a,REG_   ; Return with REG token
0292   C9                     RET      
0293                NEXTTOKEN10:      
0293   11 CA 05               LD   de,flags   ; List of flags to search
0296   CD FE 03               CALL   searchStr   
0299   30 03                  JR   nc,nextToken11   
029B   3E 46                  LD   a,FLAG_   ; Return with FLAG token
029D   C9                     RET      
029E                NEXTTOKEN11:      
029E   11 CA 05               LD   de,flags   ; List of flags to search
02A1   CD FE 03               CALL   searchStr   
02A4   30 03                  JR   nc,nextToken12   
02A6   3E 44                  LD   a,DIRECT_   ; Return with DIRECT token
02A8   C9                     RET      
02A9                NEXTTOKEN12:      
02A9   3E 49                  LD   a,IDENT_   ; Return with IDENT token
02AB   C9                     RET      
02AC                NEXTTOKEN13:      
02AC   21 00 00               LD   hl,0   
02AF   FE 24                  CP   "$"   ; Is it a hexadecimal number?
02B1   20 0F                  JR   nz,nextToken14   ; If not, continue to the next check
02B3   CD 2B 04               CALL   nextChar   ; Get the next character
02B6   CD 65 03               CALL   isSpace   ; Check if it's the assembly pointer
02B9   CD 53 04               CALL   rewindChar   ; Push back the character (flags unaffected)
02BC   C8                     RET   z   ; Return with the assembly pointer token
02BD   CD AF 03               CALL   number_hex   ; Process hexadecimal number
02C0   18 0C                  JR   nextToken16   
02C2                NEXTTOKEN14:      
02C2   FE 2D                  CP   "-"   ; Is it a negative number?
02C4   28 05                  JR   z,nextToken15   ; If yes, continue to the next check
02C6   CD 7C 03               CALL   isDigit   ; Check if it's a digit
02C9   30 06                  JR   nc,nextToken17   ; Jump to the next check
02CB                NEXTTOKEN15:      
02CB   CD 83 03               CALL   number   ; Parse the number
02CE                NEXTTOKEN16:      
02CE   3E 39                  LD   a,NUM_   ; Return with NUM token
02D0   C9                     RET      
02D1                NEXTTOKEN17:      
02D1   FE 28                  CP   "("   
02D3   C8                     RET   z   ; Return with the "(" token
02D4   FE 29                  CP   ")"   
02D6   C8                     RET   z   ; Return with the ")" token
02D7   FE 2C                  CP   ","   
02D9   C8                     RET   z   ; Return with the "," token
02DA   3E 55                  LD   a,UNKNOWN_   ; Return with UNKNOWN token
02DC   C9                     RET      
02DD                             ; *****************************************************************************
02DD                             ; Routine: searchOpcode
02DD                             ; 
02DD                             ; Purpose:
02DD                             ;    Searches for a matching opcode in various lists of opcodes.
02DD                             ; 
02DD                             ; Inputs:
02DD                             ;    HL - Points to the string to search for.
02DD                             ; 
02DD                             ; Outputs:
02DD                             ;    CF - Set if a match is found, cleared otherwise.
02DD                             ;    A  - Contains the index of the matching opcode if a match is found,
02DD                             ;         or the last checked index if no match is found.
02DD                             ; 
02DD                             ; Registers Destroyed:
02DD                             ;    A, DE, F
02DD                             ; *****************************************************************************
02DD                SEARCHOPCODE:      
02DD   11 A1 04               LD   de,alu_opcodes   ; Point DE to the list of ALU opcodes
02E0   CD FE 03               CALL   searchStr   ; Call searchStr to search for the string in ALU opcodes
02E3   D8                     RET   c   ; If carry flag is set, return (match found)
02E4   11 82 04               LD   de,rot_opcodes   ; Point DE to the list of ROT opcodes
02E7   CD FE 03               CALL   searchStr   ; Call searchStr to search for the string in ROT opcodes
02EA   CB 4F                  BIT   1,a   ; Check bit 1 of register A (flags unaffected)
02EC   D8                     RET   c   ; If carry flag is set, return (match found)
02ED   11 C0 04               LD   de,gen_opcodes   ; Point DE to the list of general opcodes
02F0   CD FE 03               CALL   searchStr   ; Call searchStr to search for the string in general opcodes
02F3   CB 6F                  BIT   5,a   ; Check bit 5 of register A (flags unaffected)
02F5   C9                     RET      ; Return (if match found or not)
02F6                             ; *****************************************************************************
02F6                             ; Routine: pushBackToken
02F6                             ; 
02F6                             ; Purpose:
02F6                             ;    Pushes back a token into the pushback buffer to allow the token to be
02F6                             ;    re-read by the nextToken routine.
02F6                             ; 
02F6                             ; Inputs:
02F6                             ;    A  - token type
02F6                             ;    HL - token value
02F6                             ; 
02F6                             ; Outputs:
02F6                             ;    None
02F6                             ; 
02F6                             ; Registers Destroyed:
02F6                             ;    A, DE
02F6                             ; *****************************************************************************
02F6                PUSHBACKTOKEN:      
02F6   CB FF                  SET   7,a   ; Set the high bit of the token type (without affecting flags)
02F8   32 6C 09               LD   (vToken),a   ; push back the token
02FB   22 6D 09               LD   (vTokenVal),hl   ; push back the token value
02FE   C9                     RET      
02FF                             ; *****************************************************************************
02FF                             ; Routine: ident
02FF                             ; 
02FF                             ; Purpose:
02FF                             ;    Reads characters from the input stream until a charcter which is not an
02FF                             ;    an underscore or an alphanumeric character is encountered. Writes the chars
02FF                             ;    to a Pascal string and updates the top of the strings heap pointer.
02FF                             ;    It also calculates the length of the string and stores it at the beginning
02FF                             ;    of the string.
02FF                             ; 
02FF                             ; Inputs:
02FF                             ;    A - Current character read from the input stream
02FF                             ;    vStrPtr - Address of the top of strings heap pointer
02FF                             ; 
02FF                             ; Outputs:
02FF                             ;    None
02FF                             ; 
02FF                             ; Registers Destroyed:
02FF                             ;    A, DE, HL
02FF                             ; *****************************************************************************
02FF                IDENT:       
02FF   2A 71 09               LD   hl,(vStrPtr)   ; Load the address of the top of strings heap
0302   54 5D                  LD   de,hl   ; Copy it to DE (DE = HL = top of strings heap)
0304   23                     INC   hl   ; Move to the next byte to skip the length byte
0305                IDENT1:      
0305   77                     LD   (hl),a   ; Write the current character to the string buffer
0306   23                     INC   hl   ; Move to the next position in the buffer
0307   CD 2B 04               CALL   nextChar   ; Get the next character from the input stream
030A   FE 5F                  CP   "_"   ; Compare with underscore character
030C   28 05                  JR   z,ident2   ; If underscore, jump to ident2
030E   CD 6B 03               CALL   isAlphanum   ; Check if the character is alphanumeric
0311   30 04                  JR   nc,ident3   ; If not alphanumeric, jump to ident3
0313                IDENT2:      
0313   77                     LD   (hl),a   ; Write the current character to the string buffer
0314   23                     INC   hl   ; Move to the next position in the buffer
0315   18 EE                  JR   ident1   ; Repeat the process
0317                IDENT3:      
0317   CD 53 04               CALL   rewindChar   ; Rewind the input stream by one character
031A   22 71 09               LD   (vStrPtr),hl   ; Update the top of strings heap pointer
031D   B7                     OR   a   ; Clear A register
031E   ED 52                  SBC   hl,de   ; Calculate the length of the string (HL = length, DE = string)
0320   EB                     EX   de,hl   ; Swap DE and HL (E = length, HL = string)
0321   73                     LD   (hl),e   ; Store the length at the beginning of the string buffer
0322   7B                     LD   a,e   ; Load the length into A
0323   C9                     RET      
0324                             ; *****************************************************************************
0324                             ; Routine: expr
0324                             ; 
0324                             ; Purpose:
0324                             ;    Collects a string until it reaches a right parenthesis, comma, semicolon,
0324                             ;    or newline character. Keeps track of parentheses to ensure correct ending
0324                             ;    of the expression.
0324                             ; 
0324                             ; Inputs:
0324                             ;    None
0324                             ; 
0324                             ; Outputs:
0324                             ;    HL - Points to the collected string.
0324                             ;    A - Contains the length of the collected string.
0324                             ; 
0324                             ; Registers Destroyed:
0324                             ;    A, C, D, E, HL
0324                             ; *****************************************************************************
0324                EXPR:        
0324   2A 71 09               LD   hl,(vStrPtr)   ; Load the address of the top of strings heap
0327   54 5D                  LD   de,hl   ; Copy it to DE (DE = HL = top of strings heap)
0329   23                     INC   hl   ; Move to the next byte to skip the length byte
032A   0E 01                  LD   c,1   ; Initialize parenthesis count to 1
032C                EXPR1:       
032C   77                     LD   (hl),a   ; Write the current character to the string buffer
032D   23                     INC   hl   ; Move to the next position in the buffer
032E   CD 2B 04               CALL   nextChar   ; Get the next character from the input stream
0331   FE 28                  CP   "("   ; Compare with left parenthesis character
0333   28 17                  JR   z,expr2   ; If left parenthesis, increase count
0335   FE 29                  CP   ")"   ; Compare with right parenthesis character
0337   28 16                  JR   z,expr3   ; If right parenthesis, decrease count
0339   FE 2C                  CP   ","   ; Compare with comma character
033B   28 17                  JR   z,expr4   ; If comma, check if parentheses count is zero
033D   FE 3B                  CP   ";"   ; Compare with semicolon character
033F   28 13                  JR   z,expr4   ; If semicolon, check if parentheses count is zero
0341   FE 0A                  CP   "\n"   ; Compare with newline character
0343   28 0F                  JR   z,expr4   ; If newline, check if parentheses count is zero
0345   CD 6B 03               CALL   isAlphanum   ; Check if the character is alphanumeric
0348   30 0A                  JR   nc,expr4   ; If not alphanumeric, check if parentheses count is zero
034A   18 E0                  JR   expr1   ; Repeat the process
034C                EXPR2:       
034C   0C                     INC   c   ; Increase parentheses count
034D   18 DD                  JR   expr1   ; Repeat the process
034F                EXPR3:       
034F   0D                     DEC   c   ; Decrease parentheses count
0350   20 DA                  JR   nz,expr1   ; If not zero, continue collecting
0352   18 04                  JR   expr5   ; If zero, end collection
0354                EXPR4:       
0354   AF                     XOR   a   
0355   B9                     CP   c   ; Check if parentheses count is zero
0356   20 D4                  JR   nz,expr1   ; If not zero, continue collecting
0358                EXPR5:       
0358   CD 53 04               CALL   rewindChar   ; Rewind the input stream by one character
035B   22 71 09               LD   (vStrPtr),hl   ; Update the top of strings heap pointer
035E   B7                     OR   a   ; Clear A register
035F   ED 52                  SBC   hl,de   ; Calculate the length of the string (HL = length, DE = string)
0361   EB                     EX   de,hl   ; Swap DE and HL (E = length, HL = string)
0362   73                     LD   (hl),e   ; Store the length at the beginning of the string buffer
0363   7B                     LD   a,e   ; Load the length into A
0364   C9                     RET      
0365                             ; *****************************************************************************
0365                             ; Routine: isSpace
0365                             ; 
0365                             ; Purpose:
0365                             ;    Checks if the character in the A register is a space or tab character.
0365                             ; 
0365                             ; Input:
0365                             ;    A - Contains the character to be checked.
0365                             ; 
0365                             ; Output:
0365                             ;    A - Contains the character to be checked.
0365                             ;    CF - Set if the input character was space or tab, cleared otherwise.
0365                             ; 
0365                             ; Destroyed:
0365                             ;    None
0365                             ; *****************************************************************************
0365                ISSPACE:      
0365   FE 20                  CP   " "   ; Compare with space character
0367   C8                     RET   z   ; Return if it's space
0368   FE 09                  CP   "\t"   ; Compare with tab character
036A   C9                     RET      ; Return
036B                             ; *****************************************************************************
036B                             ; Routine: isAlphaNum
036B                             ; 
036B                             ; Purpose:
036B                             ;    Checks if the character in the A register is an alphanumeric character
036B                             ;    (either uppercase or lowercase). If the character is alphabetic, it converts
036B                             ;    it to uppercase and sets the carry flag. If the character is not alphabetic,
036B                             ;    it clears the carry flag.
036B                             ; 
036B                             ; Input:
036B                             ;    A - Contains the character to be checked.
036B                             ; 
036B                             ; Output:
036B                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
036B                             ;    CF - Set if the input character was alphabetic, cleared otherwise.
036B                             ; 
036B                             ; Destroyed:
036B                             ;    C
036B                             ; *****************************************************************************
036B                ISALPHANUM:      
036B   CD 7C 03               CALL   isDigit   ; Check if it's a digit
036E   C8                     RET   z   ; If it's not a digit, continue to isAlpha
036F                             ; Falls through to isAlpha
036F                             ; *****************************************************************************
036F                             ; Routine: isAlpha
036F                             ; 
036F                             ; Purpose:
036F                             ;    Checks if the character in the A register is an alphabetic character
036F                             ;    (either uppercase or lowercase). If the character is alphabetic, it converts
036F                             ;    it to uppercase and sets the carry flag.
036F                             ; 
036F                             ; Input:
036F                             ;    A - Contains the character to be checked.
036F                             ; 
036F                             ; Output:
036F                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
036F                             ;    CF - Set if the input character was alphabetic, cleared otherwise.
036F                             ; 
036F                             ; Destroyed:
036F                             ;    None
036F                             ; *****************************************************************************
036F                ISALPHA:      
036F   FE 61                  CP   "a"   ; Compare with lowercase "a"
0371   38 02                  JR   c,isAlpha1   ; Jump if it"s lower than "a'
0373   D6 20                  SUB   $20   ; Convert lowercase to uppercase
0375                ISALPHA1:      
0375   FE 5B                  CP   "Z"+1   ; Compare with "Z" + 1
0377   D0                     RET   nc   ; Return if it's not alphabetic
0378   FE 41                  CP   "A"   ; Compare with "A"
037A   3F                     CCF      ; Invert CF to set it if it's alphabetic
037B   C9                     RET      ; Return
037C                             ; *****************************************************************************
037C                             ; Routine: isDigit
037C                             ; 
037C                             ; Purpose:
037C                             ;    Checks if the character in the A register is a decimal digit (0-9). If
037C                             ;    the character is a decimal digit, it sets the carry flag.
037C                             ; 
037C                             ; Input:
037C                             ;    A - Contains the character to be checked.
037C                             ; 
037C                             ; Output:
037C                             ;    CF - Set if the input character was a digit, cleared otherwise.
037C                             ; 
037C                             ; Destroyed:
037C                             ;    None
037C                             ; *****************************************************************************
037C                ISDIGIT:      
037C   FE 3A                  CP   "9"+1   ; Compare with "9" + 1
037E   D0                     RET   nc   ; Return if it's not a digit
037F   FE 30                  CP   "0"   ; Compare with "0"
0381   3F                     CCF      ; Invert CF to set it if it's a digit
0382   C9                     RET      ; Return
0383                             ; *****************************************************************************
0383                             ; Routine: number
0383                             ; 
0383                             ; Purpose:
0383                             ;    Parse a number from the input. Handles both decimal and hexadecimal
0383                             ;    numbers, and supports negative numbers.
0383                             ; 
0383                             ; Input:
0383                             ;    None
0383                             ; 
0383                             ; Output:
0383                             ;    HL - Contains the parsed number.
0383                             ; 
0383                             ; Destroyed:
0383                             ;    None
0383                             ; *****************************************************************************
0383                NUMBER:      
0383   FE 2D                  CP   "-"   ; Check if it's a negative number
0385   3E FF                  LD   a,-1   ; Set sign flag
0387   28 01                  JR   z,number1   
0389   3C                     INC   a   ; Set sign flag to positive
038A                NUMBER1:      
038A   32 66 09               LD   (vTemp1),a   ; Store the sign flag in vTemp1
038D   CD 2B 04               CALL   nextChar   ; Get the next character
0390   FE 24                  CP   "$"   ; Check if it's a hexadecimal number
0392   20 05                  JR   nz,number2   
0394   CD B8 03               CALL   hex   ; If yes, parse hexadecimal number
0397   18 06                  JR   number3   
0399                NUMBER2:      
0399   CD 53 04               CALL   rewindChar   ; Push back the character
039C   CD E3 03               CALL   decimal   ; Parse decimal number
039F                NUMBER3:      
039F   3A 66 09               LD   a,(vTemp1)   ; Load the sign from vTemp1
03A2   3C                     INC   a   ; Increment to negate if necessary
03A3   C0                     RET   nz   ; Return if sign is not zero
03A4   EB                     EX   de,hl   ; Negate the value of HL
03A5   21 00 00               LD   hl,0   ; Load zero to clear carry
03A8   B7                     OR   a   ; Clear carry flag
03A9   ED 52                  SBC   hl,de   ; Subtract DE from HL
03AB   CD 53 04               CALL   rewindChar   ; Push back the character
03AE   C9                     RET      ; Return
03AF                NUMBER_HEX:      
03AF   AF                     XOR   a   
03B0   32 66 09               LD   (vTemp1),a   ; Store the sign flag in vTemp1
03B3   CD B8 03               CALL   hex   ; Parse hexadecimal number
03B6   18 E7                  JR   number3   
03B8                             ; *****************************************************************************
03B8                             ; Routine: hex
03B8                             ; 
03B8                             ; Purpose:
03B8                             ;    Parse a hexadecimal number.
03B8                             ; 
03B8                             ; Input:
03B8                             ;    None
03B8                             ; 
03B8                             ; Output:
03B8                             ;    HL - Parsed number.
03B8                             ; 
03B8                             ; Destroyed:
03B8                             ;    A
03B8                             ; *****************************************************************************
03B8                HEX:         
03B8   21 00 00               LD   hl,0   ; Initialize HL to 0
03BB                HEX1:        
03BB   CD 2B 04               CALL   nextChar   ; Get the next character
03BE   FE 30                  CP   "0"   ; Compare with ASCII "0"
03C0   D8                     RET   c   ; Return if less than "0"
03C1   FE 3A                  CP   "9"+1   ; Compare with ASCII "9" + 1
03C3   38 0F                  JR   c,valid   ; If less or equal, jump to valid
03C5   FE 61                  CP   "a"   ; Compare with ASCII "a"
03C7   38 02                  JR   c,hex2   ; If less, jump to hex2
03C9   D6 20                  SUB   $20   ; Convert lowercase to uppercase
03CB                HEX2:        
03CB   FE 41                  CP   "A"   ; Compare with ASCII "A"
03CD   D8                     RET   c   ; Return if less than "A"
03CE   FE 47                  CP   "F"+1   ; Compare with ASCII "F" + 1
03D0   38 00                  JR   c,upper   ; If less or equal, jump to upper
03D2                UPPER:       
03D2   D6 37                  SUB   $37   ; Convert ASCII to hexadecimal
03D4                VALID:       
03D4   D6 30                  SUB   "0"   ; Convert ASCII to numeric value
03D6   D8                     RET   c   ; Return if less than 0 (not a valid digit)
03D7   FE 10                  CP   $10   ; Compare with 16
03D9   D0                     RET   nc   ; Return if greater than 16 (not a valid digit)
03DA   29                     ADD   hl,hl   ; Multiply by 16
03DB   29                     ADD   hl,hl   ; Multiply by 16
03DC   29                     ADD   hl,hl   ; Multiply by 16
03DD   29                     ADD   hl,hl   ; Multiply by 16
03DE   85                     ADD   a,l   ; Add new digit to HL
03DF   6F                     LD   l,a   ; Store result back in L
03E0   C3 BB 03               JP   hex1   ; Jump back to hex1 to process next character
03E3                             ; *****************************************************************************
03E3                             ; Routine: decimal
03E3                             ; 
03E3                             ; Purpose:
03E3                             ;    Parse a decimal number.
03E3                             ; 
03E3                             ; Input:
03E3                             ;    None
03E3                             ; 
03E3                             ; Output:
03E3                             ;    HL - Parsed number.
03E3                             ; 
03E3                             ; Destroyed:
03E3                             ;    A, DE
03E3                             ; *****************************************************************************
03E3                DECIMAL:      
03E3   21 00 00               LD   hl,0   ; Initialize HL to 0
03E6                DECIMAL1:      
03E6   CD 2B 04               CALL   nextChar   ; Get the next character
03E9   D6 30                  SUB   "0"   ; Convert ASCII to binary
03EB   D8                     RET   c   ; Return if less than "0"
03EC   FE 0A                  CP   10   ; Compare with 10
03EE   D0                     RET   nc   ; Return if greater than 10
03EF   03                     INC   bc   ; Increment BC to point to next digit
03F0   54 5D                  LD   de,hl   ; Copy HL to DE
03F2   29                     ADD   hl,hl   ; Multiply HL by 2
03F3   29                     ADD   hl,hl   ; Multiply HL by 4
03F4   19                     ADD   hl,de   ; Add DE to HL to multiply by 5
03F5   29                     ADD   hl,hl   ; Multiply HL by 10
03F6   85                     ADD   a,l   ; Add A to HL
03F7   6F                     LD   l,a   ; Store result back in L
03F8   3E 00                  LD   a,0   ; Clear A
03FA   8C                     ADC   a,h   ; Add carry to H
03FB   67                     LD   h,a   ; Store result back in H
03FC   18 E8                  JR   decimal1   ; Jump back to start of loop
03FE                             ; *****************************************************************************
03FE                             ; Routine: searchStr
03FE                             ; 
03FE                             ; Purpose:
03FE                             ;    Search through a list of Pascal strings for a match.
03FE                             ; 
03FE                             ; Inputs:
03FE                             ;    HL - Points to the string to search for.
03FE                             ;    DE - Points to the start of the list of strings.
03FE                             ; 
03FE                             ; Outputs:
03FE                             ;    CF - True if match, false otherwise.
03FE                             ;    A - Index of the matching string if a match is found, or -1 if no match
03FE                             ;        is found.
03FE                             ;    HL - Points to the string to search for.
03FE                             ; 
03FE                             ; Destroyed:
03FE                             ;    A, B, C, D, E, A", F"
03FE                             ; *****************************************************************************
03FE                SEARCHSTR:      
03FE   EB                     EX   de,hl   ; DE = search string, HL = string list
03FF   AF                     XOR   a   ; Initialize index counter, ZF = true, CF = false
0400   08                     EX   af,af'   ; Exchange AF with AF prime
0401                SEARCHSTRLOOP:      
0401   1A                     LD   a,(de)   ; Load length of search string
0402   47                     LD   b,a   ; Copy length to B for looping
0403   D5                     PUSH   de   ; Store search string
0404   E5                     PUSH   hl   ; Store current string
0405   BE                     CP   (hl)   ; Compare with length of current string
0406   20 0F                  JR   nz,searchStrNext   ; If lengths are not equal, move to next string
0408   13                     INC   de   ; Move to start of search string
0409   23                     INC   hl   ; Move to start of current string
040A                SEARCHSTRCHARLOOP:      
040A   1A                     LD   a,(de)   ; Load next character from search string
040B   BE                     CP   (hl)   ; Compare with next character in current string
040C   20 09                  JR   nz,searchStrNext   ; If characters are not equal, move to next string
040E   13                     INC   de   ; Move to next character in search string
040F   23                     INC   hl   ; Move to next character in current string
0410   10 F8                  DJNZ   searchStrCharLoop   ; Loop until all characters compared
0412   E1                     POP   hl   ; Discard current string
0413   E1                     POP   hl   ; HL = search string
0414   08                     EX   af,af'   ; Load index of match
0415   3F                     CCF      ; If match, CF = true
0416   C9                     RET      
0417                SEARCHSTRNEXT:      
0417   E1                     POP   hl   ; Restore current string
0418   D1                     POP   de   ; Restore search string
0419   7E                     LD   a,(hl)   ; Load length of current string
041A   3C                     INC   a   ; A = length byte plus length of string
041B   4F                     LD   c,a   ; BC = A
041C   06 00                  LD   b,0   
041E   09                     ADD   hl,bc   ; HL += BC, move to next string
041F   D5                     PUSH   de   ; Store search string
0420   E5                     PUSH   hl   ; Store current string
0421   08                     EX   af,af'   ; Increment index counter, ZF = false, CF = false
0422   3C                     INC   a   
0423   08                     EX   af,af'   
0424   7E                     LD   a,(hl)   ; A = length of next string
0425   B7                     OR   a   ; If A != 0, continue searching
0426   20 D9                  JR   nz,searchStrLoop   
0428   3D                     DEC   a   ; A = NO_MATCH (i.e., -1), ZF = false
0429   3F                     CCF      ; CF = false
042A   C9                     RET      
042B                             ; *****************************************************************************
042B                             ; Routine: nextChar
042B                             ; 
042B                             ; Purpose:
042B                             ;    Fetches the next character from the buffer. If the buffer is empty or
042B                             ;    contains a null character (0), it refills the buffer by calling nextLine.
042B                             ; 
042B                             ; Inputs:
042B                             ;    None
042B                             ; 
042B                             ; Outputs:
042B                             ;    A - The next character from the buffer
042B                             ; 
042B                             ; Registers Destroyed:
042B                             ;    A, D, E, HL
042B                             ; *****************************************************************************
042B                NEXTCHAR:      
042B   21 6A 09               LD   hl,vBufferPos   ; Load the offset of buffer position variable
042E   7E                     LD   a,(hl)   ; Load the current position offset in the buffer into A
042F   FE 50                  CP   BUFFER_SIZE   ; Compare with buffer size
0431   CA 3D 04               JP   z,nextLine   ; Jump to nextLine if end of buffer
0434   5F                     LD   e,a   ; Copy buffer position offset to E
0435   16 08                  LD   d,msb(buffer)   ; Load the MSB of the buffer's address into D
0437   1A                     LD   a,(de)   ; Load the character at the current buffer position into A
0438   B7                     OR   a   ; Check if the character is 0 (end of line)
0439   28 02                  JR   z,nextLine   ; Jump to nextLine if character is 0
043B   34                     INC   (hl)   ; Increment the buffer position offset
043C   C9                     RET      ; Return with the character in A
043D                             ; *****************************************************************************
043D                             ; Routine: nextLine
043D                             ; 
043D                             ; Purpose:
043D                             ;    Refills the buffer by repeatedly calling getchar to fetch new characters
043D                             ;    and stores them in the buffer. Stops when the buffer is full or a
043D                             ;    non-printable character is encountered.
043D                             ; 
043D                             ; Inputs:
043D                             ;    None
043D                             ; 
043D                             ; Outputs:
043D                             ;    A - The first character in the refilled buffer
043D                             ; 
043D                             ; Registers Destroyed:
043D                             ;    A, B, HL
043D                             ; *****************************************************************************
043D                NEXTLINE:      
043D   21 00 08               LD   hl,buffer   ; Start of the buffer
0440   06 50                  LD   b,BUFFER_SIZE   ; Number of bytes to fill
0442                NEXTLINE1:      
0442   CD 81 00               CALL   getchar   ; Get a character from getchar
0445   77                     LD   (hl),a   ; Store it in the buffer
0446   23                     INC   hl   ; Move to the next position in the buffer
0447   FE 20                  CP   " "   ; Check if the character is a space
0449   38 02                  JR   c,nextLine2   ; If less than space (non-printable), skip djnz
044B   10 F5                  DJNZ   nextLine1   ; Repeat until B decrements to 0
044D                NEXTLINE2:      
044D   AF                     XOR   a   ; Clear A register
044E   32 6A 09               LD   (vBufferPos),a   ; Reset buffer position to 0
0451   18 D8                  JR   nextChar   ; Jump back to nextChar to return the first char
0453                             ; *****************************************************************************
0453                             ; Routine: rewindChar
0453                             ; 
0453                             ; Purpose:
0453                             ;    Rewinds the buffer position by one character, effectively pushing back the
0453                             ;    buffer position by one character in the input stream.
0453                             ; 
0453                             ; Inputs:
0453                             ;    None
0453                             ; 
0453                             ; Outputs:
0453                             ;    None
0453                             ; 
0453                             ; Registers Destroyed:
0453                             ;    A
0453                             ; *****************************************************************************
0453                REWINDCHAR:      
0453   21 6A 09               LD   hl,vBufferPos   ; Load the address of buffer position variable
0456   7E                     LD   a,(hl)   ; Load the current position in the buffer into A
0457   B7                     OR   a   ; Check if the buffer position is zero
0458   C8                     RET   z   ; If zero, nothing to push back, return
0459   35                     DEC   (hl)   ; Decrement the buffer position
045A   C9                     RET      ; Return
045B                PROMPT:      
045B   CD 70 04               CALL   print   
045E   04 0D 0A 3E 20         .PSTR   "\r\n> "   
0463   C9                     RET      
0464                CRLF:        
0464   CD 70 04               CALL   print   
0467   02 0D 0A               .PSTR   "\r\n"   
046A   C9                     RET      
046B                ERROR:       
046B   E1                     POP   hl   
046C   CD 75 04               CALL   printStr   
046F   76                     HALT      
0470                PRINT:       
0470   E1                     POP   hl   ; "return" address is address of string			
0471   CD 75 04               CALL   printStr   
0474   E9                     JP   (hl)   ; put it back	
0475                             ; print
0475                             ; 
0475                             ; Prints a Pascal string to the console.
0475                             ; 
0475                             ; Input:
0475                             ;   hl: Points to the start of the Pascal string in memory. The first byte at this location should be the length of the string, followed by the string data.
0475                             ; 
0475                             ; Output:
0475                             ;   hl: points to the byte after the end of the string .
0475                             ; 
0475                             ; Destroyed:
0475                             ;   a, b
0475                PRINTSTR:      
0475   7E                     LD   a,(hl)   ; Load the length of the string
0476   B7                     OR   a   ; Check if A is zero
0477   C8                     RET   z   ; If it is, return immediately
0478   23                     INC   hl   ; Move to the start of the string data
0479   47                     LD   b,a   ; Copy the length to B for looping
047A                PRINTSTR1:      
047A   7E                     LD   a,(hl)   ; Load the next character
047B   CD 85 00               CALL   putchar   ; Call a routine that prints a single character
047E   23                     INC   hl   ; Move to the next character
047F   10 F9                  DJNZ   printStr1   ; Decrement B and jump if not zero
0481   C9                     RET      ; Return from the routine
0482                             ; *******************************************************************************
0482                             ; *********  END OF MAIN   ******************************************************
0482                             ; *******************************************************************************
0482                ROT_OPCODES:      
0482   03 52 4C 43            .PSTR   "RLC"   
0486   03 52 52 43            .PSTR   "RRC"   
048A   02 52 4C               .PSTR   "RL"   
048D   02 52 52               .PSTR   "RR"   
0490   03 53 4C 41            .PSTR   "SLA"   
0494   03 53 52 41            .PSTR   "SRA"   
0498   03 53 4C 4C            .PSTR   "SLL"   
049C   03 53 52 4C            .PSTR   "SRL"   
04A0   00                     .PSTR   ""   ; terminate list with a string of zero length
04A1                ALU_OPCODES:      
04A1   03 41 44 44            .PSTR   "ADD"   
04A5   03 41 44 43            .PSTR   "ADC"   
04A9   03 53 55 42            .PSTR   "SUB"   
04AD   03 53 42 43            .PSTR   "SBC"   
04B1   03 41 4E 44            .PSTR   "AND"   
04B5   03 58 4F 52            .PSTR   "XOR"   
04B9   02 4F 52               .PSTR   "OR"   
04BC   02 43 50               .PSTR   "CP"   
04BF   00                     .PSTR   ""   ; terminate list with a string of zero length
04C0                GEN_OPCODES:      
04C0   03 42 49 54            .PSTR   "BIT"   
04C4   04 43 41 4C 4C         .PSTR   "CALL"   
04C9   03 43 43 46            .PSTR   "CCF"   
04CD   03 43 50 44            .PSTR   "CPD"   
04D1   04 43 50 44 52         .PSTR   "CPDR"   
04D6   03 43 50 49            .PSTR   "CPI"   
04DA   04 43 50 49 52         .PSTR   "CPIR"   
04DF   03 43 50 4C            .PSTR   "CPL"   
04E3   03 44 41 41            .PSTR   "DAA"   
04E7   03 44 45 43            .PSTR   "DEC"   
04EB   02 44 49               .PSTR   "DI"   
04EE   04 44 4A 4E 5A         .PSTR   "DJNZ"   
04F3   02 45 49               .PSTR   "EI"   
04F6   02 45 58               .PSTR   "EX"   
04F9   03 45 58 58            .PSTR   "EXX"   
04FD   04 48 41 4C 54         .PSTR   "HALT"   
0502   02 49 4D               .PSTR   "IM"   
0505   02 49 4E               .PSTR   "IN"   
0508   03 49 4E 43            .PSTR   "INC"   
050C   03 49 4E 44            .PSTR   "IND"   
0510   04 49 4E 44 52         .PSTR   "INDR"   
0515   03 49 4E 49            .PSTR   "INI"   
0519   04 49 4E 49 52         .PSTR   "INIR"   
051E   02 4A 50               .PSTR   "JP"   
0521   02 4A 52               .PSTR   "JR"   
0524   02 4C 44               .PSTR   "LD"   
0527   03 4C 44 44            .PSTR   "LDD"   
052B   04 4C 44 44 52         .PSTR   "LDDR"   
0530   03 4C 44 49            .PSTR   "LDI"   
0534   04 4C 44 49 52         .PSTR   "LDIR"   
0539   03 4E 45 47            .PSTR   "NEG"   
053D   03 4E 4F 50            .PSTR   "NOP"   
0541   04 4F 54 44 52         .PSTR   "OTDR"   
0546   04 4F 54 49 52         .PSTR   "OTIR"   
054B   03 4F 55 54            .PSTR   "OUT"   
054F   04 4F 55 54 44         .PSTR   "OUTD"   
0554   04 4F 55 54 49         .PSTR   "OUTI"   
0559   03 50 4F 50            .PSTR   "POP"   
055D   04 50 55 53 48         .PSTR   "PUSH"   
0562   03 52 45 53            .PSTR   "RES"   
0566   03 52 45 54            .PSTR   "RET"   
056A   04 52 45 54 49         .PSTR   "RETI"   
056F   04 52 45 54 4E         .PSTR   "RETN"   
0574   03 52 4C 41            .PSTR   "RLA"   
0578   04 52 4C 43 41         .PSTR   "RLCA"   
057D   03 52 4C 44            .PSTR   "RLD"   
0581   03 52 52 41            .PSTR   "RRA"   
0585   04 52 52 43 41         .PSTR   "RRCA"   
058A   03 52 52 44            .PSTR   "RRD"   
058E   03 52 53 54            .PSTR   "RST"   
0592   03 53 43 46            .PSTR   "SCF"   
0596   03 53 45 54            .PSTR   "SET"   
059A   00                     .PSTR   ""   ; terminate list with a string of zero length
059B                REGISTERS:      
059B   01 42                  .PSTR   "B"   
059D   01 43                  .PSTR   "C"   
059F   01 44                  .PSTR   "D"   
05A1   01 45                  .PSTR   "E"   
05A3   01 48                  .PSTR   "H"   
05A5   01 4C                  .PSTR   "L"   
05A7   01 20                  .PSTR   " "   ; don't match, stand-in for (HL)
05A9   01 41                  .PSTR   "A"   
05AB   01 49                  .PSTR   "I"   
05AD   01 52                  .PSTR   "R"   
05AF   00                     .PSTR   ""   ; terminate list with a string of zero length
05B0                REG_PAIRS:      
05B0   02 42 43               .PSTR   "BC"   
05B3   02 44 45               .PSTR   "DE"   
05B6   02 48 4C               .PSTR   "HL"   
05B9   02 53 50               .PSTR   "SP"   
05BC   02 41 46               .PSTR   "AF"   ; NOTE: AF has the same code as SP in some instructions
05BF   02 49 58               .PSTR   "IX"   
05C2   02 49 59               .PSTR   "IY"   
05C5   03 41 46 27            .PSTR   "AF'"   
05C9   00                     .PSTR   ""   ; terminate list with a string of zero length
05CA                FLAGS:       
05CA   02 4E 5A               .PSTR   "NZ"   
05CD   01 5A                  .PSTR   "Z"   
05CF   02 4E 43               .PSTR   "NC"   
05D2   01 43                  .PSTR   "C"   
05D4   02 50 4F               .PSTR   "PO"   
05D7   02 50 45               .PSTR   "PE"   
05DA   01 50                  .PSTR   "P"   
05DC   01 4D                  .PSTR   "M"   
05DE   00                     .PSTR   ""   ; terminate list with a string of zero length
05DF                DIRECTIVES:      
05DF   06 2E 41 4C 49 47 4E   .PSTR   ".ALIGN"   
05E6   03 2E 44 42            .PSTR   ".DB"   
05EA   04 2E 4F 52 47         .PSTR   ".ORG"   
05EF   04 2E 53 45 54         .PSTR   ".SET"   
05F4   00                     .PSTR   ""   ; terminate list with a string of zero length
05F5                             ; *******************************************************************************
05F5                             ; *********  END OF DATA   ******************************************************
05F5                             ; *******************************************************************************
0800                          .ORG   RAMSTART   
0800                          ALIGN   $100   
0800                BUFFER:   DS   BUFFER_SIZE   ; line buffer, page aligned
0850                          DS   $100   
0950                STACK:       ; grows down
0950                RST08:    DS   2   
0952                RST10:    DS   2   
0954                RST18:    DS   2   
0956                RST20:    DS   2   
0958                RST28:    DS   2   
095A                RST30:    DS   2   ; 
095C                BAUD:     DS   2   ; 
095E                INTVEC:   DS   2   ; 
0960                NMIVEC:   DS   2   ; 
0962                GETCVEC:   DS   2   ; 
0964                PUTCVEC:   DS   2   ; 
0966                VTEMP1:   DS   2   ; temp var 1
0968                VTEMP2:   DS   2   ; temp var 2
096A                VBUFFERPOS:   DS   2   ; pointer to char position into input buffer
096C                VTOKEN:   DS   1   ; buffer for pushed back token
096D                VTOKENVAL:   DS   2   ; buffer for pushed back token value
096F                VASMPTR:   DS   2   ; pointer to assembly point
0971                VSTRPTR:   DS   2   ; pointer to string stack
0973                VSYMPTR:   DS   2   ; pointer to symbol stack
0975                VEXPRPTR:   DS   2   ; pointer to expression stack
0977                STRINGS:   DS   $100   ; string heap - grows up
0A77                SYMBOLS:   DS   $100   ; symbol heap - grows up
0B77                EXPRS:    DS   $100   ; expression heap - grows up
0C77                ASSEMBLY:      


ROMSTART:           0000 DEFINED AT LINE 1 IN constants.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 116 IN IOSerial.asm
                    > USED AT LINE 122 IN IOSerial.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 134 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 146 IN IOSerial.asm
                    > USED AT LINE 152 IN IOSerial.asm
                    > USED AT LINE 158 IN IOSerial.asm
                    > USED AT LINE 200 IN IOSerial.asm
                    > USED AT LINE 17 IN MAIN.asm
RAMSTART:           0800 DEFINED AT LINE 2 IN constants.asm
                    > USED AT LINE 1 IN ram.asm
ROMSIZE:            0800 DEFINED AT LINE 3 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 4 IN constants.asm
NO_MATCH:           00-1 DEFINED AT LINE 6 IN constants.asm
CTRL_H:             0008 DEFINED AT LINE 7 IN constants.asm
BUFFER_SIZE:        0050 DEFINED AT LINE 8 IN constants.asm
                    > USED AT LINE 834 IN MAIN.asm
                    > USED AT LINE 864 IN MAIN.asm
                    > USED AT LINE 5 IN ram.asm
TOKENS:             0000 DEFINED AT LINE 10 IN constants.asm
COLON_:             000: DEFINED AT LINE 12 IN constants.asm
COMMA_:             000, DEFINED AT LINE 13 IN constants.asm
                    > USED AT LINE 179 IN MAIN.asm
DIRECT_:            000D DEFINED AT LINE 14 IN constants.asm
                    > USED AT LINE 154 IN MAIN.asm
                    > USED AT LINE 304 IN MAIN.asm
DOLLAR_:            000$ DEFINED AT LINE 15 IN constants.asm
EOF_:               000E DEFINED AT LINE 16 IN constants.asm
                    > USED AT LINE 117 IN MAIN.asm
                    > USED AT LINE 161 IN MAIN.asm
                    > USED AT LINE 172 IN MAIN.asm
                    > USED AT LINE 236 IN MAIN.asm
                    > USED AT LINE 242 IN MAIN.asm
FLAG_:              000F DEFINED AT LINE 17 IN constants.asm
                    > USED AT LINE 296 IN MAIN.asm
IDENT_:             000I DEFINED AT LINE 18 IN constants.asm
                    > USED AT LINE 308 IN MAIN.asm
LABEL_:             000L DEFINED AT LINE 19 IN constants.asm
                    > USED AT LINE 143 IN MAIN.asm
                    > USED AT LINE 267 IN MAIN.asm
LPAREN_:            000( DEFINED AT LINE 20 IN constants.asm
NEWLN_:             000
 DEFINED AT LINE 21 IN constants.asm
                    > USED AT LINE 159 IN MAIN.asm
                    > USED AT LINE 170 IN MAIN.asm
NUM_:               0009 DEFINED AT LINE 22 IN constants.asm
                    > USED AT LINE 332 IN MAIN.asm
OPCODE_:            000C DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 148 IN MAIN.asm
                    > USED AT LINE 275 IN MAIN.asm
REG_:               000R DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 289 IN MAIN.asm
REGPAIR_:           000P DEFINED AT LINE 25 IN constants.asm
                    > USED AT LINE 282 IN MAIN.asm
RPAREN_:            000) DEFINED AT LINE 26 IN constants.asm
UNKNOWN_:           000U DEFINED AT LINE 27 IN constants.asm
                    > USED AT LINE 342 IN MAIN.asm
ALU_IDX:            0000 DEFINED AT LINE 29 IN constants.asm
ADD_:               0000 DEFINED AT LINE 31 IN constants.asm
ADC_:               0001 DEFINED AT LINE 32 IN constants.asm
SUB_:               0002 DEFINED AT LINE 33 IN constants.asm
SBC_:               0003 DEFINED AT LINE 34 IN constants.asm
AND_:               0004 DEFINED AT LINE 35 IN constants.asm
XOR_:               0005 DEFINED AT LINE 36 IN constants.asm
OR_:                0006 DEFINED AT LINE 37 IN constants.asm
CP_:                0007 DEFINED AT LINE 38 IN constants.asm
ROT_IDX:            0000 DEFINED AT LINE 40 IN constants.asm
RLC_:               0010 DEFINED AT LINE 42 IN constants.asm
RRC_:               0011 DEFINED AT LINE 43 IN constants.asm
RL_:                0012 DEFINED AT LINE 44 IN constants.asm
RR_:                0013 DEFINED AT LINE 45 IN constants.asm
SLA_:               0014 DEFINED AT LINE 46 IN constants.asm
SRA_:               0015 DEFINED AT LINE 47 IN constants.asm
SLL_:               0016 DEFINED AT LINE 48 IN constants.asm
SRL_:               0017 DEFINED AT LINE 49 IN constants.asm
GEN_IDX:            0000 DEFINED AT LINE 51 IN constants.asm
BIT_:               0040 DEFINED AT LINE 54 IN constants.asm
CALL_:              0041 DEFINED AT LINE 55 IN constants.asm
CCF_:               0042 DEFINED AT LINE 56 IN constants.asm
CPD_:               0043 DEFINED AT LINE 57 IN constants.asm
CPDR_:              0044 DEFINED AT LINE 58 IN constants.asm
CPI_:               0045 DEFINED AT LINE 59 IN constants.asm
CPIR_:              0046 DEFINED AT LINE 60 IN constants.asm
CPL_:               0047 DEFINED AT LINE 61 IN constants.asm
DAA_:               0048 DEFINED AT LINE 62 IN constants.asm
DEC_:               0049 DEFINED AT LINE 63 IN constants.asm
DI_:                004A DEFINED AT LINE 64 IN constants.asm
DJNZ_:              004B DEFINED AT LINE 65 IN constants.asm
EI_:                004C DEFINED AT LINE 66 IN constants.asm
EX_:                004D DEFINED AT LINE 67 IN constants.asm
EXX_:               004E DEFINED AT LINE 68 IN constants.asm
HALT_:              004F DEFINED AT LINE 69 IN constants.asm
IM_:                0050 DEFINED AT LINE 70 IN constants.asm
IN_:                0051 DEFINED AT LINE 71 IN constants.asm
INC_:               0052 DEFINED AT LINE 72 IN constants.asm
IND_:               0053 DEFINED AT LINE 73 IN constants.asm
INDR_:              0054 DEFINED AT LINE 74 IN constants.asm
INI_:               0055 DEFINED AT LINE 75 IN constants.asm
INIR_:              0056 DEFINED AT LINE 76 IN constants.asm
JP_:                0057 DEFINED AT LINE 77 IN constants.asm
JR_:                0058 DEFINED AT LINE 78 IN constants.asm
LD_:                0059 DEFINED AT LINE 79 IN constants.asm
LDD_:               005A DEFINED AT LINE 80 IN constants.asm
LDDR_:              005B DEFINED AT LINE 81 IN constants.asm
LDI_:               005C DEFINED AT LINE 82 IN constants.asm
LDIR_:              005D DEFINED AT LINE 83 IN constants.asm
NEG_:               005E DEFINED AT LINE 84 IN constants.asm
NOP_:               005F DEFINED AT LINE 85 IN constants.asm
OTDR_:              0060 DEFINED AT LINE 86 IN constants.asm
OTIR_:              0061 DEFINED AT LINE 87 IN constants.asm
OUT_:               0062 DEFINED AT LINE 88 IN constants.asm
OUTD_:              0063 DEFINED AT LINE 89 IN constants.asm
OUTI_:              0064 DEFINED AT LINE 90 IN constants.asm
POP_:               0065 DEFINED AT LINE 91 IN constants.asm
PUSH_:              0066 DEFINED AT LINE 92 IN constants.asm
RES_:               0067 DEFINED AT LINE 93 IN constants.asm
RET_:               0068 DEFINED AT LINE 94 IN constants.asm
RETI_:              0069 DEFINED AT LINE 95 IN constants.asm
RETN_:              006A DEFINED AT LINE 96 IN constants.asm
RLA_:               006B DEFINED AT LINE 97 IN constants.asm
RLCA_:              006C DEFINED AT LINE 98 IN constants.asm
RLD_:               006D DEFINED AT LINE 99 IN constants.asm
RRA_:               006E DEFINED AT LINE 100 IN constants.asm
RRCA_:              006F DEFINED AT LINE 101 IN constants.asm
RRD_:               0070 DEFINED AT LINE 102 IN constants.asm
RST_:               0071 DEFINED AT LINE 103 IN constants.asm
SCF_:               0072 DEFINED AT LINE 104 IN constants.asm
SET_:               0003 DEFINED AT LINE 147 IN constants.asm
REG_IDX:            0000 DEFINED AT LINE 107 IN constants.asm
B_:                 0000 DEFINED AT LINE 109 IN constants.asm
C_:                 0003 DEFINED AT LINE 136 IN constants.asm
D_:                 0002 DEFINED AT LINE 111 IN constants.asm
E_:                 0003 DEFINED AT LINE 112 IN constants.asm
H_:                 0004 DEFINED AT LINE 113 IN constants.asm
L_:                 0005 DEFINED AT LINE 114 IN constants.asm
MHL_:               0006 DEFINED AT LINE 115 IN constants.asm
A_:                 0007 DEFINED AT LINE 116 IN constants.asm
I_:                 0008 DEFINED AT LINE 117 IN constants.asm
R_:                 0009 DEFINED AT LINE 118 IN constants.asm
REG_PAIR_IDX:       0000 DEFINED AT LINE 120 IN constants.asm
BC_:                0000 DEFINED AT LINE 122 IN constants.asm
DE_:                0001 DEFINED AT LINE 123 IN constants.asm
HL_:                0002 DEFINED AT LINE 124 IN constants.asm
SP_:                0003 DEFINED AT LINE 125 IN constants.asm
AF_:                0004 DEFINED AT LINE 126 IN constants.asm
IX_:                0005 DEFINED AT LINE 127 IN constants.asm
IY_:                0006 DEFINED AT LINE 128 IN constants.asm
AFP_:               0007 DEFINED AT LINE 129 IN constants.asm
FLAG_IDX:           0000 DEFINED AT LINE 131 IN constants.asm
NZ_:                0000 DEFINED AT LINE 133 IN constants.asm
Z_:                 0001 DEFINED AT LINE 134 IN constants.asm
NC_:                0002 DEFINED AT LINE 135 IN constants.asm
PO_:                0004 DEFINED AT LINE 137 IN constants.asm
PE_:                0005 DEFINED AT LINE 138 IN constants.asm
P_:                 0006 DEFINED AT LINE 139 IN constants.asm
M_:                 0007 DEFINED AT LINE 140 IN constants.asm
DIRECTIVE_IDX:      0000 DEFINED AT LINE 142 IN constants.asm
ALIGN_:             0000 DEFINED AT LINE 144 IN constants.asm
DB_:                0001 DEFINED AT LINE 145 IN constants.asm
ORG_:               0002 DEFINED AT LINE 146 IN constants.asm
TEC_1:              0001 DEFINED AT LINE 151 IN constants.asm
RC2014:             0000 DEFINED AT LINE 152 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 154 IN constants.asm
LOADER:             0000 DEFINED AT LINE 156 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 157 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 33 IN IOSerial.asm
                    > USED AT LINE 476 IN IOSerial.asm
                    > USED AT LINE 498 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 34 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 322 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 36 IN IOSerial.asm
                    > USED AT LINE 326 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 475 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 46 IN IOSerial.asm
                    > USED AT LINE 497 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 50 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 51 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 52 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 53 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 54 IN IOSerial.asm
                    > USED AT LINE 497 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 55 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 56 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 57 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 61 IN IOSerial.asm
                    > USED AT LINE 497 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 62 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 63 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 64 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 68 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 72 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 73 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 74 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 75 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 76 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 77 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 78 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 79 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 87 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 88 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 89 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 90 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 91 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 92 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 93 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 94 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 107 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 108 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 109 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 113 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 163 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 481 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 187 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 193 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 196 IN IOSerial.asm
                    > USED AT LINE 457 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 469 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 305 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 308 IN IOSerial.asm
                    > USED AT LINE 312 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 320 IN IOSerial.asm
                    > USED AT LINE 467 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 321 IN IOSerial.asm
                    > USED AT LINE 325 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 445 IN IOSerial.asm
                    > USED AT LINE 866 IN MAIN.asm
PUTCHAR:            0085 DEFINED AT LINE 449 IN IOSerial.asm
                    > USED AT LINE 943 IN MAIN.asm
RESET:              008B DEFINED AT LINE 455 IN IOSerial.asm
                    > USED AT LINE 114 IN IOSerial.asm
START:              0180 DEFINED AT LINE 37 IN MAIN.asm
                    > USED AT LINE 6
INIT:               0198 DEFINED AT LINE 60 IN MAIN.asm
                    > USED AT LINE 39 IN MAIN.asm
PARSE:              01BB DEFINED AT LINE 92 IN MAIN.asm
                    > USED AT LINE 42 IN MAIN.asm
STATEMENTLIST:      01E2 DEFINED AT LINE 115 IN MAIN.asm
                    > USED AT LINE 93 IN MAIN.asm
                    > USED AT LINE 120 IN MAIN.asm
STATEMENT:          01ED DEFINED AT LINE 139 IN MAIN.asm
                    > USED AT LINE 119 IN MAIN.asm
STATEMENT10:        01F4 DEFINED AT LINE 147 IN MAIN.asm
                    > USED AT LINE 144 IN MAIN.asm
STATEMENT1:         01F8 DEFINED AT LINE 153 IN MAIN.asm
                    > USED AT LINE 149 IN MAIN.asm
STATEMENT2:         01FC DEFINED AT LINE 158 IN MAIN.asm
                    > USED AT LINE 155 IN MAIN.asm
INSTRUCTION:        0203 DEFINED AT LINE 166 IN MAIN.asm
INSTRUCTION1:       020E DEFINED AT LINE 174 IN MAIN.asm
                    > USED AT LINE 171 IN MAIN.asm
INSTRUCTION2:       0211 DEFINED AT LINE 176 IN MAIN.asm
                    > USED AT LINE 173 IN MAIN.asm
FIRSTOPERAND:       021F DEFINED AT LINE 183 IN MAIN.asm
                    > USED AT LINE 177 IN MAIN.asm
SECONDOPERAND:      021F DEFINED AT LINE 184 IN MAIN.asm
                    > USED AT LINE 181 IN MAIN.asm
DIRECTIVE:          021F DEFINED AT LINE 186 IN MAIN.asm
NEXTTOKEN:          021F DEFINED AT LINE 218 IN MAIN.asm
                    > USED AT LINE 116 IN MAIN.asm
                    > USED AT LINE 146 IN MAIN.asm
                    > USED AT LINE 169 IN MAIN.asm
                    > USED AT LINE 178 IN MAIN.asm
                    > USED AT LINE 180 IN MAIN.asm
NEXTTOKEN0:         0230 DEFINED AT LINE 227 IN MAIN.asm
                    > USED AT LINE 220 IN MAIN.asm
                    > USED AT LINE 254 IN MAIN.asm
NEXTTOKEN1:         0233 DEFINED AT LINE 230 IN MAIN.asm
                    > USED AT LINE 233 IN MAIN.asm
NEXTTOKEN2:         0241 DEFINED AT LINE 239 IN MAIN.asm
                    > USED AT LINE 235 IN MAIN.asm
NEXTTOKEN3:         0248 DEFINED AT LINE 245 IN MAIN.asm
                    > USED AT LINE 241 IN MAIN.asm
NEXTTOKEN4:         024D DEFINED AT LINE 249 IN MAIN.asm
                    > USED AT LINE 252 IN MAIN.asm
NEXTTOKEN5:         0259 DEFINED AT LINE 256 IN MAIN.asm
                    > USED AT LINE 247 IN MAIN.asm
NEXTTOKEN6:         0262 DEFINED AT LINE 262 IN MAIN.asm
                    > USED AT LINE 258 IN MAIN.asm
NEXTTOKEN7:         026F DEFINED AT LINE 270 IN MAIN.asm
                    > USED AT LINE 266 IN MAIN.asm
NEXTTOKEN8:         027D DEFINED AT LINE 278 IN MAIN.asm
                    > USED AT LINE 274 IN MAIN.asm
NEXTTOKEN9:         0288 DEFINED AT LINE 285 IN MAIN.asm
                    > USED AT LINE 281 IN MAIN.asm
NEXTTOKEN10:        0293 DEFINED AT LINE 292 IN MAIN.asm
                    > USED AT LINE 288 IN MAIN.asm
NEXTTOKEN11:        029E DEFINED AT LINE 299 IN MAIN.asm
                    > USED AT LINE 295 IN MAIN.asm
NEXTTOKEN12:        02A9 DEFINED AT LINE 307 IN MAIN.asm
                    > USED AT LINE 302 IN MAIN.asm
NEXTTOKEN13:        02AC DEFINED AT LINE 311 IN MAIN.asm
                    > USED AT LINE 260 IN MAIN.asm
NEXTTOKEN14:        02C2 DEFINED AT LINE 322 IN MAIN.asm
                    > USED AT LINE 314 IN MAIN.asm
NEXTTOKEN15:        02CB DEFINED AT LINE 328 IN MAIN.asm
                    > USED AT LINE 324 IN MAIN.asm
NEXTTOKEN16:        02CE DEFINED AT LINE 331 IN MAIN.asm
                    > USED AT LINE 320 IN MAIN.asm
NEXTTOKEN17:        02D1 DEFINED AT LINE 335 IN MAIN.asm
                    > USED AT LINE 326 IN MAIN.asm
SEARCHOPCODE:       02DD DEFINED AT LINE 363 IN MAIN.asm
                    > USED AT LINE 273 IN MAIN.asm
PUSHBACKTOKEN:      02F6 DEFINED AT LINE 396 IN MAIN.asm
                    > USED AT LINE 175 IN MAIN.asm
IDENT:              02FF DEFINED AT LINE 424 IN MAIN.asm
                    > USED AT LINE 263 IN MAIN.asm
IDENT1:             0305 DEFINED AT LINE 428 IN MAIN.asm
                    > USED AT LINE 439 IN MAIN.asm
IDENT2:             0313 DEFINED AT LINE 436 IN MAIN.asm
                    > USED AT LINE 433 IN MAIN.asm
IDENT3:             0317 DEFINED AT LINE 440 IN MAIN.asm
                    > USED AT LINE 435 IN MAIN.asm
EXPR:               0324 DEFINED AT LINE 469 IN MAIN.asm
EXPR1:              032C DEFINED AT LINE 474 IN MAIN.asm
                    > USED AT LINE 490 IN MAIN.asm
                    > USED AT LINE 493 IN MAIN.asm
                    > USED AT LINE 496 IN MAIN.asm
                    > USED AT LINE 501 IN MAIN.asm
EXPR2:              034C DEFINED AT LINE 491 IN MAIN.asm
                    > USED AT LINE 479 IN MAIN.asm
EXPR3:              034F DEFINED AT LINE 494 IN MAIN.asm
                    > USED AT LINE 481 IN MAIN.asm
EXPR4:              0354 DEFINED AT LINE 498 IN MAIN.asm
                    > USED AT LINE 483 IN MAIN.asm
                    > USED AT LINE 485 IN MAIN.asm
                    > USED AT LINE 487 IN MAIN.asm
                    > USED AT LINE 489 IN MAIN.asm
EXPR5:              0358 DEFINED AT LINE 502 IN MAIN.asm
                    > USED AT LINE 497 IN MAIN.asm
ISSPACE:            0365 DEFINED AT LINE 529 IN MAIN.asm
                    > USED AT LINE 232 IN MAIN.asm
                    > USED AT LINE 316 IN MAIN.asm
ISALPHANUM:         036B DEFINED AT LINE 555 IN MAIN.asm
                    > USED AT LINE 259 IN MAIN.asm
                    > USED AT LINE 434 IN MAIN.asm
                    > USED AT LINE 488 IN MAIN.asm
ISALPHA:            036F DEFINED AT LINE 579 IN MAIN.asm
ISALPHA1:           0375 DEFINED AT LINE 583 IN MAIN.asm
                    > USED AT LINE 581 IN MAIN.asm
ISDIGIT:            037C DEFINED AT LINE 607 IN MAIN.asm
                    > USED AT LINE 325 IN MAIN.asm
                    > USED AT LINE 556 IN MAIN.asm
NUMBER:             0383 DEFINED AT LINE 631 IN MAIN.asm
                    > USED AT LINE 329 IN MAIN.asm
NUMBER1:            038A DEFINED AT LINE 636 IN MAIN.asm
                    > USED AT LINE 634 IN MAIN.asm
NUMBER2:            0399 DEFINED AT LINE 643 IN MAIN.asm
                    > USED AT LINE 640 IN MAIN.asm
NUMBER3:            039F DEFINED AT LINE 646 IN MAIN.asm
                    > USED AT LINE 642 IN MAIN.asm
                    > USED AT LINE 661 IN MAIN.asm
NUMBER_HEX:         03AF DEFINED AT LINE 657 IN MAIN.asm
                    > USED AT LINE 319 IN MAIN.asm
HEX:                03B8 DEFINED AT LINE 679 IN MAIN.asm
                    > USED AT LINE 641 IN MAIN.asm
                    > USED AT LINE 660 IN MAIN.asm
HEX1:               03BB DEFINED AT LINE 681 IN MAIN.asm
                    > USED AT LINE 708 IN MAIN.asm
HEX2:               03CB DEFINED AT LINE 690 IN MAIN.asm
                    > USED AT LINE 688 IN MAIN.asm
UPPER:              03D2 DEFINED AT LINE 695 IN MAIN.asm
                    > USED AT LINE 694 IN MAIN.asm
VALID:              03D4 DEFINED AT LINE 697 IN MAIN.asm
                    > USED AT LINE 686 IN MAIN.asm
DECIMAL:            03E3 DEFINED AT LINE 726 IN MAIN.asm
                    > USED AT LINE 645 IN MAIN.asm
DECIMAL1:           03E6 DEFINED AT LINE 728 IN MAIN.asm
                    > USED AT LINE 745 IN MAIN.asm
SEARCHSTR:          03FE DEFINED AT LINE 768 IN MAIN.asm
                    > USED AT LINE 280 IN MAIN.asm
                    > USED AT LINE 287 IN MAIN.asm
                    > USED AT LINE 294 IN MAIN.asm
                    > USED AT LINE 301 IN MAIN.asm
                    > USED AT LINE 365 IN MAIN.asm
                    > USED AT LINE 369 IN MAIN.asm
                    > USED AT LINE 374 IN MAIN.asm
SEARCHSTRLOOP:      0401 DEFINED AT LINE 773 IN MAIN.asm
                    > USED AT LINE 809 IN MAIN.asm
SEARCHSTRCHARLOOP:  040A DEFINED AT LINE 782 IN MAIN.asm
                    > USED AT LINE 788 IN MAIN.asm
SEARCHSTRNEXT:      0417 DEFINED AT LINE 794 IN MAIN.asm
                    > USED AT LINE 779 IN MAIN.asm
                    > USED AT LINE 785 IN MAIN.asm
NEXTCHAR:           042B DEFINED AT LINE 831 IN MAIN.asm
                    > USED AT LINE 231 IN MAIN.asm
                    > USED AT LINE 250 IN MAIN.asm
                    > USED AT LINE 264 IN MAIN.asm
                    > USED AT LINE 315 IN MAIN.asm
                    > USED AT LINE 431 IN MAIN.asm
                    > USED AT LINE 477 IN MAIN.asm
                    > USED AT LINE 638 IN MAIN.asm
                    > USED AT LINE 682 IN MAIN.asm
                    > USED AT LINE 729 IN MAIN.asm
                    > USED AT LINE 875 IN MAIN.asm
NEXTLINE:           043D DEFINED AT LINE 862 IN MAIN.asm
                    > USED AT LINE 835 IN MAIN.asm
                    > USED AT LINE 840 IN MAIN.asm
NEXTLINE1:          0442 DEFINED AT LINE 865 IN MAIN.asm
                    > USED AT LINE 871 IN MAIN.asm
NEXTLINE2:          044D DEFINED AT LINE 872 IN MAIN.asm
                    > USED AT LINE 870 IN MAIN.asm
REWINDCHAR:         0453 DEFINED AT LINE 894 IN MAIN.asm
                    > USED AT LINE 253 IN MAIN.asm
                    > USED AT LINE 271 IN MAIN.asm
                    > USED AT LINE 317 IN MAIN.asm
                    > USED AT LINE 441 IN MAIN.asm
                    > USED AT LINE 503 IN MAIN.asm
                    > USED AT LINE 644 IN MAIN.asm
                    > USED AT LINE 654 IN MAIN.asm
PROMPT:             045B DEFINED AT LINE 902 IN MAIN.asm
CRLF:               0464 DEFINED AT LINE 907 IN MAIN.asm
ERROR:              046B DEFINED AT LINE 912 IN MAIN.asm
PRINT:              0470 DEFINED AT LINE 917 IN MAIN.asm
                    > USED AT LINE 40 IN MAIN.asm
                    > USED AT LINE 94 IN MAIN.asm
                    > USED AT LINE 903 IN MAIN.asm
                    > USED AT LINE 908 IN MAIN.asm
PRINTSTR:           0475 DEFINED AT LINE 935 IN MAIN.asm
                    > USED AT LINE 914 IN MAIN.asm
                    > USED AT LINE 919 IN MAIN.asm
PRINTSTR1:          047A DEFINED AT LINE 941 IN MAIN.asm
                    > USED AT LINE 945 IN MAIN.asm
ROT_OPCODES:        0482 DEFINED AT LINE 2 IN data.asm
                    > USED AT LINE 368 IN MAIN.asm
ALU_OPCODES:        04A1 DEFINED AT LINE 14 IN data.asm
                    > USED AT LINE 364 IN MAIN.asm
GEN_OPCODES:        04C0 DEFINED AT LINE 26 IN data.asm
                    > USED AT LINE 373 IN MAIN.asm
REGISTERS:          059B DEFINED AT LINE 82 IN data.asm
                    > USED AT LINE 286 IN MAIN.asm
REG_PAIRS:          05B0 DEFINED AT LINE 96 IN data.asm
                    > USED AT LINE 279 IN MAIN.asm
FLAGS:              05CA DEFINED AT LINE 108 IN data.asm
                    > USED AT LINE 293 IN MAIN.asm
                    > USED AT LINE 300 IN MAIN.asm
DIRECTIVES:         05DF DEFINED AT LINE 120 IN data.asm
BUFFER:             0800 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 863 IN MAIN.asm
STACK:              0950 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 456 IN IOSerial.asm
                    > USED AT LINE 38 IN MAIN.asm
RST08:              0950 DEFINED AT LINE 9 IN ram.asm
                    > USED AT LINE 118 IN IOSerial.asm
                    > USED AT LINE 458 IN IOSerial.asm
RST10:              0952 DEFINED AT LINE 10 IN ram.asm
                    > USED AT LINE 124 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
RST18:              0954 DEFINED AT LINE 11 IN ram.asm
                    > USED AT LINE 130 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
RST20:              0956 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 136 IN IOSerial.asm
                    > USED AT LINE 461 IN IOSerial.asm
RST28:              0958 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RST30:              095A DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 148 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
BAUD:               095C DEFINED AT LINE 15 IN ram.asm
INTVEC:             095E DEFINED AT LINE 16 IN ram.asm
                    > USED AT LINE 154 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
NMIVEC:             0960 DEFINED AT LINE 17 IN ram.asm
                    > USED AT LINE 202 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
GETCVEC:            0962 DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 446 IN IOSerial.asm
                    > USED AT LINE 468 IN IOSerial.asm
PUTCVEC:            0964 DEFINED AT LINE 19 IN ram.asm
                    > USED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
VTEMP1:             0966 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 637 IN MAIN.asm
                    > USED AT LINE 647 IN MAIN.asm
                    > USED AT LINE 659 IN MAIN.asm
VTEMP2:             0968 DEFINED AT LINE 22 IN ram.asm
VBUFFERPOS:         096A DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 63 IN MAIN.asm
                    > USED AT LINE 832 IN MAIN.asm
                    > USED AT LINE 874 IN MAIN.asm
                    > USED AT LINE 895 IN MAIN.asm
VTOKEN:             096C DEFINED AT LINE 25 IN ram.asm
                    > USED AT LINE 62 IN MAIN.asm
                    > USED AT LINE 219 IN MAIN.asm
                    > USED AT LINE 221 IN MAIN.asm
                    > USED AT LINE 224 IN MAIN.asm
                    > USED AT LINE 398 IN MAIN.asm
VTOKENVAL:          096D DEFINED AT LINE 26 IN ram.asm
                    > USED AT LINE 68 IN MAIN.asm
                    > USED AT LINE 222 IN MAIN.asm
                    > USED AT LINE 399 IN MAIN.asm
VASMPTR:            096F DEFINED AT LINE 27 IN ram.asm
                    > USED AT LINE 65 IN MAIN.asm
VSTRPTR:            0971 DEFINED AT LINE 28 IN ram.asm
                    > USED AT LINE 67 IN MAIN.asm
                    > USED AT LINE 272 IN MAIN.asm
                    > USED AT LINE 425 IN MAIN.asm
                    > USED AT LINE 442 IN MAIN.asm
                    > USED AT LINE 470 IN MAIN.asm
                    > USED AT LINE 504 IN MAIN.asm
VSYMPTR:            0973 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 70 IN MAIN.asm
VEXPRPTR:           0975 DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 72 IN MAIN.asm
STRINGS:            0977 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 66 IN MAIN.asm
SYMBOLS:            0A77 DEFINED AT LINE 33 IN ram.asm
                    > USED AT LINE 69 IN MAIN.asm
EXPRS:              0B77 DEFINED AT LINE 34 IN ram.asm
                    > USED AT LINE 71 IN MAIN.asm
ASSEMBLY:           0C77 DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 64 IN MAIN.asm
