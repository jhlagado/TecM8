0000                          .ENGINE   mycomputer   
0000                             ; 
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                          IF   RC2014   
                                 ; Configuration for RC2014
                    ROMSTART:   EQU   $8000   
                    RAMSTART:   EQU   $8800   
                    LOADER:   EQU   0   
                    BITBANG:   EQU   0   
0000                          ENDIF      
0000                          IF   TEC_1   
0000                             ; Configuration for TEC-1
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $0800   
0000                ROMSIZE:   EQU   $0800   
0000                RAMSIZE:   EQU   $0800   
0000                             ;TEC-1D SC 8k rom/ram
0000                             ; ROMSTART .equ $0000
0000                             ; RAMSTART .equ $2000
0000                             ; ROMSIZE  .equ 8192
0000                             ; RAMSIZE  .equ 8192
0000                          ENDIF      
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8B 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 06 0A               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 08 0A               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 0A 0A               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A 0C 0A               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A 0E 0A               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A 10 0A               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A 14 0A               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A 16 0A               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   2A 18 0A               LD   HL,(GETCVEC)   
0084   E9                     JP   (HL)   
0085                             ; 
0085                PUTCHAR:      
0085   E5                     PUSH   HL   
0086   2A 1A 0A               LD   HL,(PUTCVEC)   
0089   E3                     EX   (SP),HL   
008A   C9                     RET      
008B                             ; 
008B                RESET:       
008B   31 00 0A               LD   SP,stack   
008E   21 5F 00               LD   HL,IntRet   
0091   22 06 0A               LD   (RST08),HL   
0094   22 08 0A               LD   (RST10),HL   
0097   22 0A 0A               LD   (RST18),HL   
009A   22 0C 0A               LD   (RST20),HL   
009D   22 0E 0A               LD   (RST28),HL   
00A0   22 10 0A               LD   (RST30),HL   
00A3   22 14 0A               LD   (INTVEC),HL   
00A6   22 16 0A               LD   (NMIVEC),HL   
00A9                             ; 
00A9   21 78 00               LD   HL,RXDATA   
00AC   22 18 0A               LD   (GETCVEC),HL   
00AF   21 6B 00               LD   HL,TXDATA   
00B2   22 1A 0A               LD   (PUTCVEC),HL   
00B5                             ; 
00B5                          IF   TEC_1   
00B5                          IF   BITBANG = 0   
00B5                             ; 
00B5   3E 03                  LD   a,MRESET   
00B7   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B9                             ; 
00B9                          ENDIF      
00B9                          ENDIF      
00B9                             ; 
00B9   CD 50 00               CALL   PWRUP   
00BC   ED 56                  IM   1   
00BE   FB                     EI      
00BF                             ; 
00BF                          IF   TEC_1   
00BF                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00BF                          ELSE      ;6850      
00BF                             ; 
00BF   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C1   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C3                             ; 
00C3                          ENDIF      
00C3                          ENDIF      
00C3                             ; 
00C3                             ; 
00C3                             ; 
00C3   C3 5F 02               JP   start   ; into #180 of the prog
00C6                             ; 
00C6                             ; *************************************************************************
00C6                             ; 
00C6                             ;       TecM8 1.0 Assembler for the Tec-1
00C6                             ; 
00C6                             ;       John Hardy
00C6                             ;       incorporates code by Ken Boak and Craig Jones
00C6                             ; 
00C6                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
00C6                             ; 
00C6                             ;       see the LICENSE file in this repo for more information
00C6                             ; 
00C6                             ; *****************************************************************************
00C6                             ; **************************************************************************
00C6                             ; Constants
00C6                             ; **************************************************************************
00C6                TRUE:     EQU   -1   
00C6                FALSE:    EQU   0   
00C6                CTRL_C:   EQU   3   
00C6                CTRL_H:   EQU   8   
00C6                             ; **************************************************************************
00C6                             ; Page 0  Initialisation
00C6                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put TecM8 code from here	
0180                OPCODES:      
0180   02                     DB   lsb(bang_)   ;   !
0181   00                     DB   lsb(dquote_)   ;   "
0182   00                     DB   lsb(hash_)   ;   #
0183   00                     DB   lsb(dollar_)   ;   $
0184   00                     DB   lsb(percent_)   ;   %
0185   00                     DB   lsb(amper_)   ;   &
0186   00                     DB   lsb(quote_)   ;   '
0187   00                     DB   lsb(lparen_)   ;   (
0188   00                     DB   lsb(rparen_)   ;   )
0189   00                     DB   lsb(star_)   ;   *
018A   12                     DB   lsb(plus_)   ;   +
018B   00                     DB   lsb(comma_)   ;   ,
018C   00                     DB   lsb(minus_)   ;   -
018D   20                     DB   lsb(dot_)   ;   .
018E   00                     DB   lsb(slash_)   ;   /	
018F   3C                     DB   lsb(colon_)   ;    :
0190   2B                     DB   lsb(semi_)   ;    ;
0191   00                     DB   lsb(lt_)   ;    <
0192   00                     DB   lsb(eq_)   ;    =
0193   00                     DB   lsb(gt_)   ;    >
0194   00                     DB   lsb(question_)   ;    ?
0195   00                     DB   lsb(at_)   ;    @
0196   00                     DB   lsb(lbrack_)   ;    [
0197   00                     DB   lsb(bslash_)   ;    \
0198   00                     DB   lsb(rbrack_)   ;    ]
0199   00                     DB   lsb(caret_)   ;    ^
019A   00                     DB   lsb(underscore_)   ;    _
019B   00                     DB   lsb(grave_)   ;    `
019C   00                     DB   lsb(lbrace_)   ;    {
019D   00                     DB   lsb(pipe_)   ;    |
019E   00                     DB   lsb(rbrace_)   ;    }
019F   00                     DB   lsb(tilde_)   ;    ~
01A0                          ALIGN   $100   
0200                NOP_:        
0200                BSLASH_:      
0200                QUOTE_:      ; Discard the top member of the stack
0200                AT_:         
0200                UNDERSCORE_:      
0200                PERCENT_:      
0200                AMPER_:      
0200                PIPE_:       
0200                CARET_:      
0200                TILDE_:      
0200                INVERT:      ; Bitwise INVert the top member of the stack
0200                DQUOTE_:      
0200                COMMA_:      ; print hexadecimal
0200                LBRACE_:      
0200                RBRACE_:      
0200                DOLLAR_:      
0200                MINUS_:      ; Subtract the value 2nd on stack from top of stack
0200                EQ_:         
0200                GT_:         
0200                LT_:         
0200                GRAVE_:      
0200                RPAREN_:      
0200                LBRACK_:      
0200                RBRACK_:      
0200                LPAREN_:      
0200                SLASH_:      
0200                QUESTION_:      
0200                HASH_:       
0200                STAR_:       
0200   FD E9                  JP   (iy)   
0202                BANG_:       ; Store the value at the address placed on the top of the stack
0202                ASSIGN:      
0202   E1                     POP   hl   ; discard value of last accessed variable
0203   D1                     POP   de   ; new value
0204   2A 9E 0B               LD   hl,(vPointer)   
0207   73                     LD   (hl),e   
0208   3A 6A 0B               LD   a,(vByteMode)   
020B   3C                     INC   a   ; is it byte?
020C   28 02                  JR   z,assign1   
020E   23                     INC   hl   
020F   72                     LD   (hl),d   
0210                ASSIGN1:      
0210   FD E9                  JP   (iy)   
0212                PLUS_:       ; add the top 2 members of the stack
0212   D1                     POP   de   
0213   E1                     POP   hl   
0214   19                     ADD   hl,de   
0215   E5                     PUSH   hl   
0216   21 00 00               LD   hl,0   
0219   CB 15                  RL   l   
021B   22 6C 0B               LD   (vCarry),hl   
021E   FD E9                  JP   (iy)   
0220                DOT_:        
0220   E1                     POP   hl   
0221   CD 20 04               CALL   printDec   
0224                DOT2:        
0224   3E 20                  LD   a," "   
0226   CD 85 00               CALL   putChar   
0229   FD E9                  JP   (iy)   
022B                SEMI_:       
022B   DD 2A 9C 0B            LD   ix,(vBasePtr)   ; 
022F   CD 02 04               CALL   rpop   ; Restore old base pointer
0232   22 9C 0B               LD   (vBasePtr),hl   
0235   CD 02 04               CALL   rpop   ; Restore Instruction pointer
0238   44 4D                  LD   bc,hl   
023A   FD E9                  JP   (iy)   
023C                COLON_:      
023C   C3 68 04               JP   def   
023F                INIT:        
023F   DD 21 80 09            LD   ix,RSTACK   
0243   DD 22 9C 0B            LD   (vBasePtr),ix   
0247   FD 21 DE 02            LD   iy,next   ; iy provides a faster jump to next
024B   21 00 0B               LD   hl,vars   
024E   54 5D                  LD   de,hl   
0250   13                     INC   de   
0251   36 00                  LD   (hl),0   
0253   01 9C 00               LD   bc,VARS_SIZE * 3   ; init vars, defs and altVars
0256   ED B0                  LDIR      
0258   21 A0 0B               LD   hl,HEAP   
025B   22 76 0B               LD   (vHeapPtr),hl   
025E   C9                     RET      
025F                START:       ; start of TecM8
025F   31 00 0A               LD   sp,DSTACK   
0262   CD 3F 02               CALL   init   
0265   CD E7 03               CALL   printStr   ; prog count to stack, put code line 235 on stack then call print
0268   54 65 63 4D 38 20 30 2E 30 0D 0A 00 .CSTR   "TecM8 0.0\r\n"   
0274                INTERPRET:      
0274   CD D7 03               CALL   prompt   
0277   01 00 00               LD   bc,0   ; load bc with offset into TIB, decide char into tib or execute or control
027A   ED 43 7C 0B            LD   (vTIBPtr),bc   
027E                INTERPRET2:      ; calc nesting
027E   1E 00                  LD   E,0   ; initilize nesting value
0280   C5                     PUSH   bc   ; save offset into TIB,
0281                             ; bc is also the count of chars in TIB
0281   21 00 08               LD   hl,TIB   ; hl is start of TIB
0284   18 06                  JR   interpret4   
0286                INTERPRET3:      
0286   7E                     LD   a,(hl)   ; A = char in TIB
0287   23                     INC   hl   ; inc pointer into TIB
0288   0B                     DEC   bc   ; dec count of chars in TIB
0289   CD B0 03               CALL   nesting   ; update nesting value
028C                INTERPRET4:      
028C   79                     LD   a,C   ; is count zero?
028D   B0                     OR   B   
028E   20 F6                  JR   NZ,interpret3   ; if not loop
0290   C1                     POP   bc   ; restore offset into TIB
0291                INTERPRET5:      
0291   CD 81 00               CALL   getchar   ; loop around waiting for character from serial port
0294   FE 20                  CP   $20   ; compare to space
0296   30 1A                  JR   NC,interpret6   ; if >= space, if below 20 set cary flag
0298   FE 00                  CP   $0   ; is it end of string? null end of string
029A   28 3A                  JR   Z,interpret8   
029C   FE 0D                  CP   "\r"   ; carriage return? ascii 13
029E   28 20                  JR   Z,interpret7   ; if anything else its control char
02A0   FE 08                  CP   CTRL_H   
02A2   20 DA                  JR   nz,interpret2   
02A4                BACKSPACE:      
02A4   79                     LD   a,c   
02A5   B0                     OR   b   
02A6   28 D6                  JR   z,interpret2   
02A8   0B                     DEC   bc   
02A9   CD E7 03               CALL   printStr   
02AC   08 20 08 00            .CSTR   "\b \b"   
02B0   18 CC                  JR   interpret2   
02B2                INTERPRET6:      
02B2   21 00 08               LD   hl,TIB   
02B5   09                     ADD   hl,bc   
02B6   77                     LD   (hl),A   ; store the character in textbuf
02B7   03                     INC   bc   
02B8   CD 85 00               CALL   putchar   ; echo character to screen
02BB   CD B0 03               CALL   nesting   
02BE   18 D1                  JR   interpret5   ; wait for next character
02C0                INTERPRET7:      
02C0   21 00 08               LD   hl,TIB   
02C3   09                     ADD   hl,bc   
02C4   36 0D                  LD   (hl),"\r"   ; store the crlf in textbuf
02C6   23                     INC   hl   
02C7   36 0A                  LD   (hl),"\n"   
02C9   23                     INC   hl   ; ????
02CA   03                     INC   bc   
02CB   03                     INC   bc   
02CC   CD E0 03               CALL   crlf   ; echo character to screen
02CF   7B                     LD   a,E   ; if zero nesting append and ETX after \r
02D0   B7                     OR   A   
02D1   20 BE                  JR   NZ,interpret5   
02D3   36 03                  LD   (hl),$03   ; store end of text ETX in text buffer
02D5   03                     INC   bc   
02D6                INTERPRET8:      
02D6   ED 43 7C 0B            LD   (vTIBPtr),bc   
02DA   01 00 08               LD   bc,TIB   ; Instructions stored on heap at address HERE, we pressed enter
02DD   0B                     DEC   bc   
02DE                NEXT:        
02DE   03                     INC   bc   ; Increment the IP
02DF   0A                     LD   a,(bc)   ; Get the next character and dispatch
02E0   B7                     OR   a   ; is it NUL?
02E1   28 30                  JR   z,exit   
02E3   FE 03                  CP   CTRL_C   
02E5   28 40                  JR   z,etx   
02E7   FE 30                  CP   "0"   
02E9   16 21                  LD   d,"!"   
02EB   38 1B                  JR   c,op   
02ED   FE 3A                  CP   "9"+1   
02EF   38 42                  JR   c,num   
02F1   FE 41                  CP   "A"   
02F3   16 2B                  LD   d,"!"+10   
02F5   38 11                  JR   c,op   
02F7   FE 5B                  CP   "Z"+1   
02F9   38 67                  JR   c,callx   
02FB   FE 61                  CP   "a"   
02FD   16 45                  LD   d,"!"+10+26   
02FF   38 07                  JR   c,op   
0301   FE 7B                  CP   "z"+1   
0303   DA 86 03               JP   c,var   
0306   16 5F                  LD   d,"!"+10+26+26   
0308                OP:          
0308   92                     SUB   d   
0309   38 D3                  JR   c,next   
030B   C6 80                  ADD   a,lsb(opcodes)   
030D   6F                     LD   l,A   ; Index into table
030E   26 01                  LD   h,msb(opcodes)   ; Start address of jump table
0310   6E                     LD   l,(hl)   ; get low jump address
0311   24                     INC   h   ; msb on next page
0312   E9                     JP   (hl)   ; Jump to routine
0313                EXIT:        
0313   03                     INC   bc   ; store offests into a table of bytes, smaller
0314   50 59                  LD   de,bc   
0316   DD 2A 9C 0B            LD   ix,(vBasePtr)   ; 
031A   CD 02 04               CALL   rpop   ; Restore old base pointer
031D   22 9C 0B               LD   (vBasePtr),hl   
0320   CD 02 04               CALL   rpop   ; Restore Instruction pointer
0323   44 4D                  LD   bc,hl   
0325   EB                     EX   de,hl   
0326   E9                     JP   (hl)   
0327                ETX:         
0327   21 00 F6               LD   hl,-DSTACK   ; check if stack pointer is underwater
032A   39                     ADD   hl,sp   
032B   30 03                  JR   NC,etx1   
032D   31 00 0A               LD   sp,DSTACK   
0330                ETX1:        
0330   C3 74 02               JP   interpret   
0333                NUM:         
0333   21 00 00               LD   hl,$0000   ; Clear hl to accept the number
0336   FE 2D                  CP   "-"   
0338   20 01                  JR   nz,num0   
033A   03                     INC   bc   ; move to next char, no flags affected
033B                NUM0:        
033B   08                     EX   af,af'   ; save zero flag = 0 for later
033C                NUM1:        
033C   0A                     LD   a,(bc)   ; read digit
033D   D6 30                  SUB   "0"   ; less than 0?
033F   38 13                  JR   c,num2   ; not a digit, exit loop
0341   FE 0A                  CP   10   ; greater that 9?
0343   30 0F                  JR   nc,num2   ; not a digit, exit loop
0345   03                     INC   bc   ; inc IP
0346   54 5D                  LD   de,hl   ; multiply hl * 10
0348   29                     ADD   hl,hl   
0349   29                     ADD   hl,hl   
034A   19                     ADD   hl,de   
034B   29                     ADD   hl,hl   
034C   85                     ADD   a,l   ; add digit in a to hl
034D   6F                     LD   l,a   
034E   3E 00                  LD   a,0   
0350   8C                     ADC   a,h   
0351   67                     LD   h,a   
0352   18 E8                  JR   num1   
0354                NUM2:        
0354   0B                     DEC   bc   
0355   08                     EX   af,af'   ; restore zero flag
0356   20 07                  JR   nz,num3   
0358   EB                     EX   de,hl   ; negate the value of hl
0359   21 00 00               LD   hl,0   
035C   B7                     OR   a   ; jump to sub2
035D   ED 52                  SBC   hl,de   
035F                NUM3:        
035F   E5                     PUSH   hl   ; Put the number on the stack
0360   FD E9                  JP   (iy)   ; and process the next character
0362                CALLX:       
0362   CD 9D 03               CALL   lookupRef0   
0365   5E                     LD   E,(hl)   
0366   23                     INC   hl   
0367   56                     LD   D,(hl)   
0368   7A                     LD   a,D   ; skip if destination address is null
0369   B3                     OR   E   
036A   28 18                  JR   Z,call2   
036C   60 69                  LD   hl,bc   
036E   03                     INC   bc   ; read next char from source
036F   0A                     LD   a,(bc)   ; if ; to tail call optimise
0370   FE 3B                  CP   ";"   ; by jumping to rather than calling destination
0372   28 0D                  JR   Z,call1   
0374   CD F7 03               CALL   rpush   ; save Instruction Pointer
0377   2A 9C 0B               LD   hl,(vBasePtr)   
037A   CD F7 03               CALL   rpush   
037D   DD 22 9C 0B            LD   (vBasePtr),ix   
0381                CALL1:       
0381   42 4B                  LD   bc,de   
0383   0B                     DEC   bc   
0384                CALL2:       
0384   FD E9                  JP   (iy)   
0386                VAR:         
0386   21 00 0B               LD   hl,vars   
0389   CD A4 03               CALL   lookupRef   
038C                VAR1:        
038C   22 9E 0B               LD   (vPointer),hl   
038F   16 00                  LD   d,0   
0391   5E                     LD   e,(hl)   
0392   3A 6A 0B               LD   a,(vByteMode)   
0395   3C                     INC   a   ; is it byte?
0396   28 02                  JR   z,var2   
0398   23                     INC   hl   
0399   56                     LD   d,(hl)   
039A                VAR2:        
039A   D5                     PUSH   de   
039B   FD E9                  JP   (iy)   
039D                LOOKUPREF0:      
039D   21 34 0B               LD   hl,defs   
03A0   D6 41                  SUB   "A"   
03A2   18 02                  JR   lookupRef1   
03A4                LOOKUPREF:      
03A4   D6 61                  SUB   "a"   
03A6                LOOKUPREF1:      
03A6   87                     ADD   a,a   
03A7   85                     ADD   a,l   
03A8   6F                     LD   l,a   
03A9   3E 00                  LD   a,0   
03AB   8C                     ADC   a,h   
03AC   67                     LD   h,a   
03AD   AF                     XOR   a   
03AE   B3                     OR   e   ; sets Z flag if A-Z
03AF   C9                     RET      
03B0                             ; **************************************************************************
03B0                             ; calculate nesting value
03B0                             ; A is char to be tested,
03B0                             ; E is the nesting value (initially 0)
03B0                             ; E is increased by ( and [
03B0                             ; E is decreased by ) and ]
03B0                             ; E has its bit 7 toggled by `
03B0                             ; limited to 127 levels
03B0                             ; **************************************************************************
03B0                NESTING:      
03B0   FE 60                  CP   "`"   
03B2   20 05                  JR   NZ,nesting1   
03B4   3E 80                  LD   a,$80   
03B6   AB                     XOR   e   
03B7   5F                     LD   e,a   
03B8   C9                     RET      
03B9                NESTING1:      
03B9   CB 7B                  BIT   7,E   
03BB   C0                     RET   NZ   
03BC   FE 3A                  CP   ":"   
03BE   28 08                  JR   Z,nesting2   
03C0   FE 5B                  CP   "["   
03C2   28 04                  JR   Z,nesting2   
03C4   FE 28                  CP   "("   
03C6   20 02                  JR   NZ,nesting3   
03C8                NESTING2:      
03C8   1C                     INC   E   
03C9   C9                     RET      
03CA                NESTING3:      
03CA   FE 3B                  CP   ";"   
03CC   28 07                  JR   Z,nesting4   
03CE   FE 5D                  CP   "]"   
03D0   28 03                  JR   Z,nesting4   
03D2   FE 29                  CP   ")"   
03D4   C0                     RET   NZ   
03D5                NESTING4:      
03D5   1D                     DEC   E   
03D6   C9                     RET      
03D7                PROMPT:      
03D7   CD E7 03               CALL   printStr   
03DA   0D 0A 3E 20 00         .CSTR   "\r\n> "   
03DF   C9                     RET      
03E0                CRLF:        
03E0   CD E7 03               CALL   printStr   
03E3   0D 0A 00               .CSTR   "\r\n"   
03E6   C9                     RET      
03E7                PRINTSTR:      
03E7   E3                     EX   (sp),hl   ; swap			
03E8   CD F2 03               CALL   putStr   
03EB   23                     INC   hl   ; inc past null
03EC   E3                     EX   (sp),hl   ; put it back	
03ED   C9                     RET      
03EE                PUTSTR0:      
03EE   CD 85 00               CALL   putchar   
03F1   23                     INC   hl   
03F2                PUTSTR:      
03F2   7E                     LD   a,(hl)   
03F3   B7                     OR   A   
03F4   20 F8                  JR   NZ,putStr0   
03F6   C9                     RET      
03F7                RPUSH:       
03F7   DD 2B                  DEC   ix   
03F9   DD 74 00               LD   (ix+0),H   
03FC   DD 2B                  DEC   ix   
03FE   DD 75 00               LD   (ix+0),L   
0401   C9                     RET      
0402                RPOP:        
0402   DD 6E 00               LD   L,(ix+0)   
0405   DD 23                  INC   ix   
0407   DD 66 00               LD   H,(ix+0)   
040A   DD 23                  INC   ix   
040C                RPOP2:       
040C   C9                     RET      
040D                ENTER:       
040D   60 69                  LD   hl,bc   
040F   CD F7 03               CALL   rpush   ; save Instruction Pointer
0412   2A 9C 0B               LD   hl,(vBasePtr)   
0415   CD F7 03               CALL   rpush   
0418   DD 22 9C 0B            LD   (vBasePtr),ix   
041C   C1                     POP   bc   
041D   0B                     DEC   bc   
041E   FD E9                  JP   (iy)   
0420                             ; hl = value
0420                PRINTDEC:      
0420   CB 7C                  BIT   7,h   
0422   28 0B                  JR   z,printDec2   
0424   3E 2D                  LD   a,"-"   
0426   CD 85 00               CALL   putchar   
0429   AF                     XOR   a   
042A   95                     SUB   l   
042B   6F                     LD   l,a   
042C   9F                     SBC   a,a   
042D   94                     SUB   h   
042E   67                     LD   h,a   
042F                PRINTDEC2:      
042F   C5                     PUSH   bc   
0430   0E 00                  LD   c,0   ; leading zeros flag = false
0432   11 F0 D8               LD   de,-10000   
0435   CD 51 04               CALL   printDec4   
0438   11 18 FC               LD   de,-1000   
043B   CD 51 04               CALL   printDec4   
043E   11 9C FF               LD   de,-100   
0441   CD 51 04               CALL   printDec4   
0444   1E F6                  LD   e,-10   
0446   CD 51 04               CALL   printDec4   
0449   0C                     INC   c   ; flag = true for at least digit
044A   1E FF                  LD   e,-1   
044C   CD 51 04               CALL   printDec4   
044F   C1                     POP   bc   
0450   C9                     RET      
0451                PRINTDEC4:      
0451   06 2F                  LD   b,"0"-1   
0453                PRINTDEC5:      
0453   04                     INC   b   
0454   19                     ADD   hl,de   
0455   38 FC                  JR   c,printDec5   
0457   ED 52                  SBC   hl,de   
0459   3E 30                  LD   a,"0"   
045B   B8                     CP   b   
045C   20 05                  JR   nz,printDec6   
045E   AF                     XOR   a   
045F   B1                     OR   c   
0460   C8                     RET   z   
0461   18 01                  JR   printDec7   
0463                PRINTDEC6:      
0463   0C                     INC   c   
0464                PRINTDEC7:      
0464   78                     LD   a,b   
0465   C3 85 00               JP   putchar   
0468                DEF:         ; Create a colon definition
0468   03                     INC   bc   
0469   0A                     LD   a,(bc)   ; Get the next character
046A   FE 3A                  CP   ":"   ; is it anonymouse
046C   20 08                  JR   nz,def0   
046E   03                     INC   bc   
046F   ED 5B 76 0B            LD   de,(vHeapPtr)   ; return start of definition
0473   D5                     PUSH   de   
0474   18 0B                  JR   def1   
0476                DEF0:        
0476   CD 9D 03               CALL   lookupRef0   
0479   ED 5B 76 0B            LD   de,(vHeapPtr)   ; start of defintion
047D   73                     LD   (hl),E   ; Save low byte of address in CFA
047E   23                     INC   hl   
047F   72                     LD   (hl),D   ; Save high byte of address in CFA+1
0480   03                     INC   bc   
0481                DEF1:        ; Skip to end of definition
0481   0A                     LD   a,(bc)   ; Get the next character
0482   03                     INC   bc   ; Point to next character
0483   12                     LD   (de),A   
0484   13                     INC   de   
0485   FE 3B                  CP   ";"   ; Is it a semicolon
0487   28 02                  JR   Z,def2   ; end the definition
0489   18 F6                  JR   def1   ; get the next element
048B                DEF2:        
048B   0B                     DEC   bc   
048C                DEF3:        
048C   ED 53 76 0B            LD   (vHeapPtr),de   ; bump heap ptr to after definiton
0490   FD E9                  JP   (iy)   
0492                             ; *******************************************************************************
0492                             ; *********  END OF MAIN   ******************************************************
0492                             ; *******************************************************************************
0492                DSIZE:    EQU   $80   
0492                RSIZE:    EQU   $80   
0492                TIBSIZE:   EQU   $100   ; 256 bytes , along line!
0492                VARS_SIZE:   EQU   26*2   
0800                          .ORG   RAMSTART   
0800                TIB:      DS   TIBSIZE   
0900                          DS   RSIZE   
0980                RSTACK:      
0980                          DS   DSIZE   
0A00                DSTACK:      
0A00                STACK:       
0A00                TBPTR:    DS   2   ; reserved for tests
0A02                VTEMP1:   DS   2   ; 
0A04                VTEMP2:   DS   2   ; 
0A06                RST08:    DS   2   
0A08                RST10:    DS   2   
0A0A                RST18:    DS   2   
0A0C                RST20:    DS   2   
0A0E                RST28:    DS   2   
0A10                RST30:    DS   2   ; 
0A12                BAUD:     DS   2   ; 
0A14                INTVEC:   DS   2   ; 
0A16                NMIVEC:   DS   2   ; 
0A18                GETCVEC:   DS   2   ; 
0A1A                PUTCVEC:   DS   2   ; 
0A1C                          ALIGN   $100   
0B00                VARS:     DS   VARS_SIZE   
0B34                DEFS:     DS   VARS_SIZE   
0B68                ALTVARS:      
0B68                          DS   2   ; a
0B6A                VBYTEMODE:   DS   2   ; b
0B6C                VCARRY:   DS   2   ; c carry variable
0B6E                          DS   2   ; d
0B70                          DS   2   ; e
0B72                          DS   2   ; f
0B74                          DS   2   ; g
0B76                VHEAPPTR:   DS   2   ; h heap pointer variable
0B78                          DS   2   ; i loop variable
0B7A                          DS   2   ; j outer loop variable
0B7C                VTIBPTR:   DS   2   ; k address of text input buffer
0B7E                          DS   2   ; l
0B80                          DS   2   ; m
0B82                          DS   2   ; n
0B84                          DS   2   ; o
0B86                          DS   2   ; p
0B88                          DS   2   ; q
0B8A                VREMAIN:   DS   2   ; r remainder of last division
0B8C                          DS   2   ; s address of start of stack
0B8E                          DS   2   ; t
0B90                          DS   2   ; u
0B92                          DS   2   ; v
0B94                          DS   2   ; w
0B96                          DS   2   ; x
0B98                          DS   2   ; y
0B9A                          DS   2   ; z name of last defined function
0B9C                VBASEPTR:   DS   2   
0B9E                VPOINTER:   DS   2   
0BA0                HEAP:        


TEC_1:              0001 DEFINED AT LINE 1 IN constants.asm
RC2014:             0000 DEFINED AT LINE 2 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 4 IN constants.asm
LOADER:             0000 DEFINED AT LINE 20 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 21 IN constants.asm
ROMSTART:           0000 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 100 IN IOSerial.asm
                    > USED AT LINE 105 IN IOSerial.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 117 IN IOSerial.asm
                    > USED AT LINE 123 IN IOSerial.asm
                    > USED AT LINE 129 IN IOSerial.asm
                    > USED AT LINE 135 IN IOSerial.asm
                    > USED AT LINE 141 IN IOSerial.asm
                    > USED AT LINE 147 IN IOSerial.asm
                    > USED AT LINE 189 IN IOSerial.asm
                    > USED AT LINE 27 IN MAIN.asm
RAMSTART:           0800 DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 6 IN ram.asm
ROMSIZE:            0800 DEFINED AT LINE 25 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 26 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 22 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
                    > USED AT LINE 487 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 23 IN IOSerial.asm
                    > USED AT LINE 298 IN IOSerial.asm
                    > USED AT LINE 311 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 24 IN IOSerial.asm
                    > USED AT LINE 303 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 25 IN IOSerial.asm
                    > USED AT LINE 315 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 32 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 39 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 40 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 41 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 42 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 44 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 45 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 46 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 50 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 51 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 52 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 53 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 57 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 61 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 62 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 63 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 64 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 65 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 66 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 67 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 68 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 76 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 77 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 78 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 79 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 80 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 81 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 82 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 83 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 96 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 97 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 98 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 102 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 152 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 174 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 176 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 180 IN IOSerial.asm
                    > USED AT LINE 182 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 446 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 293 IN IOSerial.asm
                    > USED AT LINE 458 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 294 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 297 IN IOSerial.asm
                    > USED AT LINE 301 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 456 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 310 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 434 IN IOSerial.asm
                    > USED AT LINE 193 IN MAIN.asm
PUTCHAR:            0085 DEFINED AT LINE 438 IN IOSerial.asm
                    > USED AT LINE 128 IN MAIN.asm
                    > USED AT LINE 217 IN MAIN.asm
                    > USED AT LINE 445 IN MAIN.asm
                    > USED AT LINE 483 IN MAIN.asm
                    > USED AT LINE 524 IN MAIN.asm
RESET:              008B DEFINED AT LINE 444 IN IOSerial.asm
                    > USED AT LINE 103 IN IOSerial.asm
TRUE:               00-1 DEFINED AT LINE 18 IN MAIN.asm
FALSE:              0000 DEFINED AT LINE 19 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 20 IN MAIN.asm
                    > USED AT LINE 247 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 21 IN MAIN.asm
                    > USED AT LINE 200 IN MAIN.asm
OPCODES:            0180 DEFINED AT LINE 29 IN MAIN.asm
NOP_:               0200 DEFINED AT LINE 68 IN MAIN.asm
BSLASH_:            0200 DEFINED AT LINE 69 IN MAIN.asm
QUOTE_:             0200 DEFINED AT LINE 70 IN MAIN.asm
AT_:                0200 DEFINED AT LINE 71 IN MAIN.asm
UNDERSCORE_:        0200 DEFINED AT LINE 72 IN MAIN.asm
PERCENT_:           0200 DEFINED AT LINE 73 IN MAIN.asm
AMPER_:             0200 DEFINED AT LINE 74 IN MAIN.asm
PIPE_:              0200 DEFINED AT LINE 75 IN MAIN.asm
CARET_:             0200 DEFINED AT LINE 76 IN MAIN.asm
TILDE_:             0200 DEFINED AT LINE 77 IN MAIN.asm
INVERT:             0200 DEFINED AT LINE 78 IN MAIN.asm
DQUOTE_:            0200 DEFINED AT LINE 79 IN MAIN.asm
COMMA_:             0200 DEFINED AT LINE 80 IN MAIN.asm
LBRACE_:            0200 DEFINED AT LINE 81 IN MAIN.asm
RBRACE_:            0200 DEFINED AT LINE 82 IN MAIN.asm
DOLLAR_:            0200 DEFINED AT LINE 83 IN MAIN.asm
MINUS_:             0200 DEFINED AT LINE 84 IN MAIN.asm
EQ_:                0200 DEFINED AT LINE 85 IN MAIN.asm
GT_:                0200 DEFINED AT LINE 86 IN MAIN.asm
LT_:                0200 DEFINED AT LINE 87 IN MAIN.asm
GRAVE_:             0200 DEFINED AT LINE 88 IN MAIN.asm
RPAREN_:            0200 DEFINED AT LINE 89 IN MAIN.asm
LBRACK_:            0200 DEFINED AT LINE 90 IN MAIN.asm
RBRACK_:            0200 DEFINED AT LINE 91 IN MAIN.asm
LPAREN_:            0200 DEFINED AT LINE 92 IN MAIN.asm
SLASH_:             0200 DEFINED AT LINE 93 IN MAIN.asm
QUESTION_:          0200 DEFINED AT LINE 94 IN MAIN.asm
HASH_:              0200 DEFINED AT LINE 95 IN MAIN.asm
STAR_:              0200 DEFINED AT LINE 96 IN MAIN.asm
BANG_:              0202 DEFINED AT LINE 99 IN MAIN.asm
ASSIGN:             0202 DEFINED AT LINE 100 IN MAIN.asm
ASSIGN1:            0210 DEFINED AT LINE 110 IN MAIN.asm
                    > USED AT LINE 107 IN MAIN.asm
PLUS_:              0212 DEFINED AT LINE 113 IN MAIN.asm
DOT_:               0220 DEFINED AT LINE 123 IN MAIN.asm
DOT2:               0224 DEFINED AT LINE 126 IN MAIN.asm
SEMI_:              022B DEFINED AT LINE 131 IN MAIN.asm
COLON_:             023C DEFINED AT LINE 139 IN MAIN.asm
INIT:               023F DEFINED AT LINE 144 IN MAIN.asm
                    > USED AT LINE 162 IN MAIN.asm
START:              025F DEFINED AT LINE 160 IN MAIN.asm
                    > USED AT LINE 6
INTERPRET:          0274 DEFINED AT LINE 167 IN MAIN.asm
                    > USED AT LINE 292 IN MAIN.asm
INTERPRET2:         027E DEFINED AT LINE 173 IN MAIN.asm
                    > USED AT LINE 201 IN MAIN.asm
                    > USED AT LINE 206 IN MAIN.asm
                    > USED AT LINE 210 IN MAIN.asm
INTERPRET3:         0286 DEFINED AT LINE 180 IN MAIN.asm
                    > USED AT LINE 189 IN MAIN.asm
INTERPRET4:         028C DEFINED AT LINE 186 IN MAIN.asm
                    > USED AT LINE 178 IN MAIN.asm
INTERPRET5:         0291 DEFINED AT LINE 192 IN MAIN.asm
                    > USED AT LINE 219 IN MAIN.asm
                    > USED AT LINE 233 IN MAIN.asm
BACKSPACE:          02A4 DEFINED AT LINE 203 IN MAIN.asm
INTERPRET6:         02B2 DEFINED AT LINE 212 IN MAIN.asm
                    > USED AT LINE 195 IN MAIN.asm
INTERPRET7:         02C0 DEFINED AT LINE 221 IN MAIN.asm
                    > USED AT LINE 199 IN MAIN.asm
INTERPRET8:         02D6 DEFINED AT LINE 237 IN MAIN.asm
                    > USED AT LINE 197 IN MAIN.asm
NEXT:               02DE DEFINED AT LINE 242 IN MAIN.asm
                    > USED AT LINE 147 IN MAIN.asm
                    > USED AT LINE 267 IN MAIN.asm
OP:                 0308 DEFINED AT LINE 265 IN MAIN.asm
                    > USED AT LINE 251 IN MAIN.asm
                    > USED AT LINE 256 IN MAIN.asm
                    > USED AT LINE 261 IN MAIN.asm
EXIT:               0313 DEFINED AT LINE 275 IN MAIN.asm
                    > USED AT LINE 246 IN MAIN.asm
ETX:                0327 DEFINED AT LINE 286 IN MAIN.asm
                    > USED AT LINE 248 IN MAIN.asm
ETX1:               0330 DEFINED AT LINE 291 IN MAIN.asm
                    > USED AT LINE 289 IN MAIN.asm
NUM:                0333 DEFINED AT LINE 294 IN MAIN.asm
                    > USED AT LINE 253 IN MAIN.asm
NUM0:               033B DEFINED AT LINE 299 IN MAIN.asm
                    > USED AT LINE 297 IN MAIN.asm
NUM1:               033C DEFINED AT LINE 301 IN MAIN.asm
                    > USED AT LINE 318 IN MAIN.asm
NUM2:               0354 DEFINED AT LINE 319 IN MAIN.asm
                    > USED AT LINE 304 IN MAIN.asm
                    > USED AT LINE 306 IN MAIN.asm
NUM3:               035F DEFINED AT LINE 327 IN MAIN.asm
                    > USED AT LINE 322 IN MAIN.asm
CALLX:              0362 DEFINED AT LINE 331 IN MAIN.asm
                    > USED AT LINE 258 IN MAIN.asm
CALL1:              0381 DEFINED AT LINE 348 IN MAIN.asm
                    > USED AT LINE 343 IN MAIN.asm
CALL2:              0384 DEFINED AT LINE 351 IN MAIN.asm
                    > USED AT LINE 338 IN MAIN.asm
VAR:                0386 DEFINED AT LINE 354 IN MAIN.asm
                    > USED AT LINE 263 IN MAIN.asm
VAR1:               038C DEFINED AT LINE 357 IN MAIN.asm
VAR2:               039A DEFINED AT LINE 366 IN MAIN.asm
                    > USED AT LINE 363 IN MAIN.asm
LOOKUPREF0:         039D DEFINED AT LINE 370 IN MAIN.asm
                    > USED AT LINE 332 IN MAIN.asm
                    > USED AT LINE 536 IN MAIN.asm
LOOKUPREF:          03A4 DEFINED AT LINE 374 IN MAIN.asm
                    > USED AT LINE 356 IN MAIN.asm
LOOKUPREF1:         03A6 DEFINED AT LINE 376 IN MAIN.asm
                    > USED AT LINE 373 IN MAIN.asm
NESTING:            03B0 DEFINED AT LINE 397 IN MAIN.asm
                    > USED AT LINE 184 IN MAIN.asm
                    > USED AT LINE 218 IN MAIN.asm
NESTING1:           03B9 DEFINED AT LINE 404 IN MAIN.asm
                    > USED AT LINE 399 IN MAIN.asm
NESTING2:           03C8 DEFINED AT LINE 413 IN MAIN.asm
                    > USED AT LINE 408 IN MAIN.asm
                    > USED AT LINE 410 IN MAIN.asm
NESTING3:           03CA DEFINED AT LINE 416 IN MAIN.asm
                    > USED AT LINE 412 IN MAIN.asm
NESTING4:           03D5 DEFINED AT LINE 423 IN MAIN.asm
                    > USED AT LINE 418 IN MAIN.asm
                    > USED AT LINE 420 IN MAIN.asm
PROMPT:             03D7 DEFINED AT LINE 427 IN MAIN.asm
                    > USED AT LINE 168 IN MAIN.asm
CRLF:               03E0 DEFINED AT LINE 432 IN MAIN.asm
                    > USED AT LINE 230 IN MAIN.asm
PRINTSTR:           03E7 DEFINED AT LINE 437 IN MAIN.asm
                    > USED AT LINE 164 IN MAIN.asm
                    > USED AT LINE 208 IN MAIN.asm
                    > USED AT LINE 428 IN MAIN.asm
                    > USED AT LINE 433 IN MAIN.asm
PUTSTR0:            03EE DEFINED AT LINE 444 IN MAIN.asm
                    > USED AT LINE 450 IN MAIN.asm
PUTSTR:             03F2 DEFINED AT LINE 447 IN MAIN.asm
                    > USED AT LINE 439 IN MAIN.asm
RPUSH:              03F7 DEFINED AT LINE 453 IN MAIN.asm
                    > USED AT LINE 344 IN MAIN.asm
                    > USED AT LINE 346 IN MAIN.asm
                    > USED AT LINE 470 IN MAIN.asm
                    > USED AT LINE 472 IN MAIN.asm
RPOP:               0402 DEFINED AT LINE 460 IN MAIN.asm
                    > USED AT LINE 133 IN MAIN.asm
                    > USED AT LINE 135 IN MAIN.asm
                    > USED AT LINE 279 IN MAIN.asm
                    > USED AT LINE 281 IN MAIN.asm
RPOP2:              040C DEFINED AT LINE 465 IN MAIN.asm
ENTER:              040D DEFINED AT LINE 468 IN MAIN.asm
PRINTDEC:           0420 DEFINED AT LINE 479 IN MAIN.asm
                    > USED AT LINE 125 IN MAIN.asm
PRINTDEC2:          042F DEFINED AT LINE 490 IN MAIN.asm
                    > USED AT LINE 481 IN MAIN.asm
PRINTDEC4:          0451 DEFINED AT LINE 506 IN MAIN.asm
                    > USED AT LINE 494 IN MAIN.asm
                    > USED AT LINE 496 IN MAIN.asm
                    > USED AT LINE 498 IN MAIN.asm
                    > USED AT LINE 500 IN MAIN.asm
                    > USED AT LINE 503 IN MAIN.asm
PRINTDEC5:          0453 DEFINED AT LINE 508 IN MAIN.asm
                    > USED AT LINE 511 IN MAIN.asm
PRINTDEC6:          0463 DEFINED AT LINE 520 IN MAIN.asm
                    > USED AT LINE 515 IN MAIN.asm
PRINTDEC7:          0464 DEFINED AT LINE 522 IN MAIN.asm
                    > USED AT LINE 519 IN MAIN.asm
DEF:                0468 DEFINED AT LINE 526 IN MAIN.asm
                    > USED AT LINE 140 IN MAIN.asm
DEF0:               0476 DEFINED AT LINE 535 IN MAIN.asm
                    > USED AT LINE 530 IN MAIN.asm
DEF1:               0481 DEFINED AT LINE 542 IN MAIN.asm
                    > USED AT LINE 534 IN MAIN.asm
                    > USED AT LINE 549 IN MAIN.asm
DEF2:               048B DEFINED AT LINE 550 IN MAIN.asm
                    > USED AT LINE 548 IN MAIN.asm
DEF3:               048C DEFINED AT LINE 552 IN MAIN.asm
DSIZE:              0080 DEFINED AT LINE 1 IN ram.asm
                    > USED AT LINE 13 IN ram.asm
RSIZE:              0080 DEFINED AT LINE 2 IN ram.asm
                    > USED AT LINE 10 IN ram.asm
TIBSIZE:            0100 DEFINED AT LINE 3 IN ram.asm
                    > USED AT LINE 8 IN ram.asm
VARS_SIZE:          0034 DEFINED AT LINE 4 IN ram.asm
                    > USED AT LINE 153 IN MAIN.asm
                    > USED AT LINE 34 IN ram.asm
                    > USED AT LINE 35 IN ram.asm
TIB:                0800 DEFINED AT LINE 8 IN ram.asm
                    > USED AT LINE 177 IN MAIN.asm
                    > USED AT LINE 213 IN MAIN.asm
                    > USED AT LINE 222 IN MAIN.asm
                    > USED AT LINE 239 IN MAIN.asm
RSTACK:             0980 DEFINED AT LINE 11 IN ram.asm
                    > USED AT LINE 145 IN MAIN.asm
DSTACK:             0A00 DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 161 IN MAIN.asm
                    > USED AT LINE 287 IN MAIN.asm
                    > USED AT LINE 290 IN MAIN.asm
STACK:              0A00 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 445 IN IOSerial.asm
TBPTR:              0A00 DEFINED AT LINE 16 IN ram.asm
VTEMP1:             0A02 DEFINED AT LINE 17 IN ram.asm
VTEMP2:             0A04 DEFINED AT LINE 18 IN ram.asm
RST08:              0A06 DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 447 IN IOSerial.asm
RST10:              0A08 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 113 IN IOSerial.asm
                    > USED AT LINE 448 IN IOSerial.asm
RST18:              0A0A DEFINED AT LINE 22 IN ram.asm
                    > USED AT LINE 119 IN IOSerial.asm
                    > USED AT LINE 449 IN IOSerial.asm
RST20:              0A0C DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 125 IN IOSerial.asm
                    > USED AT LINE 450 IN IOSerial.asm
RST28:              0A0E DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 131 IN IOSerial.asm
                    > USED AT LINE 451 IN IOSerial.asm
RST30:              0A10 DEFINED AT LINE 25 IN ram.asm
                    > USED AT LINE 137 IN IOSerial.asm
                    > USED AT LINE 452 IN IOSerial.asm
BAUD:               0A12 DEFINED AT LINE 26 IN ram.asm
INTVEC:             0A14 DEFINED AT LINE 27 IN ram.asm
                    > USED AT LINE 143 IN IOSerial.asm
                    > USED AT LINE 453 IN IOSerial.asm
NMIVEC:             0A16 DEFINED AT LINE 28 IN ram.asm
                    > USED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 454 IN IOSerial.asm
GETCVEC:            0A18 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 435 IN IOSerial.asm
                    > USED AT LINE 457 IN IOSerial.asm
PUTCVEC:            0A1A DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 440 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
VARS:               0B00 DEFINED AT LINE 34 IN ram.asm
                    > USED AT LINE 149 IN MAIN.asm
                    > USED AT LINE 355 IN MAIN.asm
DEFS:               0B34 DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 371 IN MAIN.asm
ALTVARS:            0B68 DEFINED AT LINE 37 IN ram.asm
VBYTEMODE:          0B6A DEFINED AT LINE 39 IN ram.asm
                    > USED AT LINE 105 IN MAIN.asm
                    > USED AT LINE 361 IN MAIN.asm
VCARRY:             0B6C DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 120 IN MAIN.asm
VHEAPPTR:           0B76 DEFINED AT LINE 45 IN ram.asm
                    > USED AT LINE 157 IN MAIN.asm
                    > USED AT LINE 532 IN MAIN.asm
                    > USED AT LINE 537 IN MAIN.asm
                    > USED AT LINE 553 IN MAIN.asm
VTIBPTR:            0B7C DEFINED AT LINE 48 IN ram.asm
                    > USED AT LINE 171 IN MAIN.asm
                    > USED AT LINE 238 IN MAIN.asm
VREMAIN:            0B8A DEFINED AT LINE 55 IN ram.asm
VBASEPTR:           0B9C DEFINED AT LINE 65 IN ram.asm
                    > USED AT LINE 132 IN MAIN.asm
                    > USED AT LINE 134 IN MAIN.asm
                    > USED AT LINE 146 IN MAIN.asm
                    > USED AT LINE 278 IN MAIN.asm
                    > USED AT LINE 280 IN MAIN.asm
                    > USED AT LINE 345 IN MAIN.asm
                    > USED AT LINE 347 IN MAIN.asm
                    > USED AT LINE 471 IN MAIN.asm
                    > USED AT LINE 473 IN MAIN.asm
VPOINTER:           0B9E DEFINED AT LINE 66 IN ram.asm
                    > USED AT LINE 103 IN MAIN.asm
                    > USED AT LINE 358 IN MAIN.asm
HEAP:               0BA0 DEFINED AT LINE 68 IN ram.asm
                    > USED AT LINE 156 IN MAIN.asm
