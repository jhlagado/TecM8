0000                          .ENGINE   mycomputer   
0000                             ; 
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                          IF   RC2014   
                                 ; Configuration for RC2014
                    ROMSTART:   EQU   $8000   
                    RAMSTART:   EQU   $8800   
                    LOADER:   EQU   0   
                    BITBANG:   EQU   0   
0000                          ENDIF      
0000                          IF   TEC_1   
0000                             ; Configuration for TEC-1
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $0800   
0000                ROMSIZE:   EQU   $0800   
0000                RAMSIZE:   EQU   $0800   
0000                             ;TEC-1D SC 8k rom/ram
0000                             ; ROMSTART .equ $0000
0000                             ; RAMSTART .equ $2000
0000                             ; ROMSIZE  .equ 8192
0000                             ; RAMSIZE  .equ 8192
0000                          ENDIF      
0000                             ; *************************************************************************
0000                             ; 
0000                             ;       Serial routines 
0000                             ; 
0000                             ;       written by Craig Jones 
0000                             ; 
0000                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
0000                             ; 
0000                             ;       see the LICENSE file in this repo for more information 
0000                             ; 
0000                             ; *****************************************************************************
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8B 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 00 08               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 02 08               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 04 08               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A 06 08               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A 08 08               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A 0A 08               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A 0E 08               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A 10 08               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   2A 12 08               LD   HL,(GETCVEC)   
0084   E9                     JP   (HL)   
0085                             ; 
0085                PUTCHAR:      
0085   E5                     PUSH   HL   
0086   2A 14 08               LD   HL,(PUTCVEC)   
0089   E3                     EX   (SP),HL   
008A   C9                     RET      
008B                             ; 
008B                RESET:       
008B   31 28 0A               LD   SP,stack   
008E   21 5F 00               LD   HL,IntRet   
0091   22 00 08               LD   (RST08),HL   
0094   22 02 08               LD   (RST10),HL   
0097   22 04 08               LD   (RST18),HL   
009A   22 06 08               LD   (RST20),HL   
009D   22 08 08               LD   (RST28),HL   
00A0   22 0A 08               LD   (RST30),HL   
00A3   22 0E 08               LD   (INTVEC),HL   
00A6   22 10 08               LD   (NMIVEC),HL   
00A9                             ; 
00A9   21 78 00               LD   HL,RXDATA   
00AC   22 12 08               LD   (GETCVEC),HL   
00AF   21 6B 00               LD   HL,TXDATA   
00B2   22 14 08               LD   (PUTCVEC),HL   
00B5                             ; 
00B5                          IF   TEC_1   
00B5                          IF   BITBANG = 0   
00B5                             ; 
00B5   3E 03                  LD   a,MRESET   
00B7   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B9                             ; 
00B9                          ENDIF      
00B9                          ENDIF      
00B9                             ; 
00B9   CD 50 00               CALL   PWRUP   
00BC   ED 56                  IM   1   
00BE   FB                     EI      
00BF                             ; 
00BF                          IF   TEC_1   
00BF                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00BF                          ELSE      ;6850      
00BF                             ; 
00BF   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C1   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C3                             ; 
00C3                          ENDIF      
00C3                          ENDIF      
00C3                             ; 
00C3                             ; 
00C3                             ; 
00C3   C3 80 01               JP   start   ; into #180 of the prog
00C6                             ; 
00C6                             ; *************************************************************************
00C6                             ; 
00C6                             ;       TecM8 1.0 Assembler for the Tec-1
00C6                             ; 
00C6                             ;       by John Hardy
00C6                             ; 
00C6                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
00C6                             ; 
00C6                             ;       see the LICENSE file in this repo for more information
00C6                             ; 
00C6                             ; *****************************************************************************
00C6                             ; **************************************************************************
00C6                             ; Constants
00C6                             ; **************************************************************************
00C6                TRUE:     EQU   -1   
00C6                FALSE:    EQU   0   
00C6                CTRL_C:   EQU   3   
00C6                CTRL_H:   EQU   8   
00C6                             ; **************************************************************************
00C6                             ; Page 0  Initialisation
00C6                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put TecM8 code from here	
0180                EOF_:     EQU   -1   
0180                NUL_:     EQU   0   
0180                END_:     EQU   2   
0180                SKIP_:    EQU   3   
0180                NUM_:     EQU   4   
0180                ID_:      EQU   5   
0180                START:       ; entry point of TecM8
0180   31 28 0A               LD   sp,STACK   
0183   CD 98 01               CALL   init   
0186   CD 1B 03               CALL   printStr   
0189   54 65 63 4D 38 20 30 2E 30 0D 0A 00 .CSTR   "TecM8 0.0\r\n"   
0195   C3 BE 01               JP   parse   
0198                INIT:        
0198   AF                     XOR   a   ; a = NUL_ token
0199   32 1A 08               LD   (vToken),a   
019C   21 28 08               LD   hl,chars   
019F   22 1E 08               LD   (vCharPtr),hl   
01A2   21 28 0D               LD   hl,assembly   
01A5   22 20 08               LD   (vAsmPtr),hl   
01A8   21 28 0A               LD   hl,strings   
01AB   22 22 08               LD   (vStrPtr),hl   
01AE   22 1C 08               LD   (vTokPtr),hl   
01B1   21 28 0B               LD   hl,symbols   
01B4   22 24 08               LD   (vSymPtr),hl   
01B7   21 28 0C               LD   hl,exprs   
01BA   22 26 08               LD   (vExprPtr),hl   
01BD   C9                     RET      
01BE                PARSE:       
01BE   CD E5 01               CALL   statementList   
01C1   CD 1B 03               CALL   printStr   
01C4   50 61 72 73 69 6E 67 20 63 6F 6D 70 6C 65 74 65 64 20 73 75 63 63 65 73 73 66 75 6C 6C 79 2E 00 .CSTR   "Parsing completed successfully."   ; 
01E4   76                     HALT      
01E5                STATEMENTLIST:      
01E5   3A 1A 08               LD   a,(vToken)   
01E8   FE FF                  CP   EOF_   
01EA   C8                     RET   z   
01EB   CD 09 02               CALL   statement   
01EE   FE 02                  CP   END_   
01F0   CD 0A 02               CALL   match   
01F3   28 F0                  JR   z,statementList   
01F5   CD 21 03               CALL   error   
01F8   45 78 70 65 63 74 65 64 20 6E 65 77 6C 69 6E 65 00 .CSTR   "Expected newline"   
0209                STATEMENT:      
0209   C9                     RET      
020A                MATCH:       
020A   C0                     RET   nz   
020B   F5                     PUSH   af   
020C   CD 13 02               CALL   nextToken   
020F   6F                     LD   l,a   
0210   F1                     POP   af   
0211   7D                     LD   a,l   
0212   C9                     RET      
0213                NEXTTOKEN:      
0213   21 00 00               LD   hl,0   
0216   CD B6 02               CALL   nextChar   
0219   3D                     DEC   a   ; if -ve then EOF
021A   38 43                  JR   c,nextToken1x   
021C   3C                     INC   a   ; restore a
021D   FE 21                  CP   " "+1   ; is it whitespace
021F   30 10                  JR   nc,nextToken3   
0221                NEXTTOKEN1:      
0221   B7                     OR   a   ; is it null
0222   28 09                  JR   z,nextToken2   
0224   FE 21                  CP   " "+1   
0226   30 05                  JR   nc,nextToken2   
0228   CD B6 02               CALL   nextChar   
022B   18 F4                  JR   nextToken1   
022D                NEXTTOKEN2:      
022D   3E 03                  LD   a,SKIP_   
022F   18 2E                  JR   nextToken1x   
0231                NEXTTOKEN3:      
0231   FE 2D                  CP   "-"   
0233   28 0E                  JR   z,nextToken4   
0235   FE 24                  CP   "$"   
0237   28 0A                  JR   z,nextToken4   
0239   FE 30                  CP   "0"   
023B   30 06                  JR   nc,nextToken4   
023D   FE 3A                  CP   "9"+1   
023F   38 02                  JR   c,nextToken4   
0241   18 07                  JR   nextToken5   
0243                NEXTTOKEN4:      
0243   CD 66 02               CALL   number   
0246   3E 04                  LD   a,NUM_   
0248   18 15                  JR   nextToken1x   
024A                NEXTTOKEN5:      
024A   FE 5F                  CP   "_"   
024C   28 05                  JR   z,nextToken6   
024E   CD 90 02               CALL   isAlpha   
0251   20 07                  JR   nz,nextToken7   
0253                NEXTTOKEN6:      
0253   CD 6A 02               CALL   ident   
0256   3E 05                  LD   a,ID_   
0258   18 05                  JR   nextToken1x   
025A                NEXTTOKEN7:      
025A   3E 00                  LD   a,NUL_   
025C   21 00 00               LD   hl,0   
025F                NEXTTOKEN1X:      
025F   32 1A 08               LD   (vToken),a   
0262   22 1C 08               LD   (vTokPtr),hl   
0265   C9                     RET      
0266                NUMBER:      
0266   21 00 00               LD   hl,0   
0269   C9                     RET      
026A                             ; adds ident to string heap
026A                             ; returns hl = ptr to ident
026A                             ; destroys a,b,c,d,e,h,l
026A                             ; updates vStrPtr
026A                IDENT:       
026A   2A 22 08               LD   hl,(vStrPtr)   
026D   23                     INC   hl   ; skip length byte
026E                IDENT1:      
026E   77                     LD   (hl),a   ; write char
026F   23                     INC   hl   
0270   CD B6 02               CALL   nextChar   
0273   FE 5F                  CP   "_"   
0275   28 F7                  JR   z,ident1   
0277   CD 89 02               CALL   isAlphanum   
027A   28 F2                  JR   z,ident1   
027C                IDENT2:      
027C   ED 5B 22 08            LD   de,(vStrPtr)   ; de = string start
0280   22 22 08               LD   (vStrPtr),hl   ; save string end
0283   B7                     OR   a   
0284   ED 52                  SBC   hl,de   ; hl = len, de = strPtr
0286   EB                     EX   de,hl   ; e = len, hl = strPtr
0287   73                     LD   (hl),e   ; save len byte
0288   C9                     RET      
0289                             ; destroys b
0289                             ; uppercases a
0289                ISALPHANUM:      
0289   CD 90 02               CALL   isAlpha   
028C   C8                     RET   z   
028D   C3 A8 02               JP   isNumeric   
0290                             ; destroys b
0290                             ; uppercases a
0290                ISALPHA:      
0290   06 00                  LD   b,0   ; reset zero flag
0292   FE 41                  CP   "A"   
0294   38 10                  JR   c,isAlpha2   
0296   FE 5B                  CP   "Z"+1   
0298   38 0A                  JR   c,isAlpha1   
029A   FE 61                  CP   "a"   
029C   38 08                  JR   c,isAlpha2   
029E   FE 7B                  CP   "z"+1   
02A0   30 04                  JR   nc,isAlpha2   
02A2   D6 20                  SUB   ("a" - "A")   ; uppercase a
02A4                ISALPHA1:      
02A4   06 01                  LD   b,1   ; set zero flag
02A6                ISALPHA2:      
02A6   05                     DEC   b   ; determine zero flag
02A7   C9                     RET      
02A8                             ; destroys b
02A8                ISNUMERIC:      
02A8   06 00                  LD   b,0   ; set zero flag
02AA   FE 30                  CP   "0"   
02AC   38 06                  JR   c,isNumeric1   
02AE   FE 3A                  CP   "9"+1   
02B0   30 02                  JR   nc,isNumeric1   
02B2   06 01                  LD   b,1   ; reset zero flag
02B4                ISNUMERIC1:      
02B4   05                     DEC   b   ; determine zero flag
02B5   C9                     RET      
02B6                NEXTCHAR:      
02B6   C3 81 00               JP   getchar   
02B9   ED 4B 1E 08            LD   bc,(vCharPtr)   
02BD   0A                     LD   a,(bc)   
02BE   03                     INC   bc   
02BF   ED 43 1E 08            LD   (vCharPtr),bc   
02C3   B7                     OR   a   
02C4   C0                     RET   nz   
02C5   CD CA 02               CALL   nextLine   
02C8   18 EC                  JR   nextChar   
02CA                NEXTLINE:      
02CA   CD 0B 03               CALL   prompt   
02CD   01 28 08               LD   bc,chars   ; load bc with start of chars buffer
02D0                NEXTLINE2:      
02D0   CD 81 00               CALL   getchar   ; get character from serial port
02D3   FE 20                  CP   $20   ; compare to space
02D5   38 07                  JR   c,nextLine3   
02D7   02                     LD   (bc),A   ; store the character in textbuf
02D8   03                     INC   bc   
02D9   CD 85 00               CALL   putchar   ; echo character to screen
02DC   18 F2                  JR   nextLine2   ; wait for next character
02DE                NEXTLINE3:      ; control char
02DE   FE 0D                  CP   "\r"   ; carriage return? ascii 13
02E0   28 1C                  JR   Z,nextLine4   ; if anything else its control char
02E2   FE 0A                  CP   "\n"   ; carriage return? ascii 13
02E4   28 18                  JR   Z,nextLine4   ; if anything else its control char
02E6   FE 08                  CP   CTRL_H   ; backSpace ?
02E8   20 E6                  JR   nz,nextLine2   ; no, ignore
02EA   21 28 08               LD   hl,chars   ; is bc already at start of chars buffer
02ED   B7                     OR   a   
02EE   ED 42                  SBC   hl,bc   
02F0   7C                     LD   a,h   
02F1   B5                     OR   l   
02F2   28 DC                  JR   z,nextLine2   ; if so, ignore backspace
02F4   0B                     DEC   bc   
02F5   CD 1B 03               CALL   printStr   ; backspace over previous letter
02F8   08 20 08 00            .CSTR   "\b \b"   ; erase letter
02FC   18 D2                  JR   nextLine2   
02FE                NEXTLINE4:      
02FE   AF                     XOR   a   ; store null in text buffer
02FF   02                     LD   (bc),a   
0300   CD 14 03               CALL   crlf   ; echo newline to screen
0303   01 28 08               LD   bc,chars   ; Instructions stored on heap at address HERE, we pressed enter
0306   ED 43 1E 08            LD   (vCharPtr),bc   ; point vCharPtr to start of chars buffer
030A   C9                     RET      
030B                             ; *******************************************************************************
030B                             ; *********  END OF MAIN   ******************************************************
030B                             ; *******************************************************************************
030B                             ; next:
030B                             ;     inc bc                  ; Increment the IP
030B                             ;     ld a,(bc)               ; Get the next character and dispatch
030B                             ;     or a                    ; is it NUL?
030B                             ;     jr z,exit
030B                             ;     cp "\n"                 ; is it newline?
030B                             ;     jr z,interpret
030B                             ;     cp "0"
030B                             ;     ld d,"!"
030B                             ;     jr c,op
030B                             ;     cp "9"+1
030B                             ;     jr c,num
030B                             ;     cp "A"
030B                             ;     ld d,"!"+10
030B                             ;     jr c,op
030B                             ;     cp "Z"+1
030B                             ;     jr c,callx
030B                             ;     cp "a"
030B                             ;     ld d,"!"+10+26
030B                             ;     jr c,op
030B                             ;     cp "z"+1
030B                             ;     jp c,var
030B                             ;     ld d,"!"+10+26+26
030B                             ; op:
030B                             ;     sub d
030B                             ;     jr c,next
030B                             ;     add a,lsb(opcodes)
030B                             ;     ld l,A                      ; Index into table
030B                             ;     ld h,msb(opcodes)           ; Start address of jump table
030B                             ;     ld l,(hl)                   ; get low jump address
030B                             ;     inc h                       ; msb on next page
030B                             ;     jp (hl)                     ; Jump to routine
030B                             ; exit:
030B                             ;     inc bc			; store offests into a table of bytes, smaller
030B                             ;     ld de,bc
030B                             ;     ld ix,(vBasePtr)        ;
030B                             ;     call rpop               ; Restore old base pointer
030B                             ;     ld (vBasePtr),hl
030B                             ;     call rpop               ; Restore Instruction pointer
030B                             ;     ld bc,hl
030B                             ;     EX de,hl
030B                             ;     jp (hl)
030B                             ; num:
030B                             ; 	ld hl,$0000				    ; Clear hl to accept the number
030B                             ;     cp "-"
030B                             ;     jr nz,num0
030B                             ;     inc bc                      ; move to next char, no flags affected
030B                             ; num0:
030B                             ;     ex af,af'                   ; save zero flag = 0 for later
030B                             ; num1:
030B                             ;     ld a,(bc)                   ; read digit
030B                             ;     sub "0"                     ; less than 0?
030B                             ;     jr c, num2                  ; not a digit, exit loop
030B                             ;     cp 10                       ; greater that 9?
030B                             ;     jr nc, num2                 ; not a digit, exit loop
030B                             ;     inc bc                      ; inc IP
030B                             ;     ld de,hl                    ; multiply hl * 10
030B                             ;     add hl,hl
030B                             ;     add hl,hl
030B                             ;     add hl,de
030B                             ;     add hl,hl
030B                             ;     add a,l                     ; add digit in a to hl
030B                             ;     ld l,a
030B                             ;     ld a,0
030B                             ;     adc a,h
030B                             ;     ld h,a
030B                             ;     jr num1
030B                             ; num2:
030B                             ;     dec bc
030B                             ;     ex af,af'                   ; restore zero flag
030B                             ;     jr nz, num3
030B                             ;     ex de,hl                    ; negate the value of hl
030B                             ;     ld hl,0
030B                             ;     or a                        ; jump to sub2
030B                             ;     sbc hl,de
030B                             ; num3:
030B                             ;     push hl                     ; Put the number on the stack
030B                             ;     jp (iy)                     ; and process the next character
030B                             ; callx:
030B                             ;     call lookupRef0
030B                             ;     ld E,(hl)
030B                             ;     inc hl
030B                             ;     ld D,(hl)
030B                             ;     ld a,D                      ; skip if destination address is null
030B                             ;     or E
030B                             ;     jr Z,call2
030B                             ;     ld hl,bc
030B                             ;     inc bc                      ; read next char from source
030B                             ;     ld a,(bc)                   ; if ; to tail call optimise
030B                             ;     cp ";"                      ; by jumping to rather than calling destination
030B                             ;     jr Z,call1
030B                             ;     call rpush                  ; save Instruction Pointer
030B                             ;     ld hl,(vBasePtr)
030B                             ;     call rpush
030B                             ;     ld (vBasePtr),ix
030B                             ; call1:
030B                             ;     ld bc,de
030B                             ;     dec bc
030B                             ; call2:
030B                             ;     jp (iy)
030B                             ; var:
030B                             ;     ld hl,vars
030B                             ;     call lookupRef
030B                             ; var1:
030B                             ;     ld (vPointer),hl
030B                             ;     ld d,0
030B                             ;     ld e,(hl)
030B                             ;     ld a,(vByteMode)
030B                             ;     inc a                       ; is it byte?
030B                             ;     jr z,var2
030B                             ;     inc hl
030B                             ;     ld d,(hl)
030B                             ; var2:
030B                             ;     push de
030B                             ;     jp (iy)
030B                             ; lookupRef0:
030B                             ;     ld hl,defs
030B                             ;     sub "A"
030B                             ;     jr lookupRef1
030B                             ; lookupRef:
030B                             ;     sub "a"
030B                             ; lookupRef1:
030B                             ;     add a,a
030B                             ;     add a,l
030B                             ;     ld l,a
030B                             ;     ld a,0
030B                             ;     ADC a,h
030B                             ;     ld h,a
030B                             ;     XOR a
030B                             ;     or e                        ; sets Z flag if A-Z
030B                             ;     ret
030B                PROMPT:      
030B   CD 1B 03               CALL   printStr   
030E   0D 0A 3E 20 00         .CSTR   "\r\n> "   
0313   C9                     RET      
0314                CRLF:        
0314   CD 1B 03               CALL   printStr   
0317   0D 0A 00               .CSTR   "\r\n"   
031A   C9                     RET      
031B                             ; printStr:
031B                             ;     EX (sp),hl		                ; swap			
031B                             ;     call putStr		
031B                             ;     inc hl			                ; inc past null
031B                             ;     EX (sp),hl		                ; put it back	
031B                             ;     ret
031B                PRINTSTR:      
031B   E1                     POP   hl   ; "return" address is address of string			
031C   CD 2A 03               CALL   putStr   
031F   23                     INC   hl   ; inc past null
0320   E9                     JP   (hl)   ; put it back	
0321                ERROR:       
0321   E1                     POP   hl   
0322   CD 2A 03               CALL   putStr   
0325   76                     HALT      
0326                PUTSTR0:      
0326   CD 85 00               CALL   putchar   
0329   23                     INC   hl   
032A                PUTSTR:      
032A   7E                     LD   a,(hl)   
032B   B7                     OR   A   
032C   20 F8                  JR   nz,putStr0   
032E   C9                     RET      
032F                RPUSH:       
032F   DD 2B                  DEC   ix   
0331   DD 74 00               LD   (ix+0),H   
0334   DD 2B                  DEC   ix   
0336   DD 75 00               LD   (ix+0),L   
0339   C9                     RET      
033A                RPOP:        
033A   DD 6E 00               LD   L,(ix+0)   
033D   DD 23                  INC   ix   
033F   DD 66 00               LD   H,(ix+0)   
0342   DD 23                  INC   ix   
0344                RPOP2:       
0344   C9                     RET      
0345                             ; enter:
0345                             ;     ld hl,bc
0345                             ;     call rpush                      ; save Instruction Pointer
0345                             ;     ld hl,(vBasePtr)
0345                             ;     call rpush
0345                             ;     ld (vBasePtr),ix
0345                             ;     pop bc
0345                             ;     dec bc
0345                             ;     jp (iy)
0345                             ; hl = value
0345                PRINTDEC:      
0345   CB 7C                  BIT   7,h   
0347   28 0B                  JR   z,printDec2   
0349   3E 2D                  LD   a,"-"   
034B   CD 85 00               CALL   putchar   
034E   AF                     XOR   a   
034F   95                     SUB   l   
0350   6F                     LD   l,a   
0351   9F                     SBC   a,a   
0352   94                     SUB   h   
0353   67                     LD   h,a   
0354                PRINTDEC2:      
0354   C5                     PUSH   bc   
0355   0E 00                  LD   c,0   ; leading zeros flag = false
0357   11 F0 D8               LD   de,-10000   
035A   CD 76 03               CALL   printDec4   
035D   11 18 FC               LD   de,-1000   
0360   CD 76 03               CALL   printDec4   
0363   11 9C FF               LD   de,-100   
0366   CD 76 03               CALL   printDec4   
0369   1E F6                  LD   e,-10   
036B   CD 76 03               CALL   printDec4   
036E   0C                     INC   c   ; flag = true for at least digit
036F   1E FF                  LD   e,-1   
0371   CD 76 03               CALL   printDec4   
0374   C1                     POP   bc   
0375   C9                     RET      
0376                PRINTDEC4:      
0376   06 2F                  LD   b,"0"-1   
0378                PRINTDEC5:      
0378   04                     INC   b   
0379   19                     ADD   hl,de   
037A   38 FC                  JR   c,printDec5   
037C   ED 52                  SBC   hl,de   
037E   3E 30                  LD   a,"0"   
0380   B8                     CP   b   
0381   20 05                  JR   nz,printDec6   
0383   AF                     XOR   a   
0384   B1                     OR   c   
0385   C8                     RET   z   
0386   18 01                  JR   printDec7   
0388                PRINTDEC6:      
0388   0C                     INC   c   
0389                PRINTDEC7:      
0389   78                     LD   a,b   
038A   C3 85 00               JP   putchar   
038D                             ; def:                                ; Create a colon definition
038D                             ;     inc bc
038D                             ;     ld  a,(bc)                  ; Get the next character
038D                             ;     cp ":"                      ; is it anonymouse
038D                             ;     jr nz,def0
038D                             ;     inc bc
038D                             ;     ld de,(vHeapPtr)            ; return start of definition
038D                             ;     push de
038D                             ;     jr def1
038D                             ; def0:
038D                             ;     call lookupRef0
038D                             ;     ld de,(vHeapPtr)            ; start of defintion
038D                             ;     ld (hl),E                   ; Save low byte of address in CFA
038D                             ;     inc hl
038D                             ;     ld (hl),D                   ; Save high byte of address in CFA+1
038D                             ;     inc bc
038D                             ; def1:                               ; Skip to end of definition
038D                             ;     ld a,(bc)                   ; Get the next character
038D                             ;     inc bc                      ; Point to next character
038D                             ;     ld (de),A
038D                             ;     inc de
038D                             ;     cp ";"                      ; Is it a semicolon
038D                             ;     jr Z, def2                  ; end the definition
038D                             ;     jr  def1                    ; get the next element
038D                             ; def2:
038D                             ;     dec bc
038D                             ; def3:
038D                             ;     ld (vHeapPtr),de            ; bump heap ptr to after definiton
038D                             ;     jp (iy)
038D                             ; opcodes:
038D                             ;     db    lsb(bang_)        ;   !
038D                             ;     db    lsb(dquote_)      ;   "
038D                             ;     db    lsb(hash_)        ;   #
038D                             ;     db    lsb(dollar_)      ;   $
038D                             ;     db    lsb(percent_)     ;   %
038D                             ;     db    lsb(amper_)       ;   &
038D                             ;     db    lsb(quote_)       ;   '
038D                             ;     db    lsb(lparen_)      ;   (
038D                             ;     db    lsb(rparen_)      ;   )
038D                             ;     db    lsb(star_)        ;   *
038D                             ;     db    lsb(plus_)        ;   +
038D                             ;     db    lsb(comma_)       ;   ,
038D                             ;     db    lsb(minus_)       ;   -
038D                             ;     db    lsb(dot_)         ;   .
038D                             ;     db    lsb(slash_)       ;   /	
038D                             ;     db    lsb(colon_)       ;    :
038D                             ;     db    lsb(semi_)        ;    ;
038D                             ;     db    lsb(lt_)          ;    <
038D                             ;     db    lsb(eq_)          ;    =
038D                             ;     db    lsb(gt_)          ;    >
038D                             ;     db    lsb(question_)    ;    ?
038D                             ;     db    lsb(at_)          ;    @
038D                             ;     db    lsb(lbrack_)      ;    [
038D                             ;     db    lsb(bslash_)      ;    \
038D                             ;     db    lsb(rbrack_)      ;    ]
038D                             ;     db    lsb(caret_)       ;    ^
038D                             ;     db    lsb(underscore_)  ;    _
038D                             ;     db    lsb(grave_)       ;    `
038D                             ;     db    lsb(lbrace_)      ;    {
038D                             ;     db    lsb(pipe_)        ;    |
038D                             ;     db    lsb(rbrace_)      ;    }
038D                             ;     db    lsb(tilde_)       ;    ~
038D                             ; .align $100
038D                             ; nop_:
038D                             ; bslash_:
038D                             ; quote_:                          ; Discard the top member of the stack
038D                             ; at_:
038D                             ; underscore_:
038D                             ; percent_:
038D                             ; amper_:
038D                             ; pipe_: 		
038D                             ; caret_:		
038D                             ; tilde_:
038D                             ; invert:				        ; Bitwise INVert the top member of the stack
038D                             ; dquote_:
038D                             ; comma_:                          ; print hexadecimal
038D                             ; lbrace_:
038D                             ; rbrace_:
038D                             ; dollar_:
038D                             ; minus_:       		        ; Subtract the value 2nd on stack from top of stack
038D                             ; eq_:
038D                             ; gt_:
038D                             ; lt_:
038D                             ; grave_:
038D                             ; rparen_:
038D                             ; lbrack_:
038D                             ; rbrack_:
038D                             ; lparen_:
038D                             ; slash_:
038D                             ; question_:
038D                             ; hash_:
038D                             ; star_:
038D                             ;     jp (iy)
038D                             ; bang_:                      ; Store the value at the address placed on the top of the stack
038D                             ; plus_:                           ; add the top 2 members of the stack
038D                             ; dot_:
038D                             ; semi_:
038D                             ; colon_:
0800                          .ORG   RAMSTART   
0800                RST08:    DS   2   
0802                RST10:    DS   2   
0804                RST18:    DS   2   
0806                RST20:    DS   2   
0808                RST28:    DS   2   
080A                RST30:    DS   2   ; 
080C                BAUD:     DS   2   ; 
080E                INTVEC:   DS   2   ; 
0810                NMIVEC:   DS   2   ; 
0812                GETCVEC:   DS   2   ; 
0814                PUTCVEC:   DS   2   ; 
0816                VTEMP1:   DS   2   ; temp var 1
0818                VTEMP2:   DS   2   ; temp var 2
081A                VTOKEN:   DS   2   ; byte containing enum of token type
081C                VTOKPTR:   DS   2   ; pointer to start of token value
081E                VCHARPTR:   DS   2   ; pointer to char position into input buffer
0820                VASMPTR:   DS   2   ; pointer to assembly point
0822                VSTRPTR:   DS   2   ; pointer to string stack
0824                VSYMPTR:   DS   2   ; pointer to symbol stack
0826                VEXPRPTR:   DS   2   ; pointer to expression stack
0828                CHARS:    DS   $100   ; page aligned, 256 bytes , a long line!
0928                          DS   $100   
0A28                STACK:       ; grows down
0A28                STRINGS:   DS   $100   ; string heap - grows up
0B28                SYMBOLS:   DS   $100   ; symbol heap - grows up
0C28                EXPRS:    DS   $100   ; expression heap - grows up
0D28                ASSEMBLY:      


TEC_1:              0001 DEFINED AT LINE 1 IN constants.asm
RC2014:             0000 DEFINED AT LINE 2 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 4 IN constants.asm
LOADER:             0000 DEFINED AT LINE 20 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 21 IN constants.asm
ROMSTART:           0000 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 116 IN IOSerial.asm
                    > USED AT LINE 122 IN IOSerial.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 134 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 146 IN IOSerial.asm
                    > USED AT LINE 152 IN IOSerial.asm
                    > USED AT LINE 158 IN IOSerial.asm
                    > USED AT LINE 200 IN IOSerial.asm
                    > USED AT LINE 26 IN MAIN.asm
RAMSTART:           0800 DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 1 IN ram.asm
ROMSIZE:            0800 DEFINED AT LINE 25 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 26 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 33 IN IOSerial.asm
                    > USED AT LINE 476 IN IOSerial.asm
                    > USED AT LINE 498 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 34 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 322 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 36 IN IOSerial.asm
                    > USED AT LINE 326 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 475 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 46 IN IOSerial.asm
                    > USED AT LINE 497 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 50 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 51 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 52 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 53 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 54 IN IOSerial.asm
                    > USED AT LINE 497 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 55 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 56 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 57 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 61 IN IOSerial.asm
                    > USED AT LINE 497 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 62 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 63 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 64 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 68 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 72 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 73 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 74 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 75 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 76 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 77 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 78 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 79 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 87 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 88 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 89 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 90 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 91 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 92 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 93 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 94 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 107 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 108 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 109 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 113 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 163 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 481 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 187 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 193 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 196 IN IOSerial.asm
                    > USED AT LINE 457 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 469 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 305 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 308 IN IOSerial.asm
                    > USED AT LINE 312 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 320 IN IOSerial.asm
                    > USED AT LINE 467 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 321 IN IOSerial.asm
                    > USED AT LINE 325 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 445 IN IOSerial.asm
                    > USED AT LINE 205 IN MAIN.asm
                    > USED AT LINE 233 IN MAIN.asm
PUTCHAR:            0085 DEFINED AT LINE 449 IN IOSerial.asm
                    > USED AT LINE 238 IN MAIN.asm
                    > USED AT LINE 437 IN MAIN.asm
                    > USED AT LINE 475 IN MAIN.asm
                    > USED AT LINE 516 IN MAIN.asm
RESET:              008B DEFINED AT LINE 455 IN IOSerial.asm
                    > USED AT LINE 114 IN IOSerial.asm
TRUE:               00-1 DEFINED AT LINE 17 IN MAIN.asm
FALSE:              0000 DEFINED AT LINE 18 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 19 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 20 IN MAIN.asm
                    > USED AT LINE 246 IN MAIN.asm
EOF_:               00-1 DEFINED AT LINE 29 IN MAIN.asm
                    > USED AT LINE 68 IN MAIN.asm
NUL_:               0000 DEFINED AT LINE 30 IN MAIN.asm
                    > USED AT LINE 131 IN MAIN.asm
END_:               0002 DEFINED AT LINE 31 IN MAIN.asm
                    > USED AT LINE 71 IN MAIN.asm
SKIP_:              0003 DEFINED AT LINE 32 IN MAIN.asm
                    > USED AT LINE 105 IN MAIN.asm
NUM_:               0004 DEFINED AT LINE 33 IN MAIN.asm
                    > USED AT LINE 119 IN MAIN.asm
ID_:                0005 DEFINED AT LINE 34 IN MAIN.asm
                    > USED AT LINE 128 IN MAIN.asm
START:              0180 DEFINED AT LINE 37 IN MAIN.asm
                    > USED AT LINE 6
INIT:               0198 DEFINED AT LINE 44 IN MAIN.asm
                    > USED AT LINE 39 IN MAIN.asm
PARSE:              01BE DEFINED AT LINE 60 IN MAIN.asm
                    > USED AT LINE 42 IN MAIN.asm
STATEMENTLIST:      01E5 DEFINED AT LINE 66 IN MAIN.asm
                    > USED AT LINE 61 IN MAIN.asm
                    > USED AT LINE 73 IN MAIN.asm
STATEMENT:          0209 DEFINED AT LINE 77 IN MAIN.asm
                    > USED AT LINE 70 IN MAIN.asm
MATCH:              020A DEFINED AT LINE 80 IN MAIN.asm
                    > USED AT LINE 72 IN MAIN.asm
NEXTTOKEN:          0213 DEFINED AT LINE 89 IN MAIN.asm
                    > USED AT LINE 83 IN MAIN.asm
NEXTTOKEN1:         0221 DEFINED AT LINE 97 IN MAIN.asm
                    > USED AT LINE 103 IN MAIN.asm
NEXTTOKEN2:         022D DEFINED AT LINE 104 IN MAIN.asm
                    > USED AT LINE 99 IN MAIN.asm
                    > USED AT LINE 101 IN MAIN.asm
NEXTTOKEN3:         0231 DEFINED AT LINE 107 IN MAIN.asm
                    > USED AT LINE 96 IN MAIN.asm
NEXTTOKEN4:         0243 DEFINED AT LINE 117 IN MAIN.asm
                    > USED AT LINE 109 IN MAIN.asm
                    > USED AT LINE 111 IN MAIN.asm
                    > USED AT LINE 113 IN MAIN.asm
                    > USED AT LINE 115 IN MAIN.asm
NEXTTOKEN5:         024A DEFINED AT LINE 121 IN MAIN.asm
                    > USED AT LINE 116 IN MAIN.asm
NEXTTOKEN6:         0253 DEFINED AT LINE 126 IN MAIN.asm
                    > USED AT LINE 123 IN MAIN.asm
NEXTTOKEN7:         025A DEFINED AT LINE 130 IN MAIN.asm
                    > USED AT LINE 125 IN MAIN.asm
NEXTTOKEN1X:        025F DEFINED AT LINE 133 IN MAIN.asm
                    > USED AT LINE 93 IN MAIN.asm
                    > USED AT LINE 106 IN MAIN.asm
                    > USED AT LINE 120 IN MAIN.asm
                    > USED AT LINE 129 IN MAIN.asm
NUMBER:             0266 DEFINED AT LINE 138 IN MAIN.asm
                    > USED AT LINE 118 IN MAIN.asm
IDENT:              026A DEFINED AT LINE 146 IN MAIN.asm
                    > USED AT LINE 127 IN MAIN.asm
IDENT1:             026E DEFINED AT LINE 149 IN MAIN.asm
                    > USED AT LINE 154 IN MAIN.asm
                    > USED AT LINE 156 IN MAIN.asm
IDENT2:             027C DEFINED AT LINE 157 IN MAIN.asm
ISALPHANUM:         0289 DEFINED AT LINE 168 IN MAIN.asm
                    > USED AT LINE 155 IN MAIN.asm
ISALPHA:            0290 DEFINED AT LINE 175 IN MAIN.asm
                    > USED AT LINE 124 IN MAIN.asm
                    > USED AT LINE 169 IN MAIN.asm
ISALPHA1:           02A4 DEFINED AT LINE 186 IN MAIN.asm
                    > USED AT LINE 180 IN MAIN.asm
ISALPHA2:           02A6 DEFINED AT LINE 188 IN MAIN.asm
                    > USED AT LINE 178 IN MAIN.asm
                    > USED AT LINE 182 IN MAIN.asm
                    > USED AT LINE 184 IN MAIN.asm
ISNUMERIC:          02A8 DEFINED AT LINE 193 IN MAIN.asm
                    > USED AT LINE 171 IN MAIN.asm
ISNUMERIC1:         02B4 DEFINED AT LINE 200 IN MAIN.asm
                    > USED AT LINE 196 IN MAIN.asm
                    > USED AT LINE 198 IN MAIN.asm
NEXTCHAR:           02B6 DEFINED AT LINE 204 IN MAIN.asm
                    > USED AT LINE 91 IN MAIN.asm
                    > USED AT LINE 102 IN MAIN.asm
                    > USED AT LINE 152 IN MAIN.asm
                    > USED AT LINE 227 IN MAIN.asm
NEXTLINE:           02CA DEFINED AT LINE 229 IN MAIN.asm
                    > USED AT LINE 226 IN MAIN.asm
NEXTLINE2:          02D0 DEFINED AT LINE 232 IN MAIN.asm
                    > USED AT LINE 239 IN MAIN.asm
                    > USED AT LINE 247 IN MAIN.asm
                    > USED AT LINE 253 IN MAIN.asm
                    > USED AT LINE 257 IN MAIN.asm
NEXTLINE3:          02DE DEFINED AT LINE 241 IN MAIN.asm
                    > USED AT LINE 235 IN MAIN.asm
NEXTLINE4:          02FE DEFINED AT LINE 259 IN MAIN.asm
                    > USED AT LINE 243 IN MAIN.asm
                    > USED AT LINE 245 IN MAIN.asm
PROMPT:             030B DEFINED AT LINE 408 IN MAIN.asm
                    > USED AT LINE 230 IN MAIN.asm
CRLF:               0314 DEFINED AT LINE 413 IN MAIN.asm
                    > USED AT LINE 262 IN MAIN.asm
PRINTSTR:           031B DEFINED AT LINE 425 IN MAIN.asm
                    > USED AT LINE 40 IN MAIN.asm
                    > USED AT LINE 62 IN MAIN.asm
                    > USED AT LINE 255 IN MAIN.asm
                    > USED AT LINE 409 IN MAIN.asm
                    > USED AT LINE 414 IN MAIN.asm
ERROR:              0321 DEFINED AT LINE 431 IN MAIN.asm
                    > USED AT LINE 74 IN MAIN.asm
PUTSTR0:            0326 DEFINED AT LINE 436 IN MAIN.asm
                    > USED AT LINE 442 IN MAIN.asm
PUTSTR:             032A DEFINED AT LINE 439 IN MAIN.asm
                    > USED AT LINE 427 IN MAIN.asm
                    > USED AT LINE 433 IN MAIN.asm
RPUSH:              032F DEFINED AT LINE 445 IN MAIN.asm
RPOP:               033A DEFINED AT LINE 452 IN MAIN.asm
RPOP2:              0344 DEFINED AT LINE 457 IN MAIN.asm
PRINTDEC:           0345 DEFINED AT LINE 471 IN MAIN.asm
PRINTDEC2:          0354 DEFINED AT LINE 482 IN MAIN.asm
                    > USED AT LINE 473 IN MAIN.asm
PRINTDEC4:          0376 DEFINED AT LINE 498 IN MAIN.asm
                    > USED AT LINE 486 IN MAIN.asm
                    > USED AT LINE 488 IN MAIN.asm
                    > USED AT LINE 490 IN MAIN.asm
                    > USED AT LINE 492 IN MAIN.asm
                    > USED AT LINE 495 IN MAIN.asm
PRINTDEC5:          0378 DEFINED AT LINE 500 IN MAIN.asm
                    > USED AT LINE 503 IN MAIN.asm
PRINTDEC6:          0388 DEFINED AT LINE 512 IN MAIN.asm
                    > USED AT LINE 507 IN MAIN.asm
PRINTDEC7:          0389 DEFINED AT LINE 514 IN MAIN.asm
                    > USED AT LINE 511 IN MAIN.asm
RST08:              0800 DEFINED AT LINE 3 IN ram.asm
                    > USED AT LINE 118 IN IOSerial.asm
                    > USED AT LINE 458 IN IOSerial.asm
RST10:              0802 DEFINED AT LINE 4 IN ram.asm
                    > USED AT LINE 124 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
RST18:              0804 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 130 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
RST20:              0806 DEFINED AT LINE 6 IN ram.asm
                    > USED AT LINE 136 IN IOSerial.asm
                    > USED AT LINE 461 IN IOSerial.asm
RST28:              0808 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RST30:              080A DEFINED AT LINE 8 IN ram.asm
                    > USED AT LINE 148 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
BAUD:               080C DEFINED AT LINE 9 IN ram.asm
INTVEC:             080E DEFINED AT LINE 10 IN ram.asm
                    > USED AT LINE 154 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
NMIVEC:             0810 DEFINED AT LINE 11 IN ram.asm
                    > USED AT LINE 202 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
GETCVEC:            0812 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 446 IN IOSerial.asm
                    > USED AT LINE 468 IN IOSerial.asm
PUTCVEC:            0814 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
VTEMP1:             0816 DEFINED AT LINE 15 IN ram.asm
VTEMP2:             0818 DEFINED AT LINE 16 IN ram.asm
VTOKEN:             081A DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 46 IN MAIN.asm
                    > USED AT LINE 67 IN MAIN.asm
                    > USED AT LINE 134 IN MAIN.asm
VTOKPTR:            081C DEFINED AT LINE 19 IN ram.asm
                    > USED AT LINE 53 IN MAIN.asm
                    > USED AT LINE 135 IN MAIN.asm
VCHARPTR:           081E DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 48 IN MAIN.asm
                    > USED AT LINE 220 IN MAIN.asm
                    > USED AT LINE 223 IN MAIN.asm
                    > USED AT LINE 264 IN MAIN.asm
VASMPTR:            0820 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 50 IN MAIN.asm
VSTRPTR:            0822 DEFINED AT LINE 22 IN ram.asm
                    > USED AT LINE 52 IN MAIN.asm
                    > USED AT LINE 147 IN MAIN.asm
                    > USED AT LINE 158 IN MAIN.asm
                    > USED AT LINE 159 IN MAIN.asm
VSYMPTR:            0824 DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 55 IN MAIN.asm
VEXPRPTR:           0826 DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 57 IN MAIN.asm
CHARS:              0828 DEFINED AT LINE 26 IN ram.asm
                    > USED AT LINE 47 IN MAIN.asm
                    > USED AT LINE 231 IN MAIN.asm
                    > USED AT LINE 248 IN MAIN.asm
                    > USED AT LINE 263 IN MAIN.asm
STACK:              0A28 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 456 IN IOSerial.asm
                    > USED AT LINE 38 IN MAIN.asm
STRINGS:            0A28 DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 51 IN MAIN.asm
SYMBOLS:            0B28 DEFINED AT LINE 31 IN ram.asm
                    > USED AT LINE 54 IN MAIN.asm
EXPRS:              0C28 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 56 IN MAIN.asm
ASSEMBLY:           0D28 DEFINED AT LINE 34 IN ram.asm
                    > USED AT LINE 49 IN MAIN.asm
