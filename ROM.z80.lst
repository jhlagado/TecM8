0000                          .ENGINE   mycomputer   
0000                             ; 
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $3000   
0000                ROMSIZE:   EQU   $3000   
0000                RAMSIZE:   EQU   $0800   
0000                EOF:      EQU   -1   
0000                NULL:     EQU   0   
0000                CTRL_C:   EQU   3   
0000                CTRL_H:   EQU   8   
0000                ESC:      EQU   27   
0000                NO_MATCH:   EQU   -1   
0000                BUFFER_SIZE:   EQU   $80   
0000                STRS_SIZE:   EQU   $100   
0000                SYMS_SIZE:   EQU   $100   
0000                EXPRS_SIZE:   EQU   $100   
0000                TOKENS:      
0000                COLON_:   EQU   ":"   
0000                COMMA_:   EQU   ","   
0000                DIRECT_:   EQU   "D"   
0000                DOLLAR_:   EQU   "$"   
0000                EOF_:     EQU   "E"   
0000                IDENT_:   EQU   "I"   
0000                LABEL_:   EQU   "L"   
0000                LPAREN_:   EQU   "("   
0000                NEWLN_:   EQU   "\n"   
0000                NUM_:     EQU   "9"   
0000                OPCODE_:   EQU   "C"   
0000                OPELEM_:   EQU   "M"   ; op element: reg, rp, flag
0000                RPAREN_:   EQU   ")"   
0000                UNKNOWN_:   EQU   "U"   
0000                ALU_:     EQU   0x00   
0000                ROT_:     EQU   0x20   
0000                BLI_:     EQU   0x40   
0000                GEN1_:    EQU   0x60   
0000                GEN2_:    EQU   0x80   
0000                ALU_IDX:      
0000                ADD_:     EQU   0 | alu_   
0000                ADC_:     EQU   1 | alu_   
0000                SUB_:     EQU   2 | alu_   
0000                SBC_:     EQU   3 | alu_   
0000                AND_:     EQU   4 | alu_   
0000                XOR_:     EQU   5 | alu_   
0000                OR_:      EQU   6 | alu_   
0000                CP_:      EQU   7 | alu_   
0000                ROT_IDX:      
0000                RLC_:     EQU   0 | rot_   
0000                RRC_:     EQU   1 | rot_   
0000                RL_:      EQU   2 | rot_   
0000                RR_:      EQU   3 | rot_   
0000                SLA_:     EQU   4 | rot_   
0000                SRA_:     EQU   5 | rot_   
0000                SLL_:     EQU   6 | rot_   
0000                SRL_:     EQU   7 | rot_   
0000                BLI_IDX:      
0000                LDI_:     EQU   00 | bli_   
0000                CPI_:     EQU   01 | bli_   
0000                INI_:     EQU   02 | bli_   
0000                OUTI_:    EQU   03 | bli_   
0000                LDD_:     EQU   04 | bli_   
0000                CPD_:     EQU   05 | bli_   
0000                IND_:     EQU   06 | bli_   
0000                OUTD_:    EQU   07 | bli_   
0000                LDIR_:    EQU   08 | bli_   
0000                CPIR_:    EQU   09 | bli_   
0000                INIR_:    EQU   10 | bli_   
0000                OTIR_:    EQU   11 | bli_   
0000                LDDR_:    EQU   12 | bli_   
0000                CPDR_:    EQU   13 | bli_   
0000                INDR_:    EQU   14 | bli_   
0000                OTDR_:    EQU   15 | bli_   
0000                GEN1_IDX:      
0000                CCF_:     EQU   00 | gen1_   
0000                CPL_:     EQU   01 | gen1_   
0000                DAA_:     EQU   02 | gen1_   
0000                DI_:      EQU   03 | gen1_   
0000                EI_:      EQU   04 | gen1_   
0000                HALT_:    EQU   05 | gen1_   
0000                NOP_:     EQU   06 | gen1_   
0000                RLCA_:    EQU   07 | gen1_   
0000                RST_:     EQU   08 | gen2_   
0000                SCF_:     EQU   09 | gen1_   
0000                GEN2_IDX:      
0000                BIT_:     EQU   00 | gen2_   
0000                CALL_:    EQU   01 | gen2_   
0000                DEC_:     EQU   02 | gen2_   
0000                DJNZ_:    EQU   03 | gen2_   
0000                EX_:      EQU   04 | gen2_   
0000                EXX_:     EQU   05 | gen2_   
0000                IM_:      EQU   06 | gen2_   
0000                IN_:      EQU   07 | gen2_   
0000                INC_:     EQU   08 | gen2_   
0000                JP_:      EQU   09 | gen2_   
0000                JR_:      EQU   10 | gen2_   
0000                LD_:      EQU   11 | gen2_   
0000                NEG_:     EQU   12 | gen2_   
0000                OUT_:     EQU   13 | gen2_   
0000                POP_:     EQU   14 | gen2_   
0000                PUSH_:    EQU   15 | gen2_   
0000                RES_:     EQU   16 | gen2_   
0000                RET_:     EQU   17 | gen2_   
0000                RETI_:    EQU   18 | gen2_   
0000                RETN_:    EQU   19 | gen2_   
0000                RLA_:     EQU   20 | gen2_   
0000                RLD_:     EQU   21 | gen2_   
0000                RRA_:     EQU   22 | gen2_   
0000                RRCA_:    EQU   23 | gen2_   
0000                RRD_:     EQU   24 | gen2_   
0000                SET_:     EQU   25 | gen2_   
0000                REG_:     EQU   0x00   ; A, B etc
0000                RP_:      EQU   0x08   ; bit 3: register pair e.g. HL, DE
0000                FLAG_:    EQU   0x10   ; bit 4: flag NZ etc
0000                IMMED_:   EQU   0x20   ; bit 5: immediate 0xff or 0xffff
0000                MEM_:     EQU   0x40   ; bit 6: memory ref (HL) or (0xffff)
0000                IDX_:     EQU   0x80   ; bit 7: indexed (IX+dd)
0000                REG8_IDX:      ; 8-bit registers
0000                B_:       EQU   0   ; B
0000                C_:       EQU   1   ; C
0000                D_:       EQU   2   ; D
0000                E_:       EQU   3   ; E
0000                H_:       EQU   4   ; H
0000                L_:       EQU   5   ; L
0000                MHL_:     EQU   6   ; (HL)
0000                A_:       EQU   7   ; A
0000                I_:       EQU   8   ; I
0000                R_:       EQU   9   ; R
0000                REG16_IDX:      ; 16-bit registers
0000                BC_:      EQU   0 | rp_   
0000                DE_:      EQU   1 | rp_   
0000                HL_:      EQU   2 | rp_   
0000                SP_:      EQU   3 | rp_   
0000                IX_:      EQU   5 | rp_   
0000                IY_:      EQU   6 | rp_   
0000                AFP_:     EQU   4 | rp_   ; AF' (prime)
0000                AF_:      EQU   7 | rp_   ; NOTE: AF has the same code as SP in some instructions
0000                FLAG_IDX:      
0000                NZ_:      EQU   0 | flag_   
0000                Z_:       EQU   1 | flag_   
0000                NC_:      EQU   2 | flag_   
0000                C_:       EQU   3 | flag_   
0000                PO_:      EQU   4 | flag_   
0000                PE_:      EQU   5 | flag_   
0000                P_:       EQU   6 | flag_   
0000                M_:       EQU   7 | flag_   
0000                DIRECTIVE_IDX:      
0000                ALIGN_:   EQU   0   
0000                DB_:      EQU   1   
0000                ORG_:     EQU   2   
0000                SET_:     EQU   3   
0000                             ; -----------------------------------------------------------------------------------------------
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                             ; *************************************************************************
0000                             ; 
0000                             ;       Serial routines 
0000                             ; 
0000                             ;       written by Craig Jones 
0000                             ; 
0000                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
0000                             ; 
0000                             ;       see the LICENSE file in this repo for more information 
0000                             ; 
0000                             ; *****************************************************************************
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8D 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 98 34               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 9A 34               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 9C 34               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A 9E 34               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A A0 34               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A A2 34               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A A6 34               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A A8 34               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   E5                     PUSH   HL   
0082   2A AA 34               LD   HL,(GETCVEC)   
0085   E3                     EX   (SP),HL   
0086   C9                     RET      
0087                             ; 
0087                PUTCHAR:      
0087   E5                     PUSH   HL   
0088   2A AC 34               LD   HL,(PUTCVEC)   
008B   E3                     EX   (SP),HL   
008C   C9                     RET      
008D                             ; 
008D                RESET:       
008D   31 80 31               LD   SP,stack   
0090   21 5F 00               LD   HL,IntRet   
0093   22 98 34               LD   (RST08),HL   
0096   22 9A 34               LD   (RST10),HL   
0099   22 9C 34               LD   (RST18),HL   
009C   22 9E 34               LD   (RST20),HL   
009F   22 A0 34               LD   (RST28),HL   
00A2   22 A2 34               LD   (RST30),HL   
00A5   22 A6 34               LD   (INTVEC),HL   
00A8   22 A8 34               LD   (NMIVEC),HL   
00AB                             ; 
00AB   21 78 00               LD   HL,RXDATA   
00AE   22 AA 34               LD   (GETCVEC),HL   
00B1   21 6B 00               LD   HL,TXDATA   
00B4   22 AC 34               LD   (PUTCVEC),HL   
00B7                             ; 
00B7                          IF   TEC_1   
00B7                          IF   BITBANG = 0   
00B7                             ; 
00B7   3E 03                  LD   a,MRESET   
00B9   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00BB                             ; 
00BB                          ENDIF      
00BB                          ENDIF      
00BB                             ; 
00BB   CD 50 00               CALL   PWRUP   
00BE   ED 56                  IM   1   
00C0   FB                     EI      
00C1                             ; 
00C1                          IF   TEC_1   
00C1                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00C1                          ELSE      ;6850      
00C1                             ; 
00C1   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C3   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C5                             ; 
00C5                          ENDIF      
00C5                          ENDIF      
00C5                             ; 
00C5                             ; 
00C5                             ; 
00C5   C3 80 01               JP   start   
00C8                             ; 
00C8                             ; *************************************************************************
00C8                             ; 
00C8                             ;       TecM8 1.0 Assembler for the Tec-1
00C8                             ; 
00C8                             ;       by John Hardy
00C8                             ; 
00C8                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
00C8                             ; 
00C8                             ;       see the LICENSE file in this repo for more information
00C8                             ; 
00C8                             ; *****************************************************************************
00C8                             ; **************************************************************************
00C8                             ; Page 0  Initialisation
00C8                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put TecM8 code from here	
0180                             ; *****************************************************************************
0180                             ; Routine: start
0180                             ; 
0180                             ; Purpose:
0180                             ;    Entry point of TecM8. Initializes the STACK pointer, calls the initialization
0180                             ;    routine, prints TecM8 version information, and jumps to the parsing routine.
0180                             ; 
0180                             ; Inputs:
0180                             ;    None
0180                             ; 
0180                             ; Outputs:
0180                             ;    None
0180                             ; 
0180                             ; Registers Destroyed:
0180                             ;    A, HL
0180                             ; *****************************************************************************
0180                START:       
0180   31 80 31               LD   sp,STACK   ; Initialize STACK pointer
0183   CD 98 01               CALL   init   ; Call initialization routine
0186   CD 52 05               CALL   print   ; Print TecM8 version information
0189   54 65 63 4D 38 20 30 2E 30 0D 0A 00 .CSTR   "TecM8 0.0\r\n"   
0195   C3 C0 01               JP   parse   ; Jump to the parsing routine
0198                             ; *****************************************************************************
0198                             ; Routine: init
0198                             ; 
0198                             ; Purpose:
0198                             ;    Initializes various pointers and variables used by TecM8.
0198                             ; 
0198                             ; Inputs:
0198                             ;    None
0198                             ; 
0198                             ; Outputs:
0198                             ;    None
0198                             ; 
0198                             ; Registers Destroyed:
0198                             ;    A, HL
0198                             ; *****************************************************************************
0198                INIT:        
0198   AF                     XOR   a   ; Clear A register
0199   32 84 31               LD   (vToken),a   ; Initialize vToken with NUL_ token
019C   32 87 31               LD   (vBufferPos),a   ; Initialize BUFFER position
019F   3E 0A                  LD   a,"\n"   ; put new line into first char of buffer
01A1   32 00 30               LD   (BUFFER),a   ; 
01A4   21 AE 34               LD   hl,ASSEMBLY   ; Load ASSEMBLY pointer
01A7   22 89 31               LD   (vAsmPtr),hl   ; Store in vAsmPtr
01AA   21 98 31               LD   hl,STRINGS   ; Load STRINGS pointer
01AD   22 8B 31               LD   (vStrPtr),hl   ; Store in vStrPtr
01B0   22 85 31               LD   (vTokenVal),hl   ; Initialize token value pointer
01B3   21 98 32               LD   hl,SYMBOLS   ; Load SYMBOLS pointer
01B6   22 8D 31               LD   (vSymPtr),hl   ; Store in vSymPtr
01B9   21 98 33               LD   hl,EXPRS   ; Load expressions pointer
01BC   22 8F 31               LD   (vExprPtr),hl   ; Store in vExprPtr
01BF   C9                     RET      ; Return
01C0                             ; *****************************************************************************
01C0                             ; Routine: parse
01C0                             ; 
01C0                             ; Purpose:
01C0                             ;    Parses the input program, calling the statementList routine, printing the
01C0                             ;    completion message, and halting the system.
01C0                             ; 
01C0                             ; Inputs:
01C0                             ;    None
01C0                             ; 
01C0                             ; Outputs:
01C0                             ;    None
01C0                             ; 
01C0                             ; Registers Destroyed:
01C0                             ;    None
01C0                             ; *****************************************************************************
01C0                PARSE:       
01C0   CD FA 01               CALL   statementList   ; Parse the input program
01C3   CD 52 05               CALL   print   ; Print completion message
01C6   50 61 72 73 69 6E 67 20 63 6F 6D 70 6C 65 74 65 64 20 73 75 63 63 65 73 73 66 75 6C 6C 79 2E 00 .CSTR   "Parsing completed successfully."   
01E6   76                     HALT      
01E7                PARSEERROR:      
01E7   55 6E 65 78 70 65 63 74 65 64 20 74 6F 6B 65 6E 2E 00 .CSTR   "Unexpected token."   
01F9   76                     HALT      
01FA                             ; *****************************************************************************
01FA                             ; Routine: statementList
01FA                             ; 
01FA                             ; Purpose:
01FA                             ;    Parses a list of statements, repeatedly calling the statement routine until
01FA                             ;    the end of file (EOF) token is encountered.
01FA                             ; 
01FA                             ; Inputs:
01FA                             ;    None
01FA                             ; 
01FA                             ; Outputs:
01FA                             ;    None
01FA                             ; 
01FA                             ; Registers Destroyed:
01FA                             ;    A
01FA                             ; *****************************************************************************
01FA                STATEMENTLIST:      
01FA   CD 97 02               CALL   nextToken   ; Get the next token
01FD   CD 0A 02               CALL   statement   ; Parse a statement
0200   CD BF 03               CALL   isEndOfLine   
0203   20 E2                  JR   nz,parseError   
0205   FE 45                  CP   EOF_   ; Check if it's the end of file
0207   C8                     RET   z   ; If yes, return
0208   18 F0                  JR   statementList   ; Repeat for the next statement
020A                             ; *****************************************************************************
020A                             ; Routine: statement
020A                             ; 
020A                             ; Purpose:
020A                             ;    Parses a single statement, checking its type (label, opcode, or directive)
020A                             ;    and performing corresponding actions.
020A                             ; 
020A                             ; Inputs:
020A                             ;    None
020A                             ; 
020A                             ; Outputs:
020A                             ;    None
020A                             ; 
020A                             ; Registers Destroyed:
020A                             ;    A
020A                             ; *****************************************************************************
020A                STATEMENT:      
020A   F5                     PUSH   af   ; save token
020B   3E FF                  LD   a,-1   
020D   32 91 31               LD   (vOpcode),a   
0210   32 92 31               LD   (vOperand1),a   
0213   32 93 31               LD   (vOperand2),a   
0216   AF                     XOR   a   
0217   32 94 31               LD   (vOpExpr),a   
021A   32 96 31               LD   (vOpDisp),a   
021D   F1                     POP   af   ; restore token
021E   CD BF 03               CALL   isEndOfLine   
0221   C8                     RET   z   
0222   FE 4C                  CP   LABEL_   ; Check if it's a label
0224   20 0A                  JR   nz,statement1   ; If not, jump to statement10
0226   ED 5B 89 31            LD   de,(vAsmPtr)   ; hl = name, de = value
022A   CD 95 02               CALL   newSymbol   ; Add label to symbol table
022D   CD 97 02               CALL   nextToken   ; Get the next token
0230                STATEMENT1:      
0230   FE 43                  CP   OPCODE_   ; Check if it's an opcode
0232   28 05                  JR   z,instruction   ; Jump to parseInstruction routine
0234   FE 44                  CP   DIRECT_   ; Check if it's a directive
0236   28 1E                  JR   z,directive   
0238   C9                     RET      
0239                INSTRUCTION:      
0239   7D                     LD   a,l   
023A   32 91 31               LD   (vOpcode),a   
023D   CD 97 02               CALL   nextToken   
0240   CD 57 02               CALL   operand   
0243   32 92 31               LD   (vOperand1),a   
0246   CD 97 02               CALL   nextToken   
0249   FE 2C                  CP   COMMA_   
024B   C0                     RET   nz   
024C   CD 97 02               CALL   nextToken   
024F   CD 57 02               CALL   operand   
0252   32 93 31               LD   (vOperand2),a   
0255   C9                     RET      
0256                DIRECTIVE:      
0256   C9                     RET      
0257                             ; *****************************************************************************
0257                             ; Routine: operand
0257                             ; 
0257                             ; Purpose:
0257                             ;    Parses and identifies different types of operands (registers, memory,
0257                             ;    immediate values, etc.) used in assembly instructions. Sets the appropriate
0257                             ;    flags based on the operand type.
0257                             ; 
0257                             ; Inputs:
0257                             ;    None (uses the current token from a token stream)
0257                             ; 
0257                             ; Outputs:
0257                             ;    A  - Contains the code indicating the type of operand identified.
0257                             ;    DE - May point to a value or expression depending on the operand type.
0257                             ; 
0257                             ; Registers Destroyed:
0257                             ;    A, DE, HL
0257                             ; Define operand codes for readability and use in the operand routine.
0257                             ; 
0257                             ; reg_    .equ    0x00        ; A, B etc
0257                             ; rp_     .equ    0x08        ; bit 3: register pair e.g. HL, DE
0257                             ; flag_   .equ    0x10        ; bit 4: flag NZ etc
0257                             ; immed_  .equ    0x20        ; bit 5: immediate 0xff or 0xffff
0257                             ; mem_    .equ    0x40        ; bit 6: memory ref (HL) or (0xffff)
0257                             ; idx_    .equ    0x80        ; bit 7: indexed (IX+dd)
0257                             ; *****************************************************************************
0257                OPERAND:      
0257   FE 4D                  CP   OPELEM_   ; Check if the token is an op element i.e. reg, rp or flag
0259   C8                     RET   z   ; Return if it is
025A   FE 28                  CP   LPAREN_   ; Check if the token is a left parenthesis
025C   28 09                  JR   z,operand1   ; If so, handle as a memory reference
025E   CD 96 02               CALL   newExpr   ; Otherwise, treat as an expression
0261   22 94 31               LD   (vOpExpr),hl   ; Store the result of the operand expression
0264   3E 20                  LD   a,immed_   ; Set A to indicate an immediate value
0266   C9                     RET      
0267                OPERAND1:      
0267   CD 97 02               CALL   nextToken   ; Memory reference. Get the next token
026A   FE 4D                  CP   OPELEM_   ; Check if the next token is an op element
026C   20 14                  JR   nz,operand2   ; If not, handle as an expression inside parentheses
026E   7D                     LD   a,l   ; Otherwise, Load A with the lower byte of HL (operand)
026F   CD B9 03               CALL   isIndexReg   
0272   20 18                  JR   nz,operand4   
0274   F5                     PUSH   af   ; Save HL on the stack
0275   CD 96 02               CALL   newExpr   ; Treat as an expression
0278   22 96 31               LD   (vOpDisp),hl   ; Store the result of the expression
027B   F1                     POP   af   ; Restore HL from the stack
027C   CB FF                  SET   7,a   ; Set A to indicate an indexed memory reference
027E                OPERAND3:      
027E   CB F7                  SET   6,a   ; Otherwise, set A to indicate a memory reference
0280   18 0A                  JR   operand4   
0282                OPERAND2:      
0282   CD 96 02               CALL   newExpr   ; Treat as a new expression
0285   22 94 31               LD   (vOpExpr),hl   ; Store the result of the expression
0288   3E 60                  LD   a,immed_ | mem_   ; Set A to indicate an immediate memory reference
028A   18 00                  JR   operand4   
028C                OPERAND4:      
028C   CD 97 02               CALL   nextToken   ; Get the next token
028F   FE 29                  CP   RPAREN_   ; Check if the next token is a right parenthesis
0291   C2 E7 01               JP   nz,parseError   ; If not, handle as a parse error
0294   C9                     RET      
0295                NEWSYMBOL:      
0295                             ; hl is string
0295                             ; asmPtr is the value
0295   C9                     RET      
0296                NEWEXPR:      
0296                             ; gather tokens in array
0296                             ; return pointer in hl
0296   C9                     RET      
0297                             ; nextToken is a lexer function that reads characters from the input and classifies
0297                             ; them into different token types. It handles whitespace, end of input, newlines,
0297                             ; comments, identifiers, labels, directives, hexadecimal numbers, and other SYMBOLS.
0297                             ; Input: None
0297                             ; Output:
0297                             ; a: contains the type of the next token.
0297                             ; hl: contains the value associated with the next token.
0297                             ; Destroyed: None
0297                             ; *****************************************************************************
0297                             ; Routine: nextToken
0297                             ; 
0297                             ; Purpose:
0297                             ;    Parses the next token from the input stream, identifying various types of
0297                             ;    tokens such as identifiers, labels, opcodes, registers, flags, numbers,
0297                             ;    and special characters.
0297                             ; 
0297                             ; Inputs:
0297                             ;    None
0297                             ; 
0297                             ; Outputs:
0297                             ;    A - Token representing the type of the parsed element
0297                             ; 
0297                             ; Registers Destroyed:
0297                             ;    A, BC, DE, HL
0297                             ; *****************************************************************************
0297                NEXTTOKEN:      
0297   CB 77                  BIT   7,(vToken)   ; Check the high bit of the pushback BUFFER
0299   CA A8 02               JP   z,nextToken0   ; If high bit clear, nothing pushed back
029C   3A 84 31               LD   a,(vToken)   ; If high bit set, load the pushed back token type into A
029F   2A 85 31               LD   hl,(vTokenVal)   ; and token value into HL
02A2   CB BF                  RES   7,a   ; Clear the high bit
02A4   32 84 31               LD   (vToken),a   ; Store the character back in the BUFFER
02A7   C9                     RET      ; Return with the pushed back character in A
02A8                NEXTTOKEN0:      
02A8   21 00 00               LD   hl,0   ; Initialize HL with 0
02AB                NEXTTOKEN1:      
02AB   CD CF 04               CALL   nextChar   ; Get the next character
02AE   FE 20                  CP   " "   ; is it space?
02B0   28 F9                  JR   z,nextToken1   ; If yes, skip it and get the next character
02B2   FE FF                  CP   EOF   ; Is it null (end of input)?
02B4   20 03                  JR   nz,nextToken2   ; If not, continue to the next check
02B6                NEXTTOKEN1A:      
02B6   3E 45                  LD   a,EOF_   ; If yes, return with EOF token
02B8   C9                     RET      
02B9                NEXTTOKEN2:      
02B9   FE 5C                  CP   $5C   ; Is it a statement separator? "\"
02BB   20 0B                  JR   nz,nextToken3   ; If not, continue to the next check
02BD   FE 3A                  CP   ":"   ; Is it a statement separator? ":"
02BF   20 07                  JR   nz,nextToken3   ; If not, continue to the next check
02C1   FE 0A                  CP   "\n"   ; Is it a new line
02C3   30 03                  JR   nc,nextToken3   ; If not, continue to the next check
02C5   3E 0A                  LD   a,NEWLN_   ; If yes, return with NEWLIN token
02C7   C9                     RET      ; Return with newline token
02C8                NEXTTOKEN3:      
02C8   FE 3B                  CP   ";"   ; Is it a comment?
02CA   C4 D9 02               CALL   nz,nextToken5   ; If not, continue to the next check
02CD                NEXTTOKEN4:      
02CD   CD CF 04               CALL   nextChar   ; Get the next character in the comment
02D0   FE 21                  CP   " "+1   ; Loop until the next control character
02D2   30 F9                  JR   nc,nextToken4   
02D4   CD 35 05               CALL   rewindChar   ; Push back the character
02D7   18 CF                  JR   nextToken0   ; return with control char
02D9                NEXTTOKEN5:      
02D9   FE 5F                  CP   "_"   ; Is it an identifier?
02DB   28 05                  JR   z,nextToken6   ; If yes, continue to the next check
02DD   CD C9 03               CALL   isAlpha   ; If not, check if it's alphabetic
02E0   30 37                  JR   nc,nextToken11   ; If not, continue to the next check
02E2                NEXTTOKEN6:      
02E2   CD 58 03               CALL   ident   ; Parse the identifier
02E5   FE 3A                  CP   ":"   ; Is it a label?
02E7   20 03                  JR   nz,nextToken7   ; If not, continue to the next check
02E9   3E 4C                  LD   a,LABEL_   ; If yes, return A = LABEL HL = string
02EB   C9                     RET      
02EC                NEXTTOKEN7:      
02EC   CD 35 05               CALL   rewindChar   ; Push back the character
02EF   22 8B 31               LD   (vStrPtr),hl   ; Restore string heap pointer to previous location
02F2   CD 7E 04               CALL   searchOpcode   
02F5   30 06                  JR   nc,nextToken8   
02F7   6F                     LD   l,a   ; hl = opcode value
02F8   26 00                  LD   h,0   
02FA   3E 43                  LD   a,OPCODE_   ; Return with OPCODE token
02FC   C9                     RET      
02FD                NEXTTOKEN8:      
02FD   CD AB 04               CALL   searchOpElem   
0300   30 06                  JR   nc,nextToken9   
0302   6F                     LD   l,a   ; hl = op element value
0303   26 00                  LD   h,0   
0305   3E 4D                  LD   a,OPELEM_   ; Return with OPELEM token
0307   C9                     RET      
0308                NEXTTOKEN9:      
0308   11 D0 06               LD   de,directives   ; List of directives to search
030B   CD 5B 04               CALL   searchStr   
030E   30 06                  JR   nc,nextToken10   
0310   6F                     LD   l,a   ; hl = directive value
0311   26 00                  LD   h,0   
0313   3E 44                  LD   a,DIRECT_   ; Return with DIRECT token
0315   C9                     RET      
0316                NEXTTOKEN10:      
0316   3E 49                  LD   a,IDENT_   ; Return with IDENT token
0318   C9                     RET      
0319                NEXTTOKEN11:      
0319   21 00 00               LD   hl,0   
031C   FE 24                  CP   "$"   ; Is it a hexadecimal number?
031E   20 14                  JR   nz,nextToken12   ; If not, continue to the next check
0320   CD CF 04               CALL   nextChar   ; Get the next character
0323   CD C5 03               CALL   isAlphaNum   ; Check if it's the ASSEMBLY pointer
0326   20 06                  JR   nz,nextToken11a   ; If not, continue to the next check
0328   CD 09 04               CALL   number_hex   ; Process hexadecimal number
032B   3E 39                  LD   a,NUM_   ; Return with NUM token
032D   C9                     RET      
032E                NEXTTOKEN11A:      
032E   CD 35 05               CALL   rewindChar   ; Push back the character (flags unaffected)
0331   3E 24                  LD   a,DOLLAR_   ; Return with DOLLAR token
0333   C9                     RET      ; Return with the DOLLAR token
0334                NEXTTOKEN12:      
0334   FE 2D                  CP   "-"   ; Is it a negative number?
0336   28 05                  JR   z,nextToken13   ; If yes, continue to the next check
0338   CD D6 03               CALL   isDigit   ; Check if it's a digit
033B   30 06                  JR   nc,nextToken15   ; Jump to the next check
033D                NEXTTOKEN13:      
033D   CD DD 03               CALL   number   ; Parse the number
0340                NEXTTOKEN14:      
0340   3E 39                  LD   a,NUM_   ; Return with NUM token
0342   C9                     RET      
0343                NEXTTOKEN15:      
0343   FE 28                  CP   "("   
0345   C8                     RET   z   ; Return with the LPAREN token
0346   FE 29                  CP   ")"   
0348   C8                     RET   z   ; Return with the RPAREN token
0349   FE 2C                  CP   ","   
034B   C8                     RET   z   ; Return with the COMMA token
034C   3E 55                  LD   a,UNKNOWN_   ; Return with UNKNOWN token
034E   C9                     RET      
034F                             ; *****************************************************************************
034F                             ; Routine: pushBackToken
034F                             ; 
034F                             ; Purpose:
034F                             ;    Pushes back a token into the pushback BUFFER to allow the token to be
034F                             ;    re-read by the nextToken routine.
034F                             ; 
034F                             ; Inputs:
034F                             ;    A  - token type
034F                             ;    HL - token value
034F                             ; 
034F                             ; Outputs:
034F                             ;    None
034F                             ; 
034F                             ; Registers Destroyed:
034F                             ;    A, DE
034F                             ; *****************************************************************************
034F                PUSHBACKTOKEN:      
034F   CB FF                  SET   7,a   ; Set the high bit of the token type (without affecting flags)
0351   32 84 31               LD   (vToken),a   ; push back the token
0354   22 85 31               LD   (vTokenVal),hl   ; push back the token value
0357   C9                     RET      
0358                             ; *****************************************************************************
0358                             ; Routine: ident
0358                             ; 
0358                             ; Purpose:
0358                             ;    Reads characters from the input stream until a charcter which is not an
0358                             ;    an underscore or an alphanumeric character is encountered. Writes the chars
0358                             ;    to a Pascal string and updates the top of the STRINGS heap pointer.
0358                             ;    It also calculates the length of the string and stores it at the beginning
0358                             ;    of the string.
0358                             ; 
0358                             ; Inputs:
0358                             ;    A - Current character read from the input stream
0358                             ;    vStrPtr - Address of the top of STRINGS heap pointer
0358                             ; 
0358                             ; Outputs:
0358                             ;    A - last character read from the input stream
0358                             ;    HL - identifier string
0358                             ; 
0358                             ; Registers Destroyed:
0358                             ;    DE, HL
0358                             ; *****************************************************************************
0358                IDENT:       
0358   2A 8B 31               LD   hl,(vStrPtr)   ; Load the address of the top of STRINGS heap
035B   E5                     PUSH   hl   ; save start of string
035C   23                     INC   hl   ; Move to the next byte to skip the length byte
035D                IDENT1:      
035D   77                     LD   (hl),a   ; Write the current character to the string BUFFER
035E   23                     INC   hl   ; Move to the next position in the BUFFER
035F   E5                     PUSH   hl   
0360   CD CF 04               CALL   nextChar   ; Get the next character from the input stream
0363   E1                     POP   hl   
0364   FE 5F                  CP   "_"   ; Compare with underscore character
0366   28 F5                  JR   z,ident1   ; If underscore, jump to ident2
0368   CD C5 03               CALL   isAlphanum   ; Check if the character is alphanumeric
036B   38 F0                  JR   c,ident1   ; If not alphanumeric, jump to ident3
036D                IDENT3:      
036D   22 8B 31               LD   (vStrPtr),hl   ; Update the top of STRINGS heap pointer
0370   D1                     POP   de   ; restore start of string into de
0371   B7                     OR   a   ; Clear carry
0372   ED 52                  SBC   hl,de   ; Calculate the length of the string (HL = length, DE = string)
0374   2D                     DEC   l   ; reduce by one (length byte)
0375   EB                     EX   de,hl   ; Swap DE and HL (E = length, HL = string)
0376   73                     LD   (hl),e   ; Store the length at the beginning of the string BUFFER
0377   C9                     RET      
0378                             ; *****************************************************************************
0378                             ; Routine: expr
0378                             ; 
0378                             ; Purpose:
0378                             ;    Collects a string until it reaches a right parenthesis, comma, semicolon,
0378                             ;    or newline character. Keeps track of parentheses to ensure correct ending
0378                             ;    of the expression.
0378                             ; 
0378                             ; Inputs:
0378                             ;    None
0378                             ; 
0378                             ; Outputs:
0378                             ;    HL - Points to the collected string.
0378                             ;    A - Contains the length of the collected string.
0378                             ; 
0378                             ; Registers Destroyed:
0378                             ;    A, C, D, E, HL
0378                             ; *****************************************************************************
0378                EXPR:        
0378   2A 8B 31               LD   hl,(vStrPtr)   ; Load the address of the top of STRINGS heap
037B   54 5D                  LD   de,hl   ; Copy it to DE (DE = HL = top of STRINGS heap)
037D   23                     INC   hl   ; Move to the next byte to skip the length byte
037E   0E 01                  LD   c,1   ; Initialize parenthesis count to 1
0380                EXPR1:       
0380   77                     LD   (hl),a   ; Write the current character to the string BUFFER
0381   23                     INC   hl   ; Move to the next position in the BUFFER
0382   CD CF 04               CALL   nextChar   ; Get the next character from the input stream
0385   FE 28                  CP   "("   ; Compare with left parenthesis character
0387   28 17                  JR   z,expr2   ; If left parenthesis, increase count
0389   FE 29                  CP   ")"   ; Compare with right parenthesis character
038B   28 16                  JR   z,expr3   ; If right parenthesis, decrease count
038D   FE 2C                  CP   ","   ; Compare with comma character
038F   28 17                  JR   z,expr4   ; If comma, check if parentheses count is zero
0391   FE 3B                  CP   ";"   ; Compare with semicolon character
0393   28 13                  JR   z,expr4   ; If semicolon, check if parentheses count is zero
0395   FE 0A                  CP   "\n"   ; Compare with newline character
0397   28 0F                  JR   z,expr4   ; If newline, check if parentheses count is zero
0399   CD C5 03               CALL   isAlphanum   ; Check if the character is alphanumeric
039C   30 0A                  JR   nc,expr4   ; If not alphanumeric, check if parentheses count is zero
039E   18 E0                  JR   expr1   ; Repeat the process
03A0                EXPR2:       
03A0   0C                     INC   c   ; Increase parentheses count
03A1   18 DD                  JR   expr1   ; Repeat the process
03A3                EXPR3:       
03A3   0D                     DEC   c   ; Decrease parentheses count
03A4   20 DA                  JR   nz,expr1   ; If not zero, continue collecting
03A6   18 04                  JR   expr5   ; If zero, end collection
03A8                EXPR4:       
03A8   AF                     XOR   a   
03A9   B9                     CP   c   ; Check if parentheses count is zero
03AA   20 D4                  JR   nz,expr1   ; If not zero, continue collecting
03AC                EXPR5:       
03AC   CD 35 05               CALL   rewindChar   ; Rewind the input stream by one character
03AF   22 8B 31               LD   (vStrPtr),hl   ; Update the top of STRINGS heap pointer
03B2   B7                     OR   a   ; Clear A register
03B3   ED 52                  SBC   hl,de   ; Calculate the length of the string (HL = length, DE = string)
03B5   EB                     EX   de,hl   ; Swap DE and HL (E = length, HL = string)
03B6   73                     LD   (hl),e   ; Store the length at the beginning of the string BUFFER
03B7   7B                     LD   a,e   ; Load the length into A
03B8   C9                     RET      
03B9                             ; *****************************************************************************
03B9                             ; Routine: isIndexReg
03B9                             ; 
03B9                             ; Purpose:
03B9                             ;    Checks if the current operand is an index register (IX or IY).
03B9                             ; 
03B9                             ; Inputs:
03B9                             ;    A - The operand to check.
03B9                             ; 
03B9                             ; Outputs:
03B9                             ;    ZF - Set if the operand is an index register (IX or IY).
03B9                             ; 
03B9                             ; Registers Destroyed:
03B9                             ;    None
03B9                             ; *****************************************************************************
03B9                ISINDEXREG:      
03B9   FE 0D                  CP   IX_   ; Compare operand with IX
03BB   C8                     RET   z   ; Return if equal (ZF is set)
03BC   FE 0E                  CP   IY_   ; Compare operand with IY
03BE   C9                     RET      ; Return (ZF is set if equal, cleared otherwise)
03BF                             ; *****************************************************************************
03BF                             ; Routine: isEndOfLine
03BF                             ; 
03BF                             ; Purpose:
03BF                             ;    Checks if the current character is an end-of-line character.
03BF                             ; 
03BF                             ; Inputs:
03BF                             ;    A - The character to check.
03BF                             ; 
03BF                             ; Outputs:
03BF                             ;    ZF - Set if the character is an end-of-line character (EOF or newline),
03BF                             ;         cleared otherwise.
03BF                             ; 
03BF                             ; Registers Destroyed:
03BF                             ;    None
03BF                             ; *****************************************************************************
03BF                ISENDOFLINE:      
03BF   FE FF                  CP   EOF   ; Compare A with EOF
03C1   C8                     RET   z   ; Return if A is EOF (ZF set)
03C2   FE 0A                  CP   "\n"   ; Compare A with newline
03C4   C9                     RET      ; Return if A is newline (ZF set), otherwise ZF cleared
03C5                             ; *****************************************************************************
03C5                             ; Routine: isAlphaNum
03C5                             ; 
03C5                             ; Purpose:
03C5                             ;    Checks if the character in the A register is an alphanumeric character
03C5                             ;    (either uppercase or lowercase). If the character is alphabetic, it converts
03C5                             ;    it to uppercase and sets the carry flag. If the character is not alphabetic,
03C5                             ;    it clears the carry flag.
03C5                             ; 
03C5                             ; Input:
03C5                             ;    A - Contains the character to be checked.
03C5                             ; 
03C5                             ; Output:
03C5                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
03C5                             ;    CF - Set if the input character was alphabetic, cleared otherwise.
03C5                             ; 
03C5                             ; Destroyed:
03C5                             ;    C
03C5                             ; *****************************************************************************
03C5                ISALPHANUM:      
03C5   CD D6 03               CALL   isDigit   ; Check if it's a digit
03C8   C8                     RET   z   ; If it's not a digit, continue to isAlpha
03C9                             ; Falls through to isAlpha
03C9                             ; *****************************************************************************
03C9                             ; Routine: isAlpha
03C9                             ; 
03C9                             ; Purpose:
03C9                             ;    Checks if the character in the A register is an alphabetic character
03C9                             ;    (either uppercase or lowercase). If the character is alphabetic, it converts
03C9                             ;    it to uppercase and sets the carry flag.
03C9                             ; 
03C9                             ; Input:
03C9                             ;    A - Contains the character to be checked.
03C9                             ; 
03C9                             ; Output:
03C9                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
03C9                             ;    CF - Set if the input character was alphabetic, cleared otherwise.
03C9                             ; 
03C9                             ; Destroyed:
03C9                             ;    None
03C9                             ; *****************************************************************************
03C9                ISALPHA:      
03C9   FE 61                  CP   "a"   ; Compare with lowercase "a"
03CB   38 02                  JR   c,isAlpha1   ; Jump if it"s lower than "a'
03CD   D6 20                  SUB   $20   ; Convert lowercase to uppercase
03CF                ISALPHA1:      
03CF   FE 5B                  CP   "Z"+1   ; Compare with "Z" + 1
03D1   D0                     RET   nc   ; Return if it's not alphabetic
03D2   FE 41                  CP   "A"   ; Compare with "A"
03D4   3F                     CCF      ; Invert CF to set it if it's alphabetic
03D5   C9                     RET      ; Return
03D6                             ; *****************************************************************************
03D6                             ; Routine: isDigit
03D6                             ; 
03D6                             ; Purpose:
03D6                             ;    Checks if the character in the A register is a decimal digit (0-9). If
03D6                             ;    the character is a decimal digit, it sets the carry flag.
03D6                             ; 
03D6                             ; Input:
03D6                             ;    A - Contains the character to be checked.
03D6                             ; 
03D6                             ; Output:
03D6                             ;    CF - Set if the input character was a digit, cleared otherwise.
03D6                             ; 
03D6                             ; Destroyed:
03D6                             ;    None
03D6                             ; *****************************************************************************
03D6                ISDIGIT:      
03D6   FE 3A                  CP   "9"+1   ; Compare with "9" + 1
03D8   D0                     RET   nc   ; Return if it's not a digit
03D9   FE 30                  CP   "0"   ; Compare with "0"
03DB   3F                     CCF      ; Invert CF to set it if it's a digit
03DC   C9                     RET      ; Return
03DD                             ; *****************************************************************************
03DD                             ; Routine: number
03DD                             ; 
03DD                             ; Purpose:
03DD                             ;    Parse a number from the input. Handles both decimal and hexadecimal
03DD                             ;    numbers, and supports negative numbers.
03DD                             ; 
03DD                             ; Input:
03DD                             ;    A - first char of number
03DD                             ; 
03DD                             ; Output:
03DD                             ;    HL - Contains the parsed number.
03DD                             ; 
03DD                             ; Destroyed:
03DD                             ;    None
03DD                             ; *****************************************************************************
03DD                NUMBER:      
03DD   FE 2D                  CP   "-"   ; Check if it's a negative number
03DF   3E FF                  LD   a,-1   ; Set sign flag
03E1   28 01                  JR   z,number1   
03E3   3C                     INC   a   ; Set sign flag to positive
03E4                NUMBER1:      
03E4   32 80 31               LD   (vTemp1),a   ; Store the sign flag in vTemp1
03E7   CD CF 04               CALL   nextChar   ; Get the next character
03EA   FE 24                  CP   "$"   ; Check if it's a hexadecimal number
03EC   20 05                  JR   nz,number2   
03EE   CD 15 04               CALL   hex   ; If yes, parse hexadecimal number
03F1   18 06                  JR   number3   
03F3                NUMBER2:      
03F3   CD 35 05               CALL   rewindChar   ; Push back the character
03F6   CD 40 04               CALL   decimal   ; Parse decimal number
03F9                NUMBER3:      
03F9   3A 80 31               LD   a,(vTemp1)   ; Load the sign from vTemp1
03FC   3C                     INC   a   ; Increment to negate if necessary
03FD   C0                     RET   nz   ; Return if sign is not zero
03FE   EB                     EX   de,hl   ; Negate the value of HL
03FF   21 00 00               LD   hl,0   ; Load zero to clear carry
0402   B7                     OR   a   ; Clear carry flag
0403   ED 52                  SBC   hl,de   ; Subtract DE from HL
0405   CD 35 05               CALL   rewindChar   ; Push back the character
0408   C9                     RET      ; Return
0409                NUMBER_HEX:      
0409   CD 35 05               CALL   rewindChar   
040C   AF                     XOR   a   
040D   32 80 31               LD   (vTemp1),a   ; Store the sign flag in vTemp1
0410   CD 15 04               CALL   hex   ; Parse hexadecimal number
0413   18 E4                  JR   number3   
0415                             ; *****************************************************************************
0415                             ; Routine: hex
0415                             ; 
0415                             ; Purpose:
0415                             ;    Parse a hexadecimal number.
0415                             ; 
0415                             ; Input:
0415                             ;    None
0415                             ; 
0415                             ; Output:
0415                             ;    HL - Parsed number.
0415                             ; 
0415                             ; Destroyed:
0415                             ;    A
0415                             ; *****************************************************************************
0415                HEX:         
0415   21 00 00               LD   hl,0   ; Initialize HL to 0
0418                HEX1:        
0418   CD CF 04               CALL   nextChar   ; Get the next character
041B   FE 30                  CP   "0"   ; Compare with ASCII "0"
041D   D8                     RET   c   ; Return if less than "0"
041E   FE 3A                  CP   "9"+1   ; Compare with ASCII "9" + 1
0420   38 0F                  JR   c,valid   ; If less or equal, jump to valid
0422   FE 61                  CP   "a"   ; Compare with ASCII "a"
0424   38 02                  JR   c,hex2   ; If less, jump to hex2
0426   D6 20                  SUB   $20   ; Convert lowercase to uppercase
0428                HEX2:        
0428   FE 41                  CP   "A"   ; Compare with ASCII "A"
042A   D8                     RET   c   ; Return if less than "A"
042B   FE 47                  CP   "F"+1   ; Compare with ASCII "F" + 1
042D   38 00                  JR   c,upper   ; If less or equal, jump to upper
042F                UPPER:       
042F   D6 37                  SUB   $37   ; Convert ASCII to hexadecimal
0431                VALID:       
0431   D6 30                  SUB   "0"   ; Convert ASCII to numeric value
0433   D8                     RET   c   ; Return if less than 0 (not a valid digit)
0434   FE 10                  CP   $10   ; Compare with 16
0436   D0                     RET   nc   ; Return if greater than 16 (not a valid digit)
0437   29                     ADD   hl,hl   ; Multiply by 16
0438   29                     ADD   hl,hl   ; Multiply by 16
0439   29                     ADD   hl,hl   ; Multiply by 16
043A   29                     ADD   hl,hl   ; Multiply by 16
043B   85                     ADD   a,l   ; Add new digit to HL
043C   6F                     LD   l,a   ; Store result back in L
043D   C3 18 04               JP   hex1   ; Jump back to hex1 to process next character
0440                             ; *****************************************************************************
0440                             ; Routine: decimal
0440                             ; 
0440                             ; Purpose:
0440                             ;    Parse a decimal number.
0440                             ; 
0440                             ; Input:
0440                             ;    None
0440                             ; 
0440                             ; Output:
0440                             ;    HL - Parsed number.
0440                             ; 
0440                             ; Destroyed:
0440                             ;    A, DE
0440                             ; *****************************************************************************
0440                DECIMAL:      
0440   21 00 00               LD   hl,0   ; Initialize HL to 0
0443                DECIMAL1:      
0443   CD CF 04               CALL   nextChar   ; Get the next character
0446   D6 30                  SUB   "0"   ; Convert ASCII to binary
0448   D8                     RET   c   ; Return if less than "0"
0449   FE 0A                  CP   10   ; Compare with 10
044B   D0                     RET   nc   ; Return if greater than 10
044C   03                     INC   bc   ; Increment BC to point to next digit
044D   54 5D                  LD   de,hl   ; Copy HL to DE
044F   29                     ADD   hl,hl   ; Multiply HL by 2
0450   29                     ADD   hl,hl   ; Multiply HL by 4
0451   19                     ADD   hl,de   ; Add DE to HL to multiply by 5
0452   29                     ADD   hl,hl   ; Multiply HL by 10
0453   85                     ADD   a,l   ; Add A to HL
0454   6F                     LD   l,a   ; Store result back in L
0455   3E 00                  LD   a,0   ; Clear A
0457   8C                     ADC   a,h   ; Add carry to H
0458   67                     LD   h,a   ; Store result back in H
0459   18 E8                  JR   decimal1   ; Jump back to start of loop
045B                             ; *****************************************************************************
045B                             ; Routine: searchStr
045B                             ; 
045B                             ; Purpose:
045B                             ;    Search through a list of Pascal STRINGS for a match.
045B                             ; 
045B                             ; Inputs:
045B                             ;    HL - Points to the string to search for.
045B                             ;    DE - Points to the start of the list of STRINGS.
045B                             ; 
045B                             ; Outputs:
045B                             ;    CF - True if match, false otherwise.
045B                             ;    A - Index of the matching string if a match is found, or -1 if no match
045B                             ;        is found.
045B                             ;    HL - Points to the string to search for.
045B                             ; 
045B                             ; Destroyed:
045B                             ;    A, B, C, D, E, A", F"
045B                             ; *****************************************************************************
045B                SEARCHSTR:      
045B   EB                     EX   de,hl   ; DE = search string, HL = string list
045C   AF                     XOR   a   ; Initialize index counter, ZF = true, CF = false
045D   08                     EX   af,af'   ; Exchange AF with AF prime
045E                SEARCHSTR1:      
045E   D5                     PUSH   de   ; Store search string
045F   E5                     PUSH   hl   ; Store current string
0460   CD C4 04               CALL   compareStr   
0463   20 F6                  JR   nz,searchStr   
0465   E1                     POP   hl   ; Discard current string
0466   E1                     POP   hl   ; HL = search string
0467   08                     EX   af,af'   ; Load index of match
0468   3F                     CCF      ; If match, CF = true
0469   C9                     RET      
046A                SEARCHSTR3:      
046A   E1                     POP   hl   ; Restore current string
046B   D1                     POP   de   ; Restore search string
046C   7E                     LD   a,(hl)   ; Load length of current string
046D   3C                     INC   a   ; A = length byte plus length of string
046E   4F                     LD   c,a   ; BC = A
046F   06 00                  LD   b,0   
0471   09                     ADD   hl,bc   ; HL += BC, move to next string
0472   D5                     PUSH   de   ; Store search string
0473   E5                     PUSH   hl   ; Store current string
0474   08                     EX   af,af'   ; Increment index counter, ZF = false, CF = false
0475   3C                     INC   a   
0476   08                     EX   af,af'   
0477   7E                     LD   a,(hl)   ; A = length of next string
0478   B7                     OR   a   ; If A != 0, continue searching
0479   20 E3                  JR   nz,searchStr1   
047B   3D                     DEC   a   ; A = NO_MATCH (i.e., -1), ZF = false
047C   3F                     CCF      ; CF = false
047D   C9                     RET      
047E                             ; *****************************************************************************
047E                             ; Routine: searchOpcode
047E                             ; 
047E                             ; Purpose:
047E                             ;    Searches for a matching opcode in various lists of opcodes.
047E                             ; 
047E                             ; Inputs:
047E                             ;    HL - Points to the string to search for.
047E                             ; 
047E                             ; Outputs:
047E                             ;    CF - Set if a match is found, cleared otherwise.
047E                             ;    A  - Contains the index of the matching opcode if a match is found,
047E                             ;         or the last checked index if no match is found.
047E                             ; 
047E                             ; Registers Destroyed:
047E                             ;    A, DE, F
047E                             ; *****************************************************************************
047E                SEARCHOPCODE:      
047E   11 90 05               LD   de,alu_opcodes   ; Point DE to the list of ALU opcodes
0481   CD 5B 04               CALL   searchStr   ; Search for the string in ALU opcodes
0484   D8                     RET   c   ; If match found (CF set), return
0485   11 71 05               LD   de,rot_opcodes   ; Point DE to the list of ROT opcodes
0488   CD 5B 04               CALL   searchStr   ; Search for the string in ROT opcodes
048B   CB EF                  SET   5,a   ; Set bit 5 in A to indicate ROT opcodes
048D   D8                     RET   c   ; If match found (CF set), return
048E   11 AF 05               LD   de,bli_opcodes   ; Point DE to the list of BLI opcodes
0491   CD 5B 04               CALL   searchStr   ; Search for the string in BLI opcodes
0494   CB F7                  SET   6,a   ; Set bit 6 in A to indicate BLI opcodes
0496   D8                     RET   c   ; If match found (CF set), return
0497   11 FA 05               LD   de,gen1_opcodes   ; Point DE to the list of general opcodes (set 1)
049A   CD 5B 04               CALL   searchStr   ; Search for the string in general opcodes
049D   CB EF                  SET   5,a   ; Set bits 5 & 6 in A to indicate general opcodes (set 1)
049F   CB F7                  SET   6,a   
04A1   D8                     RET   c   ; If match found (CF set), return
04A2   11 23 06               LD   de,gen2_opcodes   ; Point DE to the list of general opcodes (set 2)
04A5   CD 5B 04               CALL   searchStr   ; Search for the string in general opcodes
04A8   CB FF                  SET   7,a   ; Set bit 7 in A to indicate general opcodes (set 2)
04AA   C9                     RET      ; Return if no match is found
04AB                             ; *****************************************************************************
04AB                             ; Routine: searchOpElem
04AB                             ; 
04AB                             ; Purpose:
04AB                             ;    Searches for an op element in the lists of 8-bit registers, 16-bit registers,
04AB                             ;    and flags. Sets appropriate flags based on the type of operand found.
04AB                             ; 
04AB                             ; Inputs:
04AB                             ;    HL - Points to the start of the string to search for.
04AB                             ; 
04AB                             ; Outputs:
04AB                             ;    A  - The index of the matching op element if a match is found, or -1 if no
04AB                             ;         match is found.
04AB                             ;    CF - Carry flag is set if a match is found.
04AB                             ; 
04AB                             ; Registers Destroyed:
04AB                             ;    A, DE, HL
04AB                             ; *****************************************************************************
04AB                             ; reg_    .equ    0x00    ; A, B etc
04AB                             ; rp_     .equ    0x08    ; bit 3: 8-bit or 16-bit e.g. A or HL, 0xff or 0xffff
04AB                             ; flag_   .equ    0x10    ; bit 4: NZ etc
04AB                SEARCHOPELEM:      
04AB   11 8C 06               LD   de,reg8   ; Point DE to the list of 8-bit register operands
04AE   CD 5B 04               CALL   searchStr   ; Search for the string in reg8 operands
04B1   D8                     RET   c   ; If match found (CF set), return
04B2   11 A1 06               LD   de,reg16   ; Point DE to the list of 16-bit register operands
04B5   CD 5B 04               CALL   searchStr   ; Search for the string in reg16 operands
04B8   CB DF                  SET   3,a   ; Set bit 4 in A to indicate a register operand
04BA   D8                     RET   c   ; If match found (CF set), return
04BB   11 BB 06               LD   de,flags   ; Point DE to the list of flag operands
04BE   CD 5B 04               CALL   searchStr   ; Search for the string in flag operands
04C1   CB E7                  SET   4,a   ; Set bit 3 in A to indicate flag operand
04C3   C9                     RET      ; Return if no match is found
04C4                             ; *****************************************************************************
04C4                             ; Routine: compareStr
04C4                             ; 
04C4                             ; Purpose:
04C4                             ;    Compares two Pascal strings. The comparison includes
04C4                             ;    the length byte and continues until all characters are compared or a
04C4                             ;    mismatch is found.
04C4                             ; 
04C4                             ; Inputs:
04C4                             ;    DE - Points to the start of string1
04C4                             ;    HL - Points to the start of string2
04C4                             ; 
04C4                             ; Outputs:
04C4                             ;    ZF - Set if the strings are equal
04C4                             ; 
04C4                             ; Registers Destroyed:
04C4                             ;    A, B, DE, HL
04C4                             ; *****************************************************************************
04C4                COMPARESTR:      
04C4   1A                     LD   a,(de)   ; Load length of search string
04C5   47                     LD   b,a   ; Copy length to B for looping
04C6   04                     INC   b   ; Increase to include length byte
04C7                COMPARESTR2:      
04C7   1A                     LD   a,(de)   ; Load next character from search string
04C8   BE                     CP   (hl)   ; Compare with next character in current string
04C9   C0                     RET   nz   ; Return if characters are not equal
04CA   13                     INC   de   ; Move to next character in search string
04CB   23                     INC   hl   ; Move to next character in current string
04CC   10 F9                  DJNZ   compareStr2   ; Loop until all characters compared or mismatch
04CE                COMPARESTR3:      
04CE   C9                     RET      ; Return with ZF set if strings are equal
04CF                             ; *****************************************************************************
04CF                             ; Routine: nextChar
04CF                             ; 
04CF                             ; Purpose:
04CF                             ;    Fetches the next character from the BUFFER. If the BUFFER is empty or
04CF                             ;    contains a null character (0), it refills the BUFFER by calling nextLine.
04CF                             ; 
04CF                             ; Inputs:
04CF                             ;    None
04CF                             ; 
04CF                             ; Outputs:
04CF                             ;    A - The next character from the BUFFER
04CF                             ; 
04CF                             ; Registers Destroyed:
04CF                             ;    A, D, E, HL
04CF                             ; *****************************************************************************
04CF                NEXTCHAR:      
04CF   21 87 31               LD   hl,vBufferPos   ; Load the offset of BUFFER position variable
04D2   7E                     LD   a,(hl)   ; Load the current position offset in the BUFFER into A
04D3   FE 80                  CP   BUFFER_SIZE   ; Compare with BUFFER size
04D5   CA E6 04               JP   z,nextLine   ; Jump to nextLine if end of BUFFER
04D8   11 00 30               LD   de,BUFFER   ; Load the MSB of the BUFFER's address into D
04DB   83                     ADD   a,e   ; de += a
04DC   5F                     LD   e,a   
04DD   3E 00                  LD   a,0   
04DF   8A                     ADC   a,d   
04E0   57                     LD   d,a   
04E1   1A                     LD   a,(de)   ; Load the character at the current BUFFER position into A
04E2   34                     INC   (hl)   ; Increment the BUFFER position offset
04E3   FE 0A                  CP   "\n"   ; if a != null return else load a new line into buffer
04E5   C0                     RET   nz   
04E6                NEXTLINE:      
04E6   21 00 30               LD   hl,BUFFER   ; Start of the BUFFER
04E9   06 80                  LD   b,BUFFER_SIZE   ; Number of bytes to fill
04EB                NEXTLINE1:      
04EB   CD 81 00               CALL   getchar   ; Get a character from getchar
04EE   FE FF                  CP   EOF   ; is it EOF
04F0   28 30                  JR   z,nextLine6   
04F2   B7                     OR   a   ; is it NULL?
04F3   28 04                  JR   z,nextLine2   
04F5   FE 03                  CP   CTRL_C   ; is it ctrl-C ?
04F7   20 04                  JR   nz,nextLine3   
04F9                NEXTLINE2:      
04F9   3E FF                  LD   a,EOF   
04FB   18 25                  JR   nextLine6   
04FD                NEXTLINE3:      
04FD   FE 08                  CP   "\b"   ; Check if character is backspace
04FF   20 10                  JR   nz,nextLine4   ; If not, proceed to store the character
0501   3E 80                  LD   a,BUFFER_SIZE   
0503   90                     SUB   b   ; Check if at the start of the buffer
0504   28 E5                  JR   z,nextLine1   ; If at the start, ignore backspace
0506   2B                     DEC   hl   ; Move back in the buffer
0507   04                     INC   b   ; Adjust buffer size counter
0508   CD 52 05               CALL   print   ; Erase the character at the current cursor position
050B   1B 5B 50 00            .CSTR   ESC,"[P"   ; Escape sequence for erasing character
050F   18 DA                  JR   nextLine1   
0511                NEXTLINE4:      
0511   CD 87 00               CALL   putchar   ; Echo character to terminal
0514   FE 09                  CP   "\t"   
0516   20 04                  JR   nz,nextLine5   ; if a == CR or NL replace with null
0518   3E 20                  LD   a," "   
051A   18 06                  JR   nextLine6   
051C                NEXTLINE5:      
051C   FE 0D                  CP   "\r"   ; Check if character is carriage return
051E   20 02                  JR   nz,nextLine6   
0520   3E 0A                  LD   a,"\n"   
0522                NEXTLINE6:      
0522   77                     LD   (hl),a   ; Store the character in the BUFFER
0523   23                     INC   hl   ; Move to the next position in the BUFFER
0524   FE FF                  CP   EOF   ; Break loop if character is end of line
0526   28 06                  JR   z,nextLine7   
0528   FE 0A                  CP   "\n"   ; Break loop if character is end of line
052A   28 02                  JR   z,nextLine7   
052C   10 BD                  DJNZ   nextLine1   ; Repeat until BUFFER is full
052E                NEXTLINE7:      
052E   21 87 31               LD   hl,vBufferPos   
0531   36 00                  LD   (hl),0   
0533   18 9A                  JR   nextChar   
0535                             ; *****************************************************************************
0535                             ; Routine: rewindChar
0535                             ; 
0535                             ; Purpose:
0535                             ;    Rewinds the BUFFER position by one character, effectively pushing back the
0535                             ;    BUFFER position by one character in the input stream.
0535                             ; 
0535                             ; Inputs:
0535                             ;    None
0535                             ; 
0535                             ; Outputs:
0535                             ;    None
0535                             ; 
0535                             ; Registers Destroyed:
0535                             ;    A
0535                             ; *****************************************************************************
0535                REWINDCHAR:      
0535   21 87 31               LD   hl,vBufferPos   ; Load the address of BUFFER position variable
0538   7E                     LD   a,(hl)   ; Load the current position in the BUFFER into A
0539   B7                     OR   a   ; Check if the BUFFER position is zero
053A   C8                     RET   z   ; If zero, nothing to push back, return
053B   35                     DEC   (hl)   ; Decrement the BUFFER position
053C   C9                     RET      ; Return
053D                             ; *****************************************************************************
053D                             ; Routine: prompt
053D                             ; 
053D                             ; Purpose:
053D                             ;    Prints a prompt symbol ("> ") to indicate readiness for user input.
053D                             ; 
053D                             ; Inputs:
053D                             ;    None
053D                             ; 
053D                             ; Outputs:
053D                             ;    None
053D                             ; 
053D                             ; Registers Destroyed:
053D                             ;    A, HL
053D                             ; *****************************************************************************
053D                PROMPT:      
053D   CD 52 05               CALL   print   ; Print the null-terminated string (prompt message)
0540   0D 0A 3E 20 00         .CSTR   "\r\n> "   ; Define the prompt message
0545   C9                     RET      ; Return to the caller
0546                             ; *****************************************************************************
0546                             ; Routine: crlf
0546                             ; 
0546                             ; Purpose:
0546                             ;    Prints a carriage return and line feed (new line) to the output.
0546                             ; 
0546                             ; Inputs:
0546                             ;    None
0546                             ; 
0546                             ; Outputs:
0546                             ;    None
0546                             ; 
0546                             ; Registers Destroyed:
0546                             ;    A, HL
0546                             ; *****************************************************************************
0546                CRLF:        
0546   CD 52 05               CALL   print   ; Print the null-terminated string (carriage return and line feed)
0549   0D 0A 00               .CSTR   "\r\n"   ; Define the carriage return and line feed message
054C   C9                     RET      ; Return to the caller
054D                             ; *****************************************************************************
054D                             ; Routine: error
054D                             ; 
054D                             ; Purpose:
054D                             ;    Prints an error message and halts execution.
054D                             ; 
054D                             ; Inputs:
054D                             ;    (Stack) - The address of the error message to be printed
054D                             ; 
054D                             ; Outputs:
054D                             ;    None
054D                             ; 
054D                             ; Registers Destroyed:
054D                             ;    A, HL
054D                             ; *****************************************************************************
054D                ERROR:       
054D   E1                     POP   hl   ; Retrieve the "return" address which is the address of the error message
054E   CD 59 05               CALL   printStr   ; Call the routine to print the null-terminated string
0551   76                     HALT      ; Halt the CPU
0552                             ; *****************************************************************************
0552                             ; Routine: print
0552                             ; 
0552                             ; Purpose:
0552                             ;    Prints a null-terminated string starting from the address in HL.
0552                             ; 
0552                             ; Inputs:
0552                             ;    HL - Points to the start of the string to be printed
0552                             ; 
0552                             ; Outputs:
0552                             ;    None
0552                             ; 
0552                             ; Registers Destroyed:
0552                             ;    None
0552                             ; *****************************************************************************
0552                PRINT:       
0552   E3                     EX   (sp),hl   ; Swap HL with the value on the stack to preserve HL
0553   CD 66 05               CALL   printZStr   ; Call the routine to print the null-terminated string
0556   23                     INC   hl   ; Increment HL to skip the null terminator
0557   E3                     EX   (sp),hl   ; Restore the original value of HL from the stack
0558   C9                     RET      ; Return to the caller
0559                             ; *****************************************************************************
0559                             ; Routine: printStr
0559                             ; 
0559                             ; Purpose:
0559                             ;    Prints a Pascal string stored in memory.
0559                             ; 
0559                             ; Inputs:
0559                             ;    HL - Points to the start of the string (first byte is the length)
0559                             ; 
0559                             ; Outputs:
0559                             ;    None
0559                             ; 
0559                             ; Registers Destroyed:
0559                             ;    A, B, HL
0559                             ; *****************************************************************************
0559                PRINTSTR:      
0559   7E                     LD   a,(hl)   ; Load the length of the string
055A   B7                     OR   a   ; Check if the length is zero
055B   C8                     RET   z   ; If zero, return immediately
055C   23                     INC   hl   ; Move HL to the start of the string data
055D   47                     LD   b,a   ; Copy the length to B for looping
055E                PRINTSTR1:      
055E   7E                     LD   a,(hl)   ; Load the next character
055F   CD 87 00               CALL   putchar   ; Call a routine that prints a single character
0562   23                     INC   hl   ; Move to the next character
0563   10 F9                  DJNZ   printStr1   ; Decrement B and jump if not zero
0565   C9                     RET      ; Return from the routine
0566                             ; *****************************************************************************
0566                             ; Routine: printZStr
0566                             ; 
0566                             ; Purpose:
0566                             ;    Prints a null-terminated string stored in memory.
0566                             ; 
0566                             ; Inputs:
0566                             ;    HL - Points to the start of the string to be printed
0566                             ; 
0566                             ; Outputs:
0566                             ;    None
0566                             ; 
0566                             ; Registers Destroyed:
0566                             ;    A, HL
0566                             ; *****************************************************************************
0566                PRINTZSTR:      
0566   18 04                  JR   printZStr2   ; Jump to the loop condition
0568                PRINTZSTR1:      
0568   CD 87 00               CALL   putchar   ; Print the current character
056B   23                     INC   hl   ; Move to the next character
056C                PRINTZSTR2:      
056C   7E                     LD   a,(hl)   ; Load the current character
056D   B7                     OR   a   ; Check if the character is null
056E   20 F8                  JR   nz,printZStr1   ; If not null, continue printing
0570   C9                     RET      ; Return when null character is encountered
0571                             ; *******************************************************************************
0571                             ; *********  END OF MAIN   ******************************************************
0571                             ; *******************************************************************************
0571                ROT_OPCODES:      
0571   03 52 4C 43            .PSTR   "RLC"   
0575   03 52 52 43            .PSTR   "RRC"   
0579   02 52 4C               .PSTR   "RL"   
057C   02 52 52               .PSTR   "RR"   
057F   03 53 4C 41            .PSTR   "SLA"   
0583   03 53 52 41            .PSTR   "SRA"   
0587   03 53 4C 4C            .PSTR   "SLL"   
058B   03 53 52 4C            .PSTR   "SRL"   
058F   00                     .PSTR   ""   ; terminate list with a string of zero length
0590                ALU_OPCODES:      
0590   03 41 44 44            .PSTR   "ADD"   
0594   03 41 44 43            .PSTR   "ADC"   
0598   03 53 55 42            .PSTR   "SUB"   
059C   03 53 42 43            .PSTR   "SBC"   
05A0   03 41 4E 44            .PSTR   "AND"   
05A4   03 58 4F 52            .PSTR   "XOR"   
05A8   02 4F 52               .PSTR   "OR"   
05AB   02 43 50               .PSTR   "CP"   
05AE   00                     .PSTR   ""   ; terminate list with a string of zero length
05AF                BLI_OPCODES:      
05AF   03 4C 44 49            .PSTR   "LDI"   
05B3   03 43 50 49            .PSTR   "CPI"   
05B7   03 49 4E 49            .PSTR   "INI"   
05BB   04 4F 55 54 49         .PSTR   "OUTI"   
05C0   03 4C 44 44            .PSTR   "LDD"   
05C4   03 43 50 44            .PSTR   "CPD"   
05C8   03 49 4E 44            .PSTR   "IND"   
05CC   04 4F 55 54 44         .PSTR   "OUTD"   
05D1   04 4C 44 49 52         .PSTR   "LDIR"   
05D6   04 43 50 49 52         .PSTR   "CPIR"   
05DB   04 49 4E 49 52         .PSTR   "INIR"   
05E0   04 4F 54 49 52         .PSTR   "OTIR"   
05E5   04 4C 44 44 52         .PSTR   "LDDR"   
05EA   04 43 50 44 52         .PSTR   "CPDR"   
05EF   04 49 4E 44 52         .PSTR   "INDR"   
05F4   04 4F 54 44 52         .PSTR   "OTDR"   
05F9   00                     .PSTR   ""   ; terminate list with a string of zero length
05FA                GEN1_OPCODES:      
05FA   03 43 43 46            .PSTR   "CCF"   
05FE   03 43 50 4C            .PSTR   "CPL"   
0602   03 44 41 41            .PSTR   "DAA"   
0606   02 44 49               .PSTR   "DI"   
0609   02 45 49               .PSTR   "EI"   
060C   04 48 41 4C 54         .PSTR   "HALT"   
0611   03 4E 4F 50            .PSTR   "NOP"   
0615   04 52 4C 43 41         .PSTR   "RLCA"   
061A   03 52 53 54            .PSTR   "RST"   
061E   03 53 43 46            .PSTR   "SCF"   
0622   00                     .PSTR   ""   ; terminate list with a string of zero length
0623                GEN2_OPCODES:      
0623   03 42 49 54            .PSTR   "BIT"   
0627   04 43 41 4C 4C         .PSTR   "CALL"   
062C   03 44 45 43            .PSTR   "DEC"   
0630   04 44 4A 4E 5A         .PSTR   "DJNZ"   
0635   02 45 58               .PSTR   "EX"   
0638   03 45 58 58            .PSTR   "EXX"   
063C   02 49 4D               .PSTR   "IM"   
063F   02 49 4E               .PSTR   "IN"   
0642   03 49 4E 43            .PSTR   "INC"   
0646   02 4A 50               .PSTR   "JP"   
0649   02 4A 52               .PSTR   "JR"   
064C   02 4C 44               .PSTR   "LD"   
064F   03 4E 45 47            .PSTR   "NEG"   
0653   03 4F 55 54            .PSTR   "OUT"   
0657   03 50 4F 50            .PSTR   "POP"   
065B   04 50 55 53 48         .PSTR   "PUSH"   
0660   03 52 45 53            .PSTR   "RES"   
0664   03 52 45 54            .PSTR   "RET"   
0668   04 52 45 54 49         .PSTR   "RETI"   
066D   04 52 45 54 4E         .PSTR   "RETN"   
0672   03 52 4C 41            .PSTR   "RLA"   
0676   03 52 4C 44            .PSTR   "RLD"   
067A   03 52 52 41            .PSTR   "RRA"   
067E   04 52 52 43 41         .PSTR   "RRCA"   
0683   03 52 52 44            .PSTR   "RRD"   
0687   03 53 45 54            .PSTR   "SET"   
068B   00                     .PSTR   ""   ; terminate list with a string of zero length
068C                REG8:        
068C   01 42                  .PSTR   "B"   
068E   01 43                  .PSTR   "C"   
0690   01 44                  .PSTR   "D"   
0692   01 45                  .PSTR   "E"   
0694   01 48                  .PSTR   "H"   
0696   01 4C                  .PSTR   "L"   
0698   01 20                  .PSTR   " "   ; don't match, stand-in for (HL)
069A   01 41                  .PSTR   "A"   
069C   01 49                  .PSTR   "I"   
069E   01 52                  .PSTR   "R"   
06A0   00                     .PSTR   ""   ; terminate list with a string of zero length
06A1                REG16:       
06A1   02 42 43               .PSTR   "BC"   
06A4   02 44 45               .PSTR   "DE"   
06A7   02 48 4C               .PSTR   "HL"   
06AA   02 53 50               .PSTR   "SP"   
06AD   02 49 58               .PSTR   "IX"   
06B0   02 49 59               .PSTR   "IY"   
06B3   03 41 46 27            .PSTR   "AF'"   
06B7   02 41 46               .PSTR   "AF"   ; NOTE: AF has the same code as SP in some instructions
06BA   00                     .PSTR   ""   ; terminate list with a string of zero length
06BB                FLAGS:       
06BB   02 4E 5A               .PSTR   "NZ"   
06BE   01 5A                  .PSTR   "Z"   
06C0   02 4E 43               .PSTR   "NC"   
06C3   01 43                  .PSTR   "C"   
06C5   02 50 4F               .PSTR   "PO"   
06C8   02 50 45               .PSTR   "PE"   
06CB   01 50                  .PSTR   "P"   
06CD   01 4D                  .PSTR   "M"   
06CF   00                     .PSTR   ""   ; terminate list with a string of zero length
06D0                DIRECTIVES:      
06D0   06 2E 41 4C 49 47 4E   .PSTR   ".ALIGN"   
06D7   03 2E 44 42            .PSTR   ".DB"   
06DB   04 2E 4F 52 47         .PSTR   ".ORG"   
06E0   04 2E 53 45 54         .PSTR   ".SET"   
06E5   00                     .PSTR   ""   ; terminate list with a string of zero length
06E6                             ; *******************************************************************************
06E6                             ; *********  END OF DATA   ******************************************************
06E6                             ; *******************************************************************************
3000                          .ORG   RAMSTART   
3000                          ALIGN   $100   
3000                BUFFER:   DS   BUFFER_SIZE   ; line BUFFER, page aligned
3080                          DS   $100   
3180                STACK:       ; grows down
3180                VTEMP1:   DS   2   ; temp var 1
3182                VTEMP2:   DS   2   ; temp var 2
3184                VTOKEN:   DS   1   ; BUFFER for pushed back token
3185                VTOKENVAL:   DS   2   ; BUFFER for pushed back token value
3187                VBUFFERPOS:   DS   2   ; pointer to char position into input BUFFER
3189                VASMPTR:   DS   2   ; pointer to ASSEMBLY point
318B                VSTRPTR:   DS   2   ; pointer to string STACK
318D                VSYMPTR:   DS   2   ; pointer to symbol STACK
318F                VEXPRPTR:   DS   2   ; pointer to expression STACK
3191                VOPCODE:   DS   1   
3192                VOPERAND1:   DS   1   
3193                VOPERAND2:   DS   1   
3194                VOPEXPR:   DS   2   
3196                VOPDISP:   DS   2   
3198                STRINGS:   DS   STRS_SIZE   ; string heap - grows up
3298                SYMBOLS:   DS   SYMS_SIZE   ; symbol heap - grows up
3398                EXPRS:    DS   EXPRS_SIZE   ; expression heap - grows up
3498                RST08:    DS   2   
349A                RST10:    DS   2   
349C                RST18:    DS   2   
349E                RST20:    DS   2   
34A0                RST28:    DS   2   
34A2                RST30:    DS   2   
34A4                BAUD:     DS   2   
34A6                INTVEC:   DS   2   
34A8                NMIVEC:   DS   2   
34AA                GETCVEC:   DS   2   
34AC                PUTCVEC:   DS   2   
34AE                ASSEMBLY:      


ROMSTART:           0000 DEFINED AT LINE 1 IN constants.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 116 IN IOSerial.asm
                    > USED AT LINE 122 IN IOSerial.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 134 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 146 IN IOSerial.asm
                    > USED AT LINE 152 IN IOSerial.asm
                    > USED AT LINE 158 IN IOSerial.asm
                    > USED AT LINE 200 IN IOSerial.asm
                    > USED AT LINE 17 IN MAIN.asm
RAMSTART:           3000 DEFINED AT LINE 2 IN constants.asm
                    > USED AT LINE 1 IN ram.asm
ROMSIZE:            3000 DEFINED AT LINE 3 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 4 IN constants.asm
EOF:                00-1 DEFINED AT LINE 6 IN constants.asm
                    > USED AT LINE 315 IN MAIN.asm
                    > USED AT LINE 598 IN MAIN.asm
                    > USED AT LINE 1032 IN MAIN.asm
                    > USED AT LINE 1040 IN MAIN.asm
                    > USED AT LINE 1072 IN MAIN.asm
NULL:               0000 DEFINED AT LINE 7 IN constants.asm
CTRL_C:             0003 DEFINED AT LINE 8 IN constants.asm
                    > USED AT LINE 1036 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 9 IN constants.asm
ESC:                001B DEFINED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 1053 IN MAIN.asm
NO_MATCH:           00-1 DEFINED AT LINE 11 IN constants.asm
BUFFER_SIZE:        0080 DEFINED AT LINE 13 IN constants.asm
                    > USED AT LINE 1013 IN MAIN.asm
                    > USED AT LINE 1028 IN MAIN.asm
                    > USED AT LINE 1046 IN MAIN.asm
                    > USED AT LINE 5 IN ram.asm
STRS_SIZE:          0100 DEFINED AT LINE 14 IN constants.asm
                    > USED AT LINE 27 IN ram.asm
SYMS_SIZE:          0100 DEFINED AT LINE 15 IN constants.asm
                    > USED AT LINE 28 IN ram.asm
EXPRS_SIZE:         0100 DEFINED AT LINE 16 IN constants.asm
                    > USED AT LINE 29 IN ram.asm
TOKENS:             0000 DEFINED AT LINE 18 IN constants.asm
COLON_:             000: DEFINED AT LINE 20 IN constants.asm
COMMA_:             000, DEFINED AT LINE 21 IN constants.asm
                    > USED AT LINE 180 IN MAIN.asm
DIRECT_:            000D DEFINED AT LINE 22 IN constants.asm
                    > USED AT LINE 169 IN MAIN.asm
                    > USED AT LINE 379 IN MAIN.asm
DOLLAR_:            000$ DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 399 IN MAIN.asm
EOF_:               000E DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 126 IN MAIN.asm
                    > USED AT LINE 318 IN MAIN.asm
IDENT_:             000I DEFINED AT LINE 25 IN constants.asm
                    > USED AT LINE 383 IN MAIN.asm
LABEL_:             000L DEFINED AT LINE 26 IN constants.asm
                    > USED AT LINE 160 IN MAIN.asm
                    > USED AT LINE 352 IN MAIN.asm
LPAREN_:            000( DEFINED AT LINE 27 IN constants.asm
                    > USED AT LINE 221 IN MAIN.asm
NEWLN_:             000
 DEFINED AT LINE 28 IN constants.asm
                    > USED AT LINE 328 IN MAIN.asm
NUM_:               0009 DEFINED AT LINE 29 IN constants.asm
                    > USED AT LINE 394 IN MAIN.asm
                    > USED AT LINE 412 IN MAIN.asm
OPCODE_:            000C DEFINED AT LINE 30 IN constants.asm
                    > USED AT LINE 167 IN MAIN.asm
                    > USED AT LINE 362 IN MAIN.asm
OPELEM_:            000M DEFINED AT LINE 31 IN constants.asm
                    > USED AT LINE 218 IN MAIN.asm
                    > USED AT LINE 231 IN MAIN.asm
                    > USED AT LINE 370 IN MAIN.asm
RPAREN_:            000) DEFINED AT LINE 32 IN constants.asm
                    > USED AT LINE 255 IN MAIN.asm
UNKNOWN_:           000U DEFINED AT LINE 33 IN constants.asm
                    > USED AT LINE 422 IN MAIN.asm
ALU_:               0000 DEFINED AT LINE 35 IN constants.asm
                    > USED AT LINE 43 IN constants.asm
                    > USED AT LINE 44 IN constants.asm
                    > USED AT LINE 45 IN constants.asm
                    > USED AT LINE 46 IN constants.asm
                    > USED AT LINE 47 IN constants.asm
                    > USED AT LINE 48 IN constants.asm
                    > USED AT LINE 49 IN constants.asm
                    > USED AT LINE 50 IN constants.asm
ROT_:               0020 DEFINED AT LINE 36 IN constants.asm
                    > USED AT LINE 54 IN constants.asm
                    > USED AT LINE 55 IN constants.asm
                    > USED AT LINE 56 IN constants.asm
                    > USED AT LINE 57 IN constants.asm
                    > USED AT LINE 58 IN constants.asm
                    > USED AT LINE 59 IN constants.asm
                    > USED AT LINE 60 IN constants.asm
                    > USED AT LINE 61 IN constants.asm
BLI_:               0040 DEFINED AT LINE 37 IN constants.asm
                    > USED AT LINE 65 IN constants.asm
                    > USED AT LINE 66 IN constants.asm
                    > USED AT LINE 67 IN constants.asm
                    > USED AT LINE 68 IN constants.asm
                    > USED AT LINE 69 IN constants.asm
                    > USED AT LINE 70 IN constants.asm
                    > USED AT LINE 71 IN constants.asm
                    > USED AT LINE 72 IN constants.asm
                    > USED AT LINE 73 IN constants.asm
                    > USED AT LINE 74 IN constants.asm
                    > USED AT LINE 75 IN constants.asm
                    > USED AT LINE 76 IN constants.asm
                    > USED AT LINE 77 IN constants.asm
                    > USED AT LINE 78 IN constants.asm
                    > USED AT LINE 79 IN constants.asm
                    > USED AT LINE 80 IN constants.asm
GEN1_:              0060 DEFINED AT LINE 38 IN constants.asm
                    > USED AT LINE 84 IN constants.asm
                    > USED AT LINE 85 IN constants.asm
                    > USED AT LINE 86 IN constants.asm
                    > USED AT LINE 87 IN constants.asm
                    > USED AT LINE 88 IN constants.asm
                    > USED AT LINE 89 IN constants.asm
                    > USED AT LINE 90 IN constants.asm
                    > USED AT LINE 91 IN constants.asm
                    > USED AT LINE 93 IN constants.asm
GEN2_:              0080 DEFINED AT LINE 39 IN constants.asm
                    > USED AT LINE 92 IN constants.asm
                    > USED AT LINE 97 IN constants.asm
                    > USED AT LINE 98 IN constants.asm
                    > USED AT LINE 99 IN constants.asm
                    > USED AT LINE 100 IN constants.asm
                    > USED AT LINE 101 IN constants.asm
                    > USED AT LINE 102 IN constants.asm
                    > USED AT LINE 103 IN constants.asm
                    > USED AT LINE 104 IN constants.asm
                    > USED AT LINE 105 IN constants.asm
                    > USED AT LINE 106 IN constants.asm
                    > USED AT LINE 107 IN constants.asm
                    > USED AT LINE 108 IN constants.asm
                    > USED AT LINE 109 IN constants.asm
                    > USED AT LINE 110 IN constants.asm
                    > USED AT LINE 111 IN constants.asm
                    > USED AT LINE 112 IN constants.asm
                    > USED AT LINE 113 IN constants.asm
                    > USED AT LINE 114 IN constants.asm
                    > USED AT LINE 115 IN constants.asm
                    > USED AT LINE 116 IN constants.asm
                    > USED AT LINE 117 IN constants.asm
                    > USED AT LINE 118 IN constants.asm
                    > USED AT LINE 119 IN constants.asm
                    > USED AT LINE 120 IN constants.asm
                    > USED AT LINE 121 IN constants.asm
                    > USED AT LINE 122 IN constants.asm
ALU_IDX:            0000 DEFINED AT LINE 41 IN constants.asm
ADD_:               0000 DEFINED AT LINE 43 IN constants.asm
ADC_:               0001 DEFINED AT LINE 44 IN constants.asm
SUB_:               0002 DEFINED AT LINE 45 IN constants.asm
SBC_:               0003 DEFINED AT LINE 46 IN constants.asm
AND_:               0004 DEFINED AT LINE 47 IN constants.asm
XOR_:               0005 DEFINED AT LINE 48 IN constants.asm
OR_:                0006 DEFINED AT LINE 49 IN constants.asm
CP_:                0007 DEFINED AT LINE 50 IN constants.asm
ROT_IDX:            0000 DEFINED AT LINE 52 IN constants.asm
RLC_:               0020 DEFINED AT LINE 54 IN constants.asm
RRC_:               0021 DEFINED AT LINE 55 IN constants.asm
RL_:                0022 DEFINED AT LINE 56 IN constants.asm
RR_:                0023 DEFINED AT LINE 57 IN constants.asm
SLA_:               0024 DEFINED AT LINE 58 IN constants.asm
SRA_:               0025 DEFINED AT LINE 59 IN constants.asm
SLL_:               0026 DEFINED AT LINE 60 IN constants.asm
SRL_:               0027 DEFINED AT LINE 61 IN constants.asm
BLI_IDX:            0000 DEFINED AT LINE 63 IN constants.asm
LDI_:               0040 DEFINED AT LINE 65 IN constants.asm
CPI_:               0041 DEFINED AT LINE 66 IN constants.asm
INI_:               0042 DEFINED AT LINE 67 IN constants.asm
OUTI_:              0043 DEFINED AT LINE 68 IN constants.asm
LDD_:               0044 DEFINED AT LINE 69 IN constants.asm
CPD_:               0045 DEFINED AT LINE 70 IN constants.asm
IND_:               0046 DEFINED AT LINE 71 IN constants.asm
OUTD_:              0047 DEFINED AT LINE 72 IN constants.asm
LDIR_:              0048 DEFINED AT LINE 73 IN constants.asm
CPIR_:              0049 DEFINED AT LINE 74 IN constants.asm
INIR_:              004A DEFINED AT LINE 75 IN constants.asm
OTIR_:              004B DEFINED AT LINE 76 IN constants.asm
LDDR_:              004C DEFINED AT LINE 77 IN constants.asm
CPDR_:              004D DEFINED AT LINE 78 IN constants.asm
INDR_:              004E DEFINED AT LINE 79 IN constants.asm
OTDR_:              004F DEFINED AT LINE 80 IN constants.asm
GEN1_IDX:           0000 DEFINED AT LINE 82 IN constants.asm
CCF_:               0060 DEFINED AT LINE 84 IN constants.asm
CPL_:               0061 DEFINED AT LINE 85 IN constants.asm
DAA_:               0062 DEFINED AT LINE 86 IN constants.asm
DI_:                0063 DEFINED AT LINE 87 IN constants.asm
EI_:                0064 DEFINED AT LINE 88 IN constants.asm
HALT_:              0065 DEFINED AT LINE 89 IN constants.asm
NOP_:               0066 DEFINED AT LINE 90 IN constants.asm
RLCA_:              0067 DEFINED AT LINE 91 IN constants.asm
RST_:               0088 DEFINED AT LINE 92 IN constants.asm
SCF_:               0069 DEFINED AT LINE 93 IN constants.asm
GEN2_IDX:           0000 DEFINED AT LINE 95 IN constants.asm
BIT_:               0080 DEFINED AT LINE 97 IN constants.asm
CALL_:              0081 DEFINED AT LINE 98 IN constants.asm
DEC_:               0082 DEFINED AT LINE 99 IN constants.asm
DJNZ_:              0083 DEFINED AT LINE 100 IN constants.asm
EX_:                0084 DEFINED AT LINE 101 IN constants.asm
EXX_:               0085 DEFINED AT LINE 102 IN constants.asm
IM_:                0086 DEFINED AT LINE 103 IN constants.asm
IN_:                0087 DEFINED AT LINE 104 IN constants.asm
INC_:               0088 DEFINED AT LINE 105 IN constants.asm
JP_:                0089 DEFINED AT LINE 106 IN constants.asm
JR_:                008A DEFINED AT LINE 107 IN constants.asm
LD_:                008B DEFINED AT LINE 108 IN constants.asm
NEG_:               008C DEFINED AT LINE 109 IN constants.asm
OUT_:               008D DEFINED AT LINE 110 IN constants.asm
POP_:               008E DEFINED AT LINE 111 IN constants.asm
PUSH_:              008F DEFINED AT LINE 112 IN constants.asm
RES_:               0090 DEFINED AT LINE 113 IN constants.asm
RET_:               0091 DEFINED AT LINE 114 IN constants.asm
RETI_:              0092 DEFINED AT LINE 115 IN constants.asm
RETN_:              0093 DEFINED AT LINE 116 IN constants.asm
RLA_:               0094 DEFINED AT LINE 117 IN constants.asm
RLD_:               0095 DEFINED AT LINE 118 IN constants.asm
RRA_:               0096 DEFINED AT LINE 119 IN constants.asm
RRCA_:              0097 DEFINED AT LINE 120 IN constants.asm
RRD_:               0098 DEFINED AT LINE 121 IN constants.asm
SET_:               0003 DEFINED AT LINE 171 IN constants.asm
REG_:               0000 DEFINED AT LINE 124 IN constants.asm
RP_:                0008 DEFINED AT LINE 125 IN constants.asm
                    > USED AT LINE 146 IN constants.asm
                    > USED AT LINE 147 IN constants.asm
                    > USED AT LINE 148 IN constants.asm
                    > USED AT LINE 149 IN constants.asm
                    > USED AT LINE 150 IN constants.asm
                    > USED AT LINE 151 IN constants.asm
                    > USED AT LINE 152 IN constants.asm
                    > USED AT LINE 153 IN constants.asm
FLAG_:              0010 DEFINED AT LINE 126 IN constants.asm
                    > USED AT LINE 157 IN constants.asm
                    > USED AT LINE 158 IN constants.asm
                    > USED AT LINE 159 IN constants.asm
                    > USED AT LINE 160 IN constants.asm
                    > USED AT LINE 161 IN constants.asm
                    > USED AT LINE 162 IN constants.asm
                    > USED AT LINE 163 IN constants.asm
                    > USED AT LINE 164 IN constants.asm
IMMED_:             0020 DEFINED AT LINE 127 IN constants.asm
                    > USED AT LINE 226 IN MAIN.asm
                    > USED AT LINE 250 IN MAIN.asm
MEM_:               0040 DEFINED AT LINE 128 IN constants.asm
                    > USED AT LINE 250 IN MAIN.asm
IDX_:               0080 DEFINED AT LINE 129 IN constants.asm
REG8_IDX:           0000 DEFINED AT LINE 131 IN constants.asm
B_:                 0000 DEFINED AT LINE 133 IN constants.asm
C_:                 0013 DEFINED AT LINE 160 IN constants.asm
D_:                 0002 DEFINED AT LINE 135 IN constants.asm
E_:                 0003 DEFINED AT LINE 136 IN constants.asm
H_:                 0004 DEFINED AT LINE 137 IN constants.asm
L_:                 0005 DEFINED AT LINE 138 IN constants.asm
MHL_:               0006 DEFINED AT LINE 139 IN constants.asm
A_:                 0007 DEFINED AT LINE 140 IN constants.asm
I_:                 0008 DEFINED AT LINE 141 IN constants.asm
R_:                 0009 DEFINED AT LINE 142 IN constants.asm
REG16_IDX:          0000 DEFINED AT LINE 144 IN constants.asm
BC_:                0008 DEFINED AT LINE 146 IN constants.asm
DE_:                0009 DEFINED AT LINE 147 IN constants.asm
HL_:                000A DEFINED AT LINE 148 IN constants.asm
SP_:                000B DEFINED AT LINE 149 IN constants.asm
IX_:                000D DEFINED AT LINE 150 IN constants.asm
                    > USED AT LINE 575 IN MAIN.asm
IY_:                000E DEFINED AT LINE 151 IN constants.asm
                    > USED AT LINE 577 IN MAIN.asm
AFP_:               000C DEFINED AT LINE 152 IN constants.asm
AF_:                000F DEFINED AT LINE 153 IN constants.asm
FLAG_IDX:           0000 DEFINED AT LINE 155 IN constants.asm
NZ_:                0010 DEFINED AT LINE 157 IN constants.asm
Z_:                 0011 DEFINED AT LINE 158 IN constants.asm
NC_:                0012 DEFINED AT LINE 159 IN constants.asm
PO_:                0014 DEFINED AT LINE 161 IN constants.asm
PE_:                0015 DEFINED AT LINE 162 IN constants.asm
P_:                 0016 DEFINED AT LINE 163 IN constants.asm
M_:                 0017 DEFINED AT LINE 164 IN constants.asm
DIRECTIVE_IDX:      0000 DEFINED AT LINE 166 IN constants.asm
ALIGN_:             0000 DEFINED AT LINE 168 IN constants.asm
DB_:                0001 DEFINED AT LINE 169 IN constants.asm
ORG_:               0002 DEFINED AT LINE 170 IN constants.asm
TEC_1:              0001 DEFINED AT LINE 175 IN constants.asm
RC2014:             0000 DEFINED AT LINE 176 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 178 IN constants.asm
LOADER:             0000 DEFINED AT LINE 180 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 181 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 33 IN IOSerial.asm
                    > USED AT LINE 478 IN IOSerial.asm
                    > USED AT LINE 500 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 34 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 322 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 36 IN IOSerial.asm
                    > USED AT LINE 326 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 477 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 46 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 50 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 51 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 52 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 53 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 54 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 55 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 56 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 57 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 61 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 62 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 63 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 64 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 68 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 72 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 73 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 74 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 75 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 76 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 77 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 78 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 79 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 87 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 88 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 89 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 90 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 91 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 92 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 93 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 94 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 108 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 109 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 113 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 163 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 483 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 187 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 193 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 196 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 471 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 305 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 308 IN IOSerial.asm
                    > USED AT LINE 312 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 320 IN IOSerial.asm
                    > USED AT LINE 469 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 321 IN IOSerial.asm
                    > USED AT LINE 325 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 445 IN IOSerial.asm
                    > USED AT LINE 1031 IN MAIN.asm
PUTCHAR:            0087 DEFINED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 1057 IN MAIN.asm
                    > USED AT LINE 1218 IN MAIN.asm
                    > USED AT LINE 1243 IN MAIN.asm
RESET:              008D DEFINED AT LINE 457 IN IOSerial.asm
                    > USED AT LINE 114 IN IOSerial.asm
START:              0180 DEFINED AT LINE 37 IN MAIN.asm
                    > USED AT LINE 6
INIT:               0198 DEFINED AT LINE 60 IN MAIN.asm
                    > USED AT LINE 39 IN MAIN.asm
PARSE:              01C0 DEFINED AT LINE 94 IN MAIN.asm
                    > USED AT LINE 42 IN MAIN.asm
PARSEERROR:         01E7 DEFINED AT LINE 100 IN MAIN.asm
                    > USED AT LINE 125 IN MAIN.asm
                    > USED AT LINE 256 IN MAIN.asm
STATEMENTLIST:      01FA DEFINED AT LINE 121 IN MAIN.asm
                    > USED AT LINE 95 IN MAIN.asm
                    > USED AT LINE 128 IN MAIN.asm
STATEMENT:          020A DEFINED AT LINE 147 IN MAIN.asm
                    > USED AT LINE 123 IN MAIN.asm
STATEMENT1:         0230 DEFINED AT LINE 166 IN MAIN.asm
                    > USED AT LINE 161 IN MAIN.asm
INSTRUCTION:        0239 DEFINED AT LINE 173 IN MAIN.asm
                    > USED AT LINE 168 IN MAIN.asm
DIRECTIVE:          0256 DEFINED AT LINE 187 IN MAIN.asm
                    > USED AT LINE 170 IN MAIN.asm
OPERAND:            0257 DEFINED AT LINE 217 IN MAIN.asm
                    > USED AT LINE 177 IN MAIN.asm
                    > USED AT LINE 183 IN MAIN.asm
OPERAND1:           0267 DEFINED AT LINE 229 IN MAIN.asm
                    > USED AT LINE 222 IN MAIN.asm
OPERAND3:           027E DEFINED AT LINE 243 IN MAIN.asm
OPERAND2:           0282 DEFINED AT LINE 247 IN MAIN.asm
                    > USED AT LINE 232 IN MAIN.asm
OPERAND4:           028C DEFINED AT LINE 253 IN MAIN.asm
                    > USED AT LINE 236 IN MAIN.asm
                    > USED AT LINE 245 IN MAIN.asm
                    > USED AT LINE 251 IN MAIN.asm
NEWSYMBOL:          0295 DEFINED AT LINE 259 IN MAIN.asm
                    > USED AT LINE 163 IN MAIN.asm
NEWEXPR:            0296 DEFINED AT LINE 264 IN MAIN.asm
                    > USED AT LINE 224 IN MAIN.asm
                    > USED AT LINE 238 IN MAIN.asm
                    > USED AT LINE 248 IN MAIN.asm
NEXTTOKEN:          0297 DEFINED AT LINE 299 IN MAIN.asm
                    > USED AT LINE 122 IN MAIN.asm
                    > USED AT LINE 164 IN MAIN.asm
                    > USED AT LINE 176 IN MAIN.asm
                    > USED AT LINE 179 IN MAIN.asm
                    > USED AT LINE 182 IN MAIN.asm
                    > USED AT LINE 230 IN MAIN.asm
                    > USED AT LINE 254 IN MAIN.asm
NEXTTOKEN0:         02A8 DEFINED AT LINE 308 IN MAIN.asm
                    > USED AT LINE 301 IN MAIN.asm
                    > USED AT LINE 340 IN MAIN.asm
NEXTTOKEN1:         02AB DEFINED AT LINE 311 IN MAIN.asm
                    > USED AT LINE 314 IN MAIN.asm
NEXTTOKEN1A:        02B6 DEFINED AT LINE 317 IN MAIN.asm
NEXTTOKEN2:         02B9 DEFINED AT LINE 321 IN MAIN.asm
                    > USED AT LINE 316 IN MAIN.asm
NEXTTOKEN3:         02C8 DEFINED AT LINE 331 IN MAIN.asm
                    > USED AT LINE 323 IN MAIN.asm
                    > USED AT LINE 325 IN MAIN.asm
                    > USED AT LINE 327 IN MAIN.asm
NEXTTOKEN4:         02CD DEFINED AT LINE 335 IN MAIN.asm
                    > USED AT LINE 338 IN MAIN.asm
NEXTTOKEN5:         02D9 DEFINED AT LINE 342 IN MAIN.asm
                    > USED AT LINE 333 IN MAIN.asm
NEXTTOKEN6:         02E2 DEFINED AT LINE 348 IN MAIN.asm
                    > USED AT LINE 344 IN MAIN.asm
NEXTTOKEN7:         02EC DEFINED AT LINE 355 IN MAIN.asm
                    > USED AT LINE 351 IN MAIN.asm
NEXTTOKEN8:         02FD DEFINED AT LINE 365 IN MAIN.asm
                    > USED AT LINE 359 IN MAIN.asm
NEXTTOKEN9:         0308 DEFINED AT LINE 373 IN MAIN.asm
                    > USED AT LINE 367 IN MAIN.asm
NEXTTOKEN10:        0316 DEFINED AT LINE 382 IN MAIN.asm
                    > USED AT LINE 376 IN MAIN.asm
NEXTTOKEN11:        0319 DEFINED AT LINE 386 IN MAIN.asm
                    > USED AT LINE 346 IN MAIN.asm
NEXTTOKEN11A:       032E DEFINED AT LINE 397 IN MAIN.asm
                    > USED AT LINE 392 IN MAIN.asm
NEXTTOKEN12:        0334 DEFINED AT LINE 402 IN MAIN.asm
                    > USED AT LINE 389 IN MAIN.asm
NEXTTOKEN13:        033D DEFINED AT LINE 408 IN MAIN.asm
                    > USED AT LINE 404 IN MAIN.asm
NEXTTOKEN14:        0340 DEFINED AT LINE 411 IN MAIN.asm
NEXTTOKEN15:        0343 DEFINED AT LINE 415 IN MAIN.asm
                    > USED AT LINE 406 IN MAIN.asm
PUSHBACKTOKEN:      034F DEFINED AT LINE 443 IN MAIN.asm
IDENT:              0358 DEFINED AT LINE 472 IN MAIN.asm
                    > USED AT LINE 349 IN MAIN.asm
IDENT1:             035D DEFINED AT LINE 476 IN MAIN.asm
                    > USED AT LINE 483 IN MAIN.asm
                    > USED AT LINE 485 IN MAIN.asm
IDENT3:             036D DEFINED AT LINE 486 IN MAIN.asm
EXPR:               0378 DEFINED AT LINE 515 IN MAIN.asm
EXPR1:              0380 DEFINED AT LINE 520 IN MAIN.asm
                    > USED AT LINE 536 IN MAIN.asm
                    > USED AT LINE 539 IN MAIN.asm
                    > USED AT LINE 542 IN MAIN.asm
                    > USED AT LINE 547 IN MAIN.asm
EXPR2:              03A0 DEFINED AT LINE 537 IN MAIN.asm
                    > USED AT LINE 525 IN MAIN.asm
EXPR3:              03A3 DEFINED AT LINE 540 IN MAIN.asm
                    > USED AT LINE 527 IN MAIN.asm
EXPR4:              03A8 DEFINED AT LINE 544 IN MAIN.asm
                    > USED AT LINE 529 IN MAIN.asm
                    > USED AT LINE 531 IN MAIN.asm
                    > USED AT LINE 533 IN MAIN.asm
                    > USED AT LINE 535 IN MAIN.asm
EXPR5:              03AC DEFINED AT LINE 548 IN MAIN.asm
                    > USED AT LINE 543 IN MAIN.asm
ISINDEXREG:         03B9 DEFINED AT LINE 574 IN MAIN.asm
                    > USED AT LINE 235 IN MAIN.asm
ISENDOFLINE:        03BF DEFINED AT LINE 597 IN MAIN.asm
                    > USED AT LINE 124 IN MAIN.asm
                    > USED AT LINE 158 IN MAIN.asm
ISALPHANUM:         03C5 DEFINED AT LINE 623 IN MAIN.asm
                    > USED AT LINE 391 IN MAIN.asm
                    > USED AT LINE 484 IN MAIN.asm
                    > USED AT LINE 534 IN MAIN.asm
ISALPHA:            03C9 DEFINED AT LINE 647 IN MAIN.asm
                    > USED AT LINE 345 IN MAIN.asm
ISALPHA1:           03CF DEFINED AT LINE 651 IN MAIN.asm
                    > USED AT LINE 649 IN MAIN.asm
ISDIGIT:            03D6 DEFINED AT LINE 675 IN MAIN.asm
                    > USED AT LINE 405 IN MAIN.asm
                    > USED AT LINE 624 IN MAIN.asm
NUMBER:             03DD DEFINED AT LINE 699 IN MAIN.asm
                    > USED AT LINE 409 IN MAIN.asm
NUMBER1:            03E4 DEFINED AT LINE 704 IN MAIN.asm
                    > USED AT LINE 702 IN MAIN.asm
NUMBER2:            03F3 DEFINED AT LINE 711 IN MAIN.asm
                    > USED AT LINE 708 IN MAIN.asm
NUMBER3:            03F9 DEFINED AT LINE 714 IN MAIN.asm
                    > USED AT LINE 710 IN MAIN.asm
                    > USED AT LINE 730 IN MAIN.asm
NUMBER_HEX:         0409 DEFINED AT LINE 725 IN MAIN.asm
                    > USED AT LINE 393 IN MAIN.asm
HEX:                0415 DEFINED AT LINE 748 IN MAIN.asm
                    > USED AT LINE 709 IN MAIN.asm
                    > USED AT LINE 729 IN MAIN.asm
HEX1:               0418 DEFINED AT LINE 750 IN MAIN.asm
                    > USED AT LINE 777 IN MAIN.asm
HEX2:               0428 DEFINED AT LINE 759 IN MAIN.asm
                    > USED AT LINE 757 IN MAIN.asm
UPPER:              042F DEFINED AT LINE 764 IN MAIN.asm
                    > USED AT LINE 763 IN MAIN.asm
VALID:              0431 DEFINED AT LINE 766 IN MAIN.asm
                    > USED AT LINE 755 IN MAIN.asm
DECIMAL:            0440 DEFINED AT LINE 795 IN MAIN.asm
                    > USED AT LINE 713 IN MAIN.asm
DECIMAL1:           0443 DEFINED AT LINE 797 IN MAIN.asm
                    > USED AT LINE 814 IN MAIN.asm
SEARCHSTR:          045B DEFINED AT LINE 837 IN MAIN.asm
                    > USED AT LINE 375 IN MAIN.asm
                    > USED AT LINE 846 IN MAIN.asm
                    > USED AT LINE 893 IN MAIN.asm
                    > USED AT LINE 897 IN MAIN.asm
                    > USED AT LINE 902 IN MAIN.asm
                    > USED AT LINE 907 IN MAIN.asm
                    > USED AT LINE 913 IN MAIN.asm
                    > USED AT LINE 943 IN MAIN.asm
                    > USED AT LINE 947 IN MAIN.asm
                    > USED AT LINE 952 IN MAIN.asm
SEARCHSTR1:         045E DEFINED AT LINE 842 IN MAIN.asm
                    > USED AT LINE 868 IN MAIN.asm
SEARCHSTR3:         046A DEFINED AT LINE 853 IN MAIN.asm
SEARCHOPCODE:       047E DEFINED AT LINE 891 IN MAIN.asm
                    > USED AT LINE 358 IN MAIN.asm
SEARCHOPELEM:       04AB DEFINED AT LINE 941 IN MAIN.asm
                    > USED AT LINE 366 IN MAIN.asm
COMPARESTR:         04C4 DEFINED AT LINE 977 IN MAIN.asm
                    > USED AT LINE 845 IN MAIN.asm
COMPARESTR2:        04C7 DEFINED AT LINE 982 IN MAIN.asm
                    > USED AT LINE 988 IN MAIN.asm
COMPARESTR3:        04CE DEFINED AT LINE 990 IN MAIN.asm
NEXTCHAR:           04CF DEFINED AT LINE 1010 IN MAIN.asm
                    > USED AT LINE 312 IN MAIN.asm
                    > USED AT LINE 336 IN MAIN.asm
                    > USED AT LINE 390 IN MAIN.asm
                    > USED AT LINE 480 IN MAIN.asm
                    > USED AT LINE 523 IN MAIN.asm
                    > USED AT LINE 706 IN MAIN.asm
                    > USED AT LINE 751 IN MAIN.asm
                    > USED AT LINE 798 IN MAIN.asm
                    > USED AT LINE 1081 IN MAIN.asm
NEXTLINE:           04E6 DEFINED AT LINE 1026 IN MAIN.asm
                    > USED AT LINE 1014 IN MAIN.asm
NEXTLINE1:          04EB DEFINED AT LINE 1030 IN MAIN.asm
                    > USED AT LINE 1048 IN MAIN.asm
                    > USED AT LINE 1054 IN MAIN.asm
                    > USED AT LINE 1076 IN MAIN.asm
NEXTLINE2:          04F9 DEFINED AT LINE 1039 IN MAIN.asm
                    > USED AT LINE 1035 IN MAIN.asm
NEXTLINE3:          04FD DEFINED AT LINE 1043 IN MAIN.asm
                    > USED AT LINE 1037 IN MAIN.asm
NEXTLINE4:          0511 DEFINED AT LINE 1056 IN MAIN.asm
                    > USED AT LINE 1045 IN MAIN.asm
NEXTLINE5:          051C DEFINED AT LINE 1064 IN MAIN.asm
                    > USED AT LINE 1060 IN MAIN.asm
NEXTLINE6:          0522 DEFINED AT LINE 1069 IN MAIN.asm
                    > USED AT LINE 1033 IN MAIN.asm
                    > USED AT LINE 1041 IN MAIN.asm
                    > USED AT LINE 1062 IN MAIN.asm
                    > USED AT LINE 1066 IN MAIN.asm
NEXTLINE7:          052E DEFINED AT LINE 1078 IN MAIN.asm
                    > USED AT LINE 1073 IN MAIN.asm
                    > USED AT LINE 1075 IN MAIN.asm
REWINDCHAR:         0535 DEFINED AT LINE 1100 IN MAIN.asm
                    > USED AT LINE 339 IN MAIN.asm
                    > USED AT LINE 356 IN MAIN.asm
                    > USED AT LINE 398 IN MAIN.asm
                    > USED AT LINE 549 IN MAIN.asm
                    > USED AT LINE 712 IN MAIN.asm
                    > USED AT LINE 722 IN MAIN.asm
                    > USED AT LINE 726 IN MAIN.asm
PROMPT:             053D DEFINED AT LINE 1124 IN MAIN.asm
CRLF:               0546 DEFINED AT LINE 1145 IN MAIN.asm
ERROR:              054D DEFINED AT LINE 1166 IN MAIN.asm
PRINT:              0552 DEFINED AT LINE 1187 IN MAIN.asm
                    > USED AT LINE 40 IN MAIN.asm
                    > USED AT LINE 96 IN MAIN.asm
                    > USED AT LINE 1052 IN MAIN.asm
                    > USED AT LINE 1125 IN MAIN.asm
                    > USED AT LINE 1146 IN MAIN.asm
PRINTSTR:           0559 DEFINED AT LINE 1210 IN MAIN.asm
                    > USED AT LINE 1168 IN MAIN.asm
PRINTSTR1:          055E DEFINED AT LINE 1216 IN MAIN.asm
                    > USED AT LINE 1220 IN MAIN.asm
PRINTZSTR:          0566 DEFINED AT LINE 1239 IN MAIN.asm
                    > USED AT LINE 1189 IN MAIN.asm
PRINTZSTR1:         0568 DEFINED AT LINE 1242 IN MAIN.asm
                    > USED AT LINE 1249 IN MAIN.asm
PRINTZSTR2:         056C DEFINED AT LINE 1246 IN MAIN.asm
                    > USED AT LINE 1240 IN MAIN.asm
ROT_OPCODES:        0571 DEFINED AT LINE 1 IN data.asm
                    > USED AT LINE 896 IN MAIN.asm
ALU_OPCODES:        0590 DEFINED AT LINE 13 IN data.asm
                    > USED AT LINE 892 IN MAIN.asm
BLI_OPCODES:        05AF DEFINED AT LINE 25 IN data.asm
                    > USED AT LINE 901 IN MAIN.asm
GEN1_OPCODES:       05FA DEFINED AT LINE 45 IN data.asm
                    > USED AT LINE 906 IN MAIN.asm
GEN2_OPCODES:       0623 DEFINED AT LINE 59 IN data.asm
                    > USED AT LINE 912 IN MAIN.asm
REG8:               068C DEFINED AT LINE 89 IN data.asm
                    > USED AT LINE 942 IN MAIN.asm
REG16:              06A1 DEFINED AT LINE 103 IN data.asm
                    > USED AT LINE 946 IN MAIN.asm
FLAGS:              06BB DEFINED AT LINE 115 IN data.asm
                    > USED AT LINE 951 IN MAIN.asm
DIRECTIVES:         06D0 DEFINED AT LINE 127 IN data.asm
                    > USED AT LINE 374 IN MAIN.asm
BUFFER:             3000 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 65 IN MAIN.asm
                    > USED AT LINE 1015 IN MAIN.asm
                    > USED AT LINE 1027 IN MAIN.asm
STACK:              3180 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 458 IN IOSerial.asm
                    > USED AT LINE 38 IN MAIN.asm
VTEMP1:             3180 DEFINED AT LINE 9 IN ram.asm
                    > USED AT LINE 705 IN MAIN.asm
                    > USED AT LINE 715 IN MAIN.asm
                    > USED AT LINE 728 IN MAIN.asm
VTEMP2:             3182 DEFINED AT LINE 10 IN ram.asm
VTOKEN:             3184 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 62 IN MAIN.asm
                    > USED AT LINE 300 IN MAIN.asm
                    > USED AT LINE 302 IN MAIN.asm
                    > USED AT LINE 305 IN MAIN.asm
                    > USED AT LINE 445 IN MAIN.asm
VTOKENVAL:          3185 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 70 IN MAIN.asm
                    > USED AT LINE 303 IN MAIN.asm
                    > USED AT LINE 446 IN MAIN.asm
VBUFFERPOS:         3187 DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 63 IN MAIN.asm
                    > USED AT LINE 1011 IN MAIN.asm
                    > USED AT LINE 1079 IN MAIN.asm
                    > USED AT LINE 1101 IN MAIN.asm
VASMPTR:            3189 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 67 IN MAIN.asm
                    > USED AT LINE 162 IN MAIN.asm
VSTRPTR:            318B DEFINED AT LINE 16 IN ram.asm
                    > USED AT LINE 69 IN MAIN.asm
                    > USED AT LINE 357 IN MAIN.asm
                    > USED AT LINE 473 IN MAIN.asm
                    > USED AT LINE 487 IN MAIN.asm
                    > USED AT LINE 516 IN MAIN.asm
                    > USED AT LINE 550 IN MAIN.asm
VSYMPTR:            318D DEFINED AT LINE 17 IN ram.asm
                    > USED AT LINE 72 IN MAIN.asm
VEXPRPTR:           318F DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 74 IN MAIN.asm
VOPCODE:            3191 DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 150 IN MAIN.asm
                    > USED AT LINE 175 IN MAIN.asm
VOPERAND1:          3192 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 151 IN MAIN.asm
                    > USED AT LINE 178 IN MAIN.asm
VOPERAND2:          3193 DEFINED AT LINE 22 IN ram.asm
                    > USED AT LINE 152 IN MAIN.asm
                    > USED AT LINE 184 IN MAIN.asm
VOPEXPR:            3194 DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 154 IN MAIN.asm
                    > USED AT LINE 225 IN MAIN.asm
                    > USED AT LINE 249 IN MAIN.asm
VOPDISP:            3196 DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 155 IN MAIN.asm
                    > USED AT LINE 239 IN MAIN.asm
STRINGS:            3198 DEFINED AT LINE 27 IN ram.asm
                    > USED AT LINE 68 IN MAIN.asm
SYMBOLS:            3298 DEFINED AT LINE 28 IN ram.asm
                    > USED AT LINE 71 IN MAIN.asm
EXPRS:              3398 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 73 IN MAIN.asm
RST08:              3498 DEFINED AT LINE 31 IN ram.asm
                    > USED AT LINE 118 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
RST10:              349A DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 124 IN IOSerial.asm
                    > USED AT LINE 461 IN IOSerial.asm
RST18:              349C DEFINED AT LINE 33 IN ram.asm
                    > USED AT LINE 130 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RST20:              349E DEFINED AT LINE 34 IN ram.asm
                    > USED AT LINE 136 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
RST28:              34A0 DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
RST30:              34A2 DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 148 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
BAUD:               34A4 DEFINED AT LINE 37 IN ram.asm
INTVEC:             34A6 DEFINED AT LINE 38 IN ram.asm
                    > USED AT LINE 154 IN IOSerial.asm
                    > USED AT LINE 466 IN IOSerial.asm
NMIVEC:             34A8 DEFINED AT LINE 39 IN ram.asm
                    > USED AT LINE 202 IN IOSerial.asm
                    > USED AT LINE 467 IN IOSerial.asm
GETCVEC:            34AA DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 447 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
PUTCVEC:            34AC DEFINED AT LINE 41 IN ram.asm
                    > USED AT LINE 453 IN IOSerial.asm
                    > USED AT LINE 472 IN IOSerial.asm
ASSEMBLY:           34AE DEFINED AT LINE 43 IN ram.asm
                    > USED AT LINE 66 IN MAIN.asm
