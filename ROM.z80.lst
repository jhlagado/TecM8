0000                          .ENGINE   mycomputer   
0000                             ; 
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $0800   
0000                ROMSIZE:   EQU   $0800   
0000                RAMSIZE:   EQU   $0800   
0000                NO_MATCH:   EQU   -1   
0000                CTRL_H:   EQU   8   
0000                TOKENS:      
0000                COMMA_:   EQU   ","   
0000                COMMENT_:   EQU   ";"   
0000                DIRECT_:   EQU   "D"   
0000                ASMLOC_:   EQU   "$"   
0000                END_:     EQU   "E"   
0000                EOF_:     EQU   0   
0000                FLAG_:    EQU   "F"   
0000                IDENT_:   EQU   "I"   
0000                LABEL_:   EQU   "L"   
0000                NEWLN_:   EQU   "\n"   
0000                NUM_:     EQU   "9"   
0000                OPCODE_:   EQU   "C"   
0000                PARCLOSE_:   EQU   ")"   
0000                PAROPEN_:   EQU   "("   
0000                REG_:     EQU   "R"   
0000                REGPAIR_:   EQU   "P"   
0000                UNKNOWN_:   EQU   -1   
0000                OPCODE_IDX:      
0000                ADC_:     EQU   0   
0000                ADD_:     EQU   1   
0000                AND_:     EQU   2   
0000                BIT_:     EQU   3   
0000                CALL_:    EQU   4   
0000                CCF_:     EQU   5   
0000                CP_:      EQU   6   
0000                CPD_:     EQU   7   
0000                CPDR_:    EQU   8   
0000                CPI_:     EQU   9   
0000                CPIR_:    EQU   10   
0000                CPL_:     EQU   11   
0000                DAA_:     EQU   12   
0000                DEC_:     EQU   13   
0000                DI_:      EQU   14   
0000                DJNZ_:    EQU   15   
0000                EI_:      EQU   16   
0000                EX_:      EQU   17   
0000                EXX_:     EQU   18   
0000                HALT_:    EQU   19   
0000                IM_:      EQU   20   
0000                IN_:      EQU   21   
0000                INC_:     EQU   22   
0000                IND_:     EQU   23   
0000                INDR_:    EQU   24   
0000                INI_:     EQU   25   
0000                INIR_:    EQU   26   
0000                JP_:      EQU   27   
0000                JR_:      EQU   28   
0000                LD_:      EQU   29   
0000                LDD_:     EQU   30   
0000                LDDR_:    EQU   31   
0000                LDI_:     EQU   32   
0000                LDIR_:    EQU   33   
0000                NEG_:     EQU   34   
0000                NOP_:     EQU   35   
0000                OR_:      EQU   36   
0000                OTDR_:    EQU   37   
0000                OTIR_:    EQU   38   
0000                OUT_:     EQU   39   
0000                OUTD_:    EQU   40   
0000                OUTI_:    EQU   41   
0000                POP_:     EQU   42   
0000                PUSH_:    EQU   43   
0000                RES_:     EQU   44   
0000                RET_:     EQU   45   
0000                RETI_:    EQU   46   
0000                RETN_:    EQU   47   
0000                RL_:      EQU   48   
0000                RLA_:     EQU   49   
0000                RLC_:     EQU   50   
0000                RLCA_:    EQU   51   
0000                RLD_:     EQU   52   
0000                RR_:      EQU   53   
0000                RRA_:     EQU   54   
0000                RRC_:     EQU   55   
0000                RRCA_:    EQU   56   
0000                RRD_:     EQU   57   
0000                RST_:     EQU   58   
0000                SBC_:     EQU   59   
0000                SCF_:     EQU   60   
0000                SET_:     EQU   61   
0000                SLA_:     EQU   62   
0000                SRA_:     EQU   63   
0000                SRL_:     EQU   64   
0000                SUB_:     EQU   65   
0000                XOR_:     EQU   66   
0000                REG_IDX:      
0000                B_:       EQU   0   ; B
0000                C_:       EQU   1   ; C
0000                D_:       EQU   2   ; D
0000                E_:       EQU   3   ; E
0000                H_:       EQU   4   ; H
0000                L_:       EQU   5   ; L
0000                MHL_:     EQU   6   ; (HL)
0000                A_:       EQU   7   ; A
0000                I_:       EQU   8   ; I
0000                R_:       EQU   9   ; R
0000                REG_PAIR_IDX:      
0000                BC_:      EQU   0   
0000                DE_:      EQU   1   
0000                HL_:      EQU   2   
0000                SP_:      EQU   3   
0000                AF_:      EQU   4   ; NOTE: AF has the same code as SP in some instructions
0000                IX_:      EQU   5   
0000                IY_:      EQU   6   
0000                AFP_:     EQU   7   ; AF' (prime)
0000                FLAG_IDX:      
0000                NZ_:      EQU   0   
0000                Z_:       EQU   1   
0000                NC_:      EQU   2   
0000                C_:       EQU   3   
0000                PO_:      EQU   4   
0000                PE_:      EQU   5   
0000                P_:       EQU   6   
0000                M_:       EQU   7   
0000                DIRECTIVE_IDX:      
0000                ALIGN_:   EQU   0   
0000                DB_:      EQU   1   
0000                ORG_:     EQU   2   
0000                SET_:     EQU   3   
0000                             ; -----------------------------------------------------------------------------------------------
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                             ; *************************************************************************
0000                             ; 
0000                             ;       Serial routines 
0000                             ; 
0000                             ;       written by Craig Jones 
0000                             ; 
0000                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
0000                             ; 
0000                             ;       see the LICENSE file in this repo for more information 
0000                             ; 
0000                             ; *****************************************************************************
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8B 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 00 08               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 02 08               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 04 08               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A 06 08               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A 08 08               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A 0A 08               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A 0E 08               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A 10 08               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   2A 12 08               LD   HL,(GETCVEC)   
0084   E9                     JP   (HL)   
0085                             ; 
0085                PUTCHAR:      
0085   E5                     PUSH   HL   
0086   2A 14 08               LD   HL,(PUTCVEC)   
0089   E3                     EX   (SP),HL   
008A   C9                     RET      
008B                             ; 
008B                RESET:       
008B   31 28 0A               LD   SP,stack   
008E   21 5F 00               LD   HL,IntRet   
0091   22 00 08               LD   (RST08),HL   
0094   22 02 08               LD   (RST10),HL   
0097   22 04 08               LD   (RST18),HL   
009A   22 06 08               LD   (RST20),HL   
009D   22 08 08               LD   (RST28),HL   
00A0   22 0A 08               LD   (RST30),HL   
00A3   22 0E 08               LD   (INTVEC),HL   
00A6   22 10 08               LD   (NMIVEC),HL   
00A9                             ; 
00A9   21 78 00               LD   HL,RXDATA   
00AC   22 12 08               LD   (GETCVEC),HL   
00AF   21 6B 00               LD   HL,TXDATA   
00B2   22 14 08               LD   (PUTCVEC),HL   
00B5                             ; 
00B5                          IF   TEC_1   
00B5                          IF   BITBANG = 0   
00B5                             ; 
00B5   3E 03                  LD   a,MRESET   
00B7   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B9                             ; 
00B9                          ENDIF      
00B9                          ENDIF      
00B9                             ; 
00B9   CD 50 00               CALL   PWRUP   
00BC   ED 56                  IM   1   
00BE   FB                     EI      
00BF                             ; 
00BF                          IF   TEC_1   
00BF                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00BF                          ELSE      ;6850      
00BF                             ; 
00BF   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C1   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C3                             ; 
00C3                          ENDIF      
00C3                          ENDIF      
00C3                             ; 
00C3                             ; 
00C3                             ; 
00C3   C3 80 01               JP   start   
00C6                             ; 
00C6                             ; *************************************************************************
00C6                             ; 
00C6                             ;       TecM8 1.0 Assembler for the Tec-1
00C6                             ; 
00C6                             ;       by John Hardy
00C6                             ; 
00C6                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
00C6                             ; 
00C6                             ;       see the LICENSE file in this repo for more information
00C6                             ; 
00C6                             ; *****************************************************************************
00C6                             ; **************************************************************************
00C6                             ; Page 0  Initialisation
00C6                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put TecM8 code from here	
0180                START:       ; entry point of TecM8
0180   31 28 0A               LD   sp,STACK   
0183   CD 98 01               CALL   init   
0186   CD D8 03               CALL   print   
0189   0B 54 65 63 4D 38 20 30 2E 30 0D 0A .PSTR   "TecM8 0.0\r\n"   
0195   C3 C1 01               JP   parse   
0198                INIT:        
0198   AF                     XOR   a   
0199   32 1A 08               LD   (vPushBack),a   ; nothing in push back buffer
019C   32 1B 08               LD   (vToken),a   ; NUL_ token
019F   21 28 08               LD   hl,chars   
01A2   22 1E 08               LD   (vCharPtr),hl   
01A5   21 28 0D               LD   hl,assembly   
01A8   22 20 08               LD   (vAsmPtr),hl   
01AB   21 28 0A               LD   hl,strings   
01AE   22 22 08               LD   (vStrPtr),hl   
01B1   22 1C 08               LD   (vTokenVal),hl   
01B4   21 28 0B               LD   hl,symbols   
01B7   22 24 08               LD   (vSymPtr),hl   
01BA   21 28 0C               LD   hl,exprs   
01BD   22 26 08               LD   (vExprPtr),hl   
01C0   C9                     RET      
01C1                PARSE:       
01C1   CD E8 01               CALL   statementList   
01C4   CD D8 03               CALL   print   
01C7   1F 50 61 72 73 69 6E 67 20 63 6F 6D 70 6C 65 74 65 64 20 73 75 63 63 65 73 73 66 75 6C 6C 79 2E .PSTR   "Parsing completed successfully."   ; 
01E7   76                     HALT      
01E8                STATEMENTLIST:      
01E8   3A 1B 08               LD   a,(vToken)   
01EB   FE 00                  CP   EOF_   
01ED   C8                     RET   z   
01EE   CD 0C 02               CALL   statement   
01F1   FE 45                  CP   END_   
01F3   CD 0D 02               CALL   match   
01F6   28 F0                  JR   z,statementList   
01F8   CD D3 03               CALL   error   
01FB   10 45 78 70 65 63 74 65 64 20 6E 65 77 6C 69 6E 65 .PSTR   "Expected newline"   
020C                STATEMENT:      
020C   C9                     RET      
020D                MATCH:       
020D   C0                     RET   nz   
020E   F5                     PUSH   af   
020F   CD 16 02               CALL   nextToken   
0212   6F                     LD   l,a   
0213   F1                     POP   af   
0214   7D                     LD   a,l   
0215   C9                     RET      
0216                             ; nextToken is a lexer function that reads characters from the input and classifies
0216                             ; them into different token types. It handles whitespace, end of input, newlines,
0216                             ; comments, identifiers, labels, directives, hexadecimal numbers, and other symbols.
0216                             ; Input: None
0216                             ; Output:
0216                             ; a: contains the type of the next token.
0216                             ; hl: contains the value associated with the next token.
0216                             ; Destroyed: None
0216                NEXTTOKEN:      
0216   21 00 00               LD   hl,0   
0219                NEXTTOKEN1:      
0219   CD AF 03               CALL   nextChar   ; Get the next character
021C   CD EA 02               CALL   isSpace   ; Is it a space?
021F   28 F8                  JR   z,nextToken1   ; If yes, skip it and get the next character
0221   B7                     OR   a   ; Is it null (end of input)?
0222   20 03                  JR   nz,nextToken2   ; If not, continue to the next check
0224   3E 00                  LD   a,EOF_   ; If yes, return with EOF token
0226   C9                     RET      
0227                NEXTTOKEN2:      
0227   FE 0A                  CP   "\n"   ; Is it a newline?
0229   20 03                  JR   nz,nextToken2x   ; If not, continue to the next check
022B   3E 0A                  LD   a,NEWLN_   ; If yes, return with NEWLN token
022D   C9                     RET      
022E                NEXTTOKEN2X:      
022E   FE 3B                  CP   ";"   ; Is it a comment?
0230   C4 3D 02               CALL   nz,nextToken4   ; If not, continue to the next check
0233                NEXTTOKEN3:      
0233   CD AF 03               CALL   nextChar   ; Get the next character in the comment
0236   FE 21                  CP   " "+1   ; Loop until the next control character
0238   30 F9                  JR   nc,nextToken3   
023A   3E 3B                  LD   a,COMMENT_   ; Return with COMMENT token
023C   C9                     RET      
023D                NEXTTOKEN4:      
023D   FE 5F                  CP   "_"   ; Is it an identifier?
023F   28 05                  JR   z,nextToken5   ; If yes, continue to the next check
0241   CD F0 02               CALL   isAlphaNum   ; If not, check if it's alphanumeric
0244   30 4D                  JR   nc,nextToken7   ; If not, continue to the next check
0246                NEXTTOKEN5:      
0246   CD C5 02               CALL   ident   ; Parse the identifier
0249   CD AF 03               CALL   nextChar   ; Get the next character
024C   FE 3A                  CP   ":"   ; Is it a label?
024E   20 03                  JR   nz,nextToken6   ; If not, continue to the next check
0250   3E 4C                  LD   a,LABEL_   ; If yes, return with LABEL token
0252   C9                     RET      
0253                NEXTTOKEN6:      
0253   CD BD 03               CALL   pushBackChar   ; Push back the character
0256   22 22 08               LD   (vStrPtr),hl   ; restore string heap ptr to prev location
0259   11 EA 03               LD   de,opcodes   ; list of opcodes to search
025C   CD 85 03               CALL   searchStr   
025F   30 03                  JR   nc,nextToken7z   
0261   3E 43                  LD   a,OPCODE_   ; Return with IDENT token
0263   C9                     RET      
0264                NEXTTOKEN7Z:      
0264   11 12 05               LD   de,reg_pairs   ; list of register pairs to search
0267   CD 85 03               CALL   searchStr   
026A   30 03                  JR   nc,nextToken7y   
026C   3E 50                  LD   a,REGPAIR_   ; Return with REGPAIR token
026E   C9                     RET      
026F                NEXTTOKEN7Y:      
026F   11 FD 04               LD   de,registers   ; list of registers to search
0272   CD 85 03               CALL   searchStr   
0275   30 03                  JR   nc,nextToken7x   
0277   3E 52                  LD   a,REG_   ; Return with REG token
0279   C9                     RET      
027A                NEXTTOKEN7X:      
027A   11 2C 05               LD   de,flags   ; list of registers to search
027D   CD 85 03               CALL   searchStr   
0280   30 F8                  JR   nc,nextToken7x   
0282   3E 46                  LD   a,FLAG_   ; Return with FLAG token
0284   C9                     RET      
0285                NEXTTOKEN7A:      
0285   11 2C 05               LD   de,flags   ; list of registers to search
0288   CD 85 03               CALL   searchStr   
028B   30 03                  JR   nc,nextToken7b   
028D   3E 44                  LD   a,DIRECT_   ; Return with DIRECT token
028F   C9                     RET      
0290                NEXTTOKEN7B:      
0290   3E 49                  LD   a,IDENT_   ; Return with IDENT token
0292   C9                     RET      
0293                NEXTTOKEN7:      
0293   21 00 00               LD   hl,0   
0296   FE 24                  CP   "$"   ; Is it a hexadecimal number?
0298   20 13                  JR   nz,nextToken8   ; If not, continue to the next check
029A   CD AF 03               CALL   nextChar   ; Get the next character
029D   CD EA 02               CALL   isSpace   ; Check if it's the assembly pointer
02A0   CD BD 03               CALL   pushBackChar   ; Push back the character (flags unaffected)
02A3   20 03                  JR   nz,nextToken8a   
02A5   3E 24                  LD   a,ASMLOC_   
02A7   C9                     RET      
02A8                NEXTTOKEN8A:      
02A8   CD 3C 03               CALL   hex   
02AB   18 0C                  JR   nextToken9a   
02AD                NEXTTOKEN8:      
02AD   FE 2D                  CP   "-"   ; Is it a negative number?
02AF   28 05                  JR   z,nextToken9   ; If yes, continue to the next check
02B1   CD 09 03               CALL   isDigit   ; Check if it's a digit
02B4   30 09                  JR   nc,nextToken10   ; Jump to the next check
02B6                NEXTTOKEN9:      
02B6   CD 10 03               CALL   number   ; Parse the number
02B9                NEXTTOKEN9A:      
02B9   CD BD 03               CALL   pushBackChar   ; Push back the character
02BC   3E 39                  LD   a,NUM_   ; Return with NUM token
02BE   C9                     RET      
02BF                NEXTTOKEN10:      
02BF   6F                     LD   l,a   ; Load the token into L
02C0   26 00                  LD   h,0   ; Clear H
02C2   3E FF                  LD   a,UNKNOWN_   ; Return with UNKNOWN token
02C4   C9                     RET      
02C5                             ; ident
02C5                             ; 
02C5                             ; Reads characters from the input stream and stores them in a string on the heap
02C5                             ; until a non-alphanumeric character is encountered. The string is stored in
02C5                             ; Pascal string format, with the length of the string stored in the first byte.
02C5                             ; 
02C5                             ; Input:
02C5                             ;   a: The first character of the identifier.
02C5                             ;   (vStrPtr): Points to the top of the strings heap.
02C5                             ; 
02C5                             ; Output:
02C5                             ;   hl: Points to the start of the stored string in memory.
02C5                             ;   a: Contains the length of the string.
02C5                             ;   (vStrPtr): Updated to point to the top of the strings heap after the stored string.
02C5                             ; 
02C5                             ; Destroyed:
02C5                             ;   c, de
02C5                IDENT:       
02C5   2A 22 08               LD   hl,(vStrPtr)   ; de = hl = top of strings heap
02C8   54 5D                  LD   de,hl   
02CA   23                     INC   hl   ; skip length byte
02CB                IDENT1:      
02CB   77                     LD   (hl),a   ; write char
02CC   23                     INC   hl   
02CD   CD AF 03               CALL   nextChar   
02D0   FE 5F                  CP   "_"   
02D2   28 05                  JR   z,ident2   
02D4   CD F0 02               CALL   isAlphanum   
02D7   30 04                  JR   nc,ident3   
02D9                IDENT2:      
02D9   77                     LD   (hl),a   
02DA   23                     INC   hl   
02DB   18 EE                  JR   ident1   
02DD                IDENT3:      
02DD   CD BD 03               CALL   pushBackChar   
02E0   22 22 08               LD   (vStrPtr),hl   ; update top of strings heap
02E3   B7                     OR   a   
02E4   ED 52                  SBC   hl,de   ; hl = length, de = string
02E6   EB                     EX   de,hl   ; e = len, hl = string
02E7   73                     LD   (hl),e   ; save lsb(length)
02E8   7B                     LD   a,e   ; a = length
02E9   C9                     RET      
02EA                             ; isSpace
02EA                             ; checks if the character in the a register is space or tab
02EA                             ; Input:
02EA                             ;   a: Contains the character to be checked.
02EA                             ; Output:
02EA                             ;   a: Contains the character to be checked.
02EA                             ;   cf: Set if the input character was alphabetic, cleared otherwise.
02EA                             ; Destroyed:
02EA                             ;   none
02EA                ISSPACE:      
02EA   FE 20                  CP   " "   ; is char lowercase?
02EC   C8                     RET   z   
02ED   FE 09                  CP   "\t"   ; is char > last letter?
02EF   C9                     RET      
02F0                             ; isAlphaNum
02F0                             ; checks if the character in the a register is an alphanumeric character
02F0                             ; (either uppercase or lowercase).
02F0                             ; If the character is alphabetic, it converts it to uppercase and sets the carry flag.
02F0                             ; If the character is not alphabetic, it clears the carry flag.
02F0                             ; Input:
02F0                             ; a: Contains the character to be checked.
02F0                             ; Output:
02F0                             ; a: Contains the uppercase version of the input character if it was alphabetic.
02F0                             ; cf: Set if the input character was alphabetic, cleared otherwise.
02F0                             ; Destroyed: c
02F0                ISALPHANUM:      
02F0   CD 09 03               CALL   isDigit   
02F3   C8                     RET   z   ; falls thru to isAlpha
02F4                             ; isAlpha
02F4                             ; checks if the character in the a register is an alphabetic character
02F4                             ; (either uppercase or lowercase).
02F4                             ; If the character is alphabetic, it converts it to uppercase and sets the carry flag.
02F4                             ; Input:
02F4                             ;   a: Contains the character to be checked.
02F4                             ; Output:
02F4                             ;   a: Contains the uppercase version of the input character if it was alphabetic.
02F4                             ;   cf: Set if the input character was alphabetic, cleared otherwise.
02F4                             ; Destroyed:
02F4                             ;   none
02F4                ISALPHA:      
02F4   FE 61                  CP   "a"   ; is char lowercase?
02F6   38 02                  JR   c,isAlpha1   
02F8   D6 20                  SUB   $20   ; yes, convert a to uppercase
02FA                ISALPHA1:      
02FA   FE 5B                  CP   "Z"+1   ; is char > last letter?
02FC   D0                     RET   nc   ; yes, exit with cf cleared
02FD   FE 41                  CP   "A"   ; is char an uppercase letter ?
02FF   3F                     CCF      ; invert cf
0300   C9                     RET      
0301                             ; isHexDigit
0301                             ; checks if the character in the a register is a hexadecimal
0301                             ; digit (0-9, A-F, a-f). If the character is a hex digit, it sets the carry flag.
0301                             ; Input:
0301                             ;   a: Contains the character to be checked.
0301                             ; Output:
0301                             ;   cf: Set if the input character was a hex digit, cleared otherwise.
0301                             ; Destroyed:
0301                             ;   none
0301                ISHEXDIGIT:      
0301   CD F4 02               CALL   isAlpha   
0304   30 03                  JR   nc,isDigit   
0306   FE 47                  CP   "F"+1   
0308   D0                     RET   nc   ; > "F", not hex, cf = false
0309                ISHEXDIGIT1:      
0309                             ; isDigit
0309                             ; checks if the character in the a register is a decimal
0309                             ; digit (0-9). If the character is a decimal digit, it sets the carry flag.
0309                             ; Input:
0309                             ;   a: Contains the character to be checked.
0309                             ; Output:
0309                             ;   cf: Set if the input character was a digit, cleared otherwise.
0309                             ; Destroyed:
0309                             ;   none
0309                ISDIGIT:      
0309   FE 3A                  CP   "9"+1   ; is char > "9"?
030B   D0                     RET   nc   ; yes, exit with cf cleared
030C   FE 30                  CP   "0"   ; is char a decimal digit ?
030E   3F                     CCF      ; invert cf
030F   C9                     RET      
0310                             ; number
0310                             ; parse a number from the input. It handles both decimal and hexadecimal
0310                             ; numbers, and also supports negative numbers.
0310                             ; Input:
0310                             ;   none
0310                             ; Output:
0310                             ;   hl: Contains the parsed number.
0310                             ; Destroyed:
0310                             ;   none
0310                             ; vTemp1: A temporary memory location used to store the sign of the number.
0310                NUMBER:      
0310   FE 2D                  CP   "-"   ; Is it a negative number?
0312   3E FF                  LD   a,-1   ; a = sign flag
0314   28 01                  JR   z,number1   
0316   3C                     INC   a   
0317                NUMBER1:      
0317   32 16 08               LD   (vTemp1),a   ; Store the sign flag in vTemp1
031A   CD AF 03               CALL   nextChar   ; Get the next character
031D   FE 24                  CP   "$"   ; Is it a hexadecimal number?
031F   20 05                  JR   nz,number2   
0321   CD 3C 03               CALL   hex   ; If yes, parse the hexadecimal number
0324   18 06                  JR   number3   
0326                NUMBER2:      
0326   CD BD 03               CALL   pushBackChar   ; Push back the character
0329   CD 67 03               CALL   decimal   ; Parse the decimal number
032C                NUMBER3:      
032C   3A 16 08               LD   a,(vTemp1)   ; Load the sign from vTemp1
032F   3C                     INC   a   ; Increment a
0330   C0                     RET   nz   
0331   EB                     EX   de,hl   ; negate the value of HL
0332   21 00 00               LD   hl,0   
0335   B7                     OR   a   
0336   ED 52                  SBC   hl,de   
0338   CD BD 03               CALL   pushBackChar   ; Push back the character
033B   C9                     RET      
033C                             ; hex
033C                             ; parses a hexadecimal number
033C                             ; Input: none
033C                             ; Output:
033C                             ; hl: parsed number
033C                             ; Destroyed: a
033C                HEX:         
033C   21 00 00               LD   hl,0   ; Initialize HL to 0 to hold the result
033F                HEX1:        
033F   CD AF 03               CALL   nextChar   
0342   FE 30                  CP   "0"   ; Compare with ASCII "0"
0344   D8                     RET   c   ; If less, exit
0345   FE 3A                  CP   "9"+1   ; Compare with ASCII "9"
0347   38 0F                  JR   c,valid   ; If less or equal, jump to valid
0349   FE 61                  CP   "a"   ; is char lowercase letter?
034B   38 02                  JR   c,hex2   
034D   D6 20                  SUB   $20   ; yes, convert a to uppercase
034F                HEX2:        
034F   FE 41                  CP   "A"   ; Compare with ASCII "A"
0351   D8                     RET   c   ; If less, exit invalid
0352   FE 47                  CP   "F"+1   ; Compare with ASCII "F"
0354   38 00                  JR   c,upper   ; If less or equal, jump to upper
0356                UPPER:       
0356   D6 37                  SUB   $37   ; Convert from ASCII to hex
0358                VALID:       
0358   D6 30                  SUB   "0"   ; Convert from ASCII to numeric value
035A   D8                     RET   c   ; If the result is negative, the character was not a valid hexadecimal digit, so return
035B   FE 10                  CP   $10   ; Compare the result with $10
035D   D0                     RET   nc   ; If the result is $10 or more, the character was not a valid hexadecimal digit, so return
035E   29                     ADD   hl,hl   ; Multiply the number in HL by 16 by shifting it left 4 times
035F   29                     ADD   hl,hl   ; This is done because each hexadecimal digit represents 16^n where n is the position of the digit from the right
0360   29                     ADD   hl,hl   
0361   29                     ADD   hl,hl   
0362   85                     ADD   a,l   ; Add the new digit to the number in HL
0363   6F                     LD   l,a   ; Store the result back in L
0364   C3 3F 03               JP   hex1   ; Jump back to hex1 to process the next character
0367                             ; decimal
0367                             ; parses a decimal number
0367                             ; Input: none
0367                             ; Output:
0367                             ; hl: parsed number.
0367                             ; Destroyed registers:
0367                             ; A: Used for temporary storage and calculations.
0367                             ; DE: Used for temporary storage and calculations.
0367                DECIMAL:      
0367   21 00 00               LD   hl,0   ; Initialize HL to 0 to hold the result
036A                DECIMAL1:      
036A   CD AF 03               CALL   nextChar   
036D   D6 30                  SUB   "0"   ; Subtract ASCII "0" to convert from ASCII to binary
036F   D8                     RET   c   ; If the result is negative, the character was not a digit; return
0370   FE 0A                  CP   10   ; Compare the result with 10
0372   D0                     RET   nc   ; If the result is 10 or more, the character was not a digit; return
0373   03                     INC   bc   ; Increment BC to point to the next digit
0374   54 5D                  LD   de,hl   ; Copy HL to DE
0376   29                     ADD   hl,hl   ; Multiply HL by 2
0377   29                     ADD   hl,hl   ; Multiply HL by 4
0378   19                     ADD   hl,de   ; Add DE to HL to multiply HL by 5
0379   29                     ADD   hl,hl   ; Multiply HL by 10
037A   85                     ADD   a,l   ; Add the digit in A to the low byte of HL
037B   6F                     LD   l,a   ; Store the result in the low byte of HL
037C   3E 00                  LD   a,0   ; Clear A
037E   8C                     ADC   a,h   ; Add the carry from the previous addition to the high byte of HL
037F   67                     LD   h,a   ; Store the result in the high byte of HL
0380   18 E8                  JR   decimal1   ; Jump back to the start of the loop
0382                             ; searchStr
0382                             ; search through a list of Pascal strings for a match.
0382                             ; Inputs:
0382                             ;   hl: Points to the string to search for.
0382                             ;   de: Points to the start of the list of strings.
0382                             ; Outputs:
0382                             ;   cf: true if match
0382                             ;   a: index of the matching string if a match is found,
0382                             ;      or -1 if no match is found.
0382                             ;   hl: Points to the string to search for.
0382                             ; Destroyed:
0382                             ;   a, b, c, d, e, a", f"
0382   EB                     EX   de,hl   ; de = search string hl = string list
0383   AF                     XOR   a   ; Initialize the index counter, zf = true, cf = false
0384   08                     EX   af,af'   
0385                SEARCHSTR:      
0385   1A                     LD   a,(de)   ; Load the length of search string
0386   47                     LD   b,a   ; Copy the length to b for looping
0387   D5                     PUSH   de   ; Store search string
0388   E5                     PUSH   hl   ; Store current string
0389   BE                     CP   (hl)   ; Compare with the length of the current string
038A   20 0F                  JR   nz,searchStr2   ; If the lengths are not equal, move to the next string
038C   13                     INC   de   ; Move to the start of the search string
038D   23                     INC   hl   ; Move to the start of the current string
038E                SEARCHSTR1:      
038E   1A                     LD   a,(de)   ; Load the next character from search string
038F   BE                     CP   (hl)   ; Compare with the next character in the current string
0390   20 09                  JR   nz,searchStr2   ; If the characters are not equal, move to the next string
0392   13                     INC   de   ; Move to the next character in the search string
0393   23                     INC   hl   ; Move to the next character in the current string
0394   10 F8                  DJNZ   searchStr1   ; Loop until we've compared all characters
0396   E1                     POP   hl   ; discard current string
0397   E1                     POP   hl   ; hl = search string
0398   08                     EX   af,af'   ; Load the index of the match
0399   3F                     CCF      ; if match, cf = true
039A   C9                     RET      
039B                SEARCHSTR2:      
039B   E1                     POP   hl   ; Restore current string
039C   D1                     POP   de   ; Restore search string
039D   7E                     LD   a,(hl)   ; Load the length of the current string
039E   3C                     INC   a   ; a = length byte plus length of string
039F   4F                     LD   c,a   ; bc = a
03A0   06 00                  LD   b,0   
03A2   09                     ADD   hl,bc   ; hl += bc, the next string
03A3   D5                     PUSH   de   ; Store search string
03A4   E5                     PUSH   hl   ; Store current string
03A5   08                     EX   af,af'   ; Increment the index counter, zf = false, cf = false
03A6   3C                     INC   a   
03A7   08                     EX   af,af'   
03A8   7E                     LD   a,(hl)   ; a = length of next string
03A9   B7                     OR   a   ; If a != 0, continue searching
03AA   20 D9                  JR   nz,searchStr   
03AC   3D                     DEC   a   ; a = NO_MATCH (i.e. -1), zf = false
03AD   3F                     CCF      ; cf = false
03AE   C9                     RET      
03AF                             ; nextChar
03AF                             ; checks if there is a character that has been pushed back for re-reading.
03AF                             ; If there is, it retrieves that character, otherwise it fetches a new character
03AF                             ; from the input.
03AF                             ; Input: none
03AF                             ; Output:
03AF                             ; a: Contains the next character to be processed, either retrieved from the
03AF                             ; pushback buffer or fetched from the input.
03AF                             ; Destroyed: None.
03AF                NEXTCHAR:      
03AF   CB 77                  BIT   7,(vPushBack)   ; Check the high bit of the pushback buffer
03B1   CA 81 00               JP   z,getchar   ; If the high bit is 0, jump to getchar
03B4   3A 1A 08               LD   a,(vPushBack)   ; If the high bit is 1, load the pushed back character into A
03B7   E6 7F                  AND   0x7F   ; Clear the high bit
03B9   32 1A 08               LD   (vPushBack),a   ; Store the character back in the buffer
03BC   C9                     RET      ; Return with the pushed back character in A
03BD                             ; pushBackChar
03BD                             ; push back a character for re-reading. It sets the high bit of the
03BD                             ; character as a flag to indicate that this character has been pushed back, and
03BD                             ; stores the character in the pushback buffer.
03BD                             ; Input:
03BD                             ; a: Contains the character to be pushed back.
03BD                             ; Output: None.
03BD                             ; Destroyed: none, no flags
03BD                PUSHBACKCHAR:      
03BD   CB FF                  SET   7,a   ; Set the high bit of the character with affecting flags
03BF   32 1A 08               LD   (vPushBack),a   ; Store the character in the pushback buffer
03C2   C9                     RET      
03C3                PROMPT:      
03C3   CD D8 03               CALL   print   
03C6   04 0D 0A 3E 20         .PSTR   "\r\n> "   
03CB   C9                     RET      
03CC                CRLF:        
03CC   CD D8 03               CALL   print   
03CF   02 0D 0A               .PSTR   "\r\n"   
03D2   C9                     RET      
03D3                ERROR:       
03D3   E1                     POP   hl   
03D4   CD DD 03               CALL   printStr   
03D7   76                     HALT      
03D8                PRINT:       
03D8   E1                     POP   hl   ; "return" address is address of string			
03D9   CD DD 03               CALL   printStr   
03DC   E9                     JP   (hl)   ; put it back	
03DD                             ; print
03DD                             ; 
03DD                             ; Prints a Pascal string to the console.
03DD                             ; 
03DD                             ; Input:
03DD                             ;   hl: Points to the start of the Pascal string in memory. The first byte at this location should be the length of the string, followed by the string data.
03DD                             ; 
03DD                             ; Output:
03DD                             ;   hl: points to the byte after the end of the string .
03DD                             ; 
03DD                             ; Destroyed:
03DD                             ;   a, b
03DD                PRINTSTR:      
03DD   7E                     LD   a,(hl)   ; Load the length of the string
03DE   B7                     OR   a   ; Check if A is zero
03DF   C8                     RET   z   ; If it is, return immediately
03E0   23                     INC   hl   ; Move to the start of the string data
03E1   47                     LD   b,a   ; Copy the length to B for looping
03E2                PRINTSTR1:      
03E2   7E                     LD   a,(hl)   ; Load the next character
03E3   CD 85 00               CALL   putchar   ; Call a routine that prints a single character
03E6   23                     INC   hl   ; Move to the next character
03E7   10 F9                  DJNZ   printStr1   ; Decrement B and jump if not zero
03E9   C9                     RET      ; Return from the routine
03EA                             ; *******************************************************************************
03EA                             ; *********  END OF MAIN   ******************************************************
03EA                             ; *******************************************************************************
03EA                OPCODES:      
03EA   03 41 44 43            .PSTR   "ADC"   
03EE   03 41 44 44            .PSTR   "ADD"   
03F2   03 41 4E 44            .PSTR   "AND"   
03F6   03 42 49 54            .PSTR   "BIT"   
03FA   04 43 41 4C 4C         .PSTR   "CALL"   
03FF   03 43 43 46            .PSTR   "CCF"   
0403   02 43 50               .PSTR   "CP"   
0406   03 43 50 44            .PSTR   "CPD"   
040A   04 43 50 44 52         .PSTR   "CPDR"   
040F   03 43 50 49            .PSTR   "CPI"   
0413   04 43 50 49 52         .PSTR   "CPIR"   
0418   03 43 50 4C            .PSTR   "CPL"   
041C   03 44 41 41            .PSTR   "DAA"   
0420   03 44 45 43            .PSTR   "DEC"   
0424   02 44 49               .PSTR   "DI"   
0427   04 44 4A 4E 5A         .PSTR   "DJNZ"   
042C   02 45 49               .PSTR   "EI"   
042F   02 45 58               .PSTR   "EX"   
0432   03 45 58 58            .PSTR   "EXX"   
0436   04 48 41 4C 54         .PSTR   "HALT"   
043B   02 49 4D               .PSTR   "IM"   
043E   02 49 4E               .PSTR   "IN"   
0441   03 49 4E 43            .PSTR   "INC"   
0445   03 49 4E 44            .PSTR   "IND"   
0449   04 49 4E 44 52         .PSTR   "INDR"   
044E   03 49 4E 49            .PSTR   "INI"   
0452   04 49 4E 49 52         .PSTR   "INIR"   
0457   02 4A 50               .PSTR   "JP"   
045A   02 4A 52               .PSTR   "JR"   
045D   02 4C 44               .PSTR   "LD"   
0460   03 4C 44 44            .PSTR   "LDD"   
0464   04 4C 44 44 52         .PSTR   "LDDR"   
0469   03 4C 44 49            .PSTR   "LDI"   
046D   04 4C 44 49 52         .PSTR   "LDIR"   
0472   03 4E 45 47            .PSTR   "NEG"   
0476   03 4E 4F 50            .PSTR   "NOP"   
047A   02 4F 52               .PSTR   "OR"   
047D   04 4F 54 44 52         .PSTR   "OTDR"   
0482   04 4F 54 49 52         .PSTR   "OTIR"   
0487   03 4F 55 54            .PSTR   "OUT"   
048B   04 4F 55 54 44         .PSTR   "OUTD"   
0490   04 4F 55 54 49         .PSTR   "OUTI"   
0495   03 50 4F 50            .PSTR   "POP"   
0499   04 50 55 53 48         .PSTR   "PUSH"   
049E   03 52 45 53            .PSTR   "RES"   
04A2   03 52 45 54            .PSTR   "RET"   
04A6   04 52 45 54 49         .PSTR   "RETI"   
04AB   04 52 45 54 4E         .PSTR   "RETN"   
04B0   02 52 4C               .PSTR   "RL"   
04B3   03 52 4C 41            .PSTR   "RLA"   
04B7   03 52 4C 43            .PSTR   "RLC"   
04BB   04 52 4C 43 41         .PSTR   "RLCA"   
04C0   03 52 4C 44            .PSTR   "RLD"   
04C4   02 52 52               .PSTR   "RR"   
04C7   03 52 52 41            .PSTR   "RRA"   
04CB   03 52 52 43            .PSTR   "RRC"   
04CF   04 52 52 43 41         .PSTR   "RRCA"   
04D4   03 52 52 44            .PSTR   "RRD"   
04D8   03 52 53 54            .PSTR   "RST"   
04DC   03 53 42 43            .PSTR   "SBC"   
04E0   03 53 43 46            .PSTR   "SCF"   
04E4   03 53 45 54            .PSTR   "SET"   
04E8   03 53 4C 41            .PSTR   "SLA"   
04EC   03 53 52 41            .PSTR   "SRA"   
04F0   03 53 52 4C            .PSTR   "SRL"   
04F4   03 53 55 42            .PSTR   "SUB"   
04F8   03 58 4F 52            .PSTR   "XOR"   
04FC   00                     .PSTR   ""   ; terminate list with a string of zero length
04FD                REGISTERS:      
04FD   01 42                  .PSTR   "B"   
04FF   01 43                  .PSTR   "C"   
0501   01 44                  .PSTR   "D"   
0503   01 45                  .PSTR   "E"   
0505   01 48                  .PSTR   "H"   
0507   01 4C                  .PSTR   "L"   
0509   01 20                  .PSTR   " "   ; don't match, stand-in for (HL)
050B   01 41                  .PSTR   "A"   
050D   01 49                  .PSTR   "I"   
050F   01 52                  .PSTR   "R"   
0511   00                     .PSTR   ""   ; terminate list with a string of zero length
0512                REG_PAIRS:      
0512   02 42 43               .PSTR   "BC"   
0515   02 44 45               .PSTR   "DE"   
0518   02 48 4C               .PSTR   "HL"   
051B   02 53 50               .PSTR   "SP"   
051E   02 41 46               .PSTR   "AF"   ; NOTE: AF has the same code as SP in some instructions
0521   02 49 58               .PSTR   "IX"   
0524   02 49 59               .PSTR   "IY"   
0527   03 41 46 27            .PSTR   "AF'"   
052B   00                     .PSTR   ""   ; terminate list with a string of zero length
052C                FLAGS:       
052C   02 4E 5A               .PSTR   "NZ"   
052F   01 5A                  .PSTR   "Z"   
0531   02 4E 43               .PSTR   "NC"   
0534   01 43                  .PSTR   "C"   
0536   02 50 4F               .PSTR   "PO"   
0539   02 50 45               .PSTR   "PE"   
053C   01 50                  .PSTR   "P"   
053E   01 4D                  .PSTR   "M"   
0540   00                     .PSTR   ""   ; terminate list with a string of zero length
0541                DIRECTIVES:      
0541   06 2E 41 4C 49 47 4E   .PSTR   ".ALIGN"   
0548   03 2E 44 42            .PSTR   ".DB"   
054C   04 2E 4F 52 47         .PSTR   ".ORG"   
0551   04 2E 53 45 54         .PSTR   ".SET"   
0556   00                     .PSTR   ""   ; terminate list with a string of zero length
0557                             ; *******************************************************************************
0557                             ; *********  END OF DATA   ******************************************************
0557                             ; *******************************************************************************
0800                          .ORG   RAMSTART   
0800                RST08:    DS   2   
0802                RST10:    DS   2   
0804                RST18:    DS   2   
0806                RST20:    DS   2   
0808                RST28:    DS   2   
080A                RST30:    DS   2   ; 
080C                BAUD:     DS   2   ; 
080E                INTVEC:   DS   2   ; 
0810                NMIVEC:   DS   2   ; 
0812                GETCVEC:   DS   2   ; 
0814                PUTCVEC:   DS   2   ; 
0816                VTEMP1:   DS   2   ; temp var 1
0818                VTEMP2:   DS   2   ; temp var 2
081A                VPUSHBACK:   DS   1   ; buffer for pushed back character on input
081B                VTOKEN:   DS   1   ; byte containing enum of token type
081C                VTOKENVAL:   DS   2   ; pointer to start of token value
081E                VCHARPTR:   DS   2   ; pointer to char position into input buffer
0820                VASMPTR:   DS   2   ; pointer to assembly point
0822                VSTRPTR:   DS   2   ; pointer to string stack
0824                VSYMPTR:   DS   2   ; pointer to symbol stack
0826                VEXPRPTR:   DS   2   ; pointer to expression stack
0828                CHARS:    DS   $100   ; page aligned, 256 bytes , a long line!
0928                          DS   $100   
0A28                STACK:       ; grows down
0A28                STRINGS:   DS   $100   ; string heap - grows up
0B28                SYMBOLS:   DS   $100   ; symbol heap - grows up
0C28                EXPRS:    DS   $100   ; expression heap - grows up
0D28                ASSEMBLY:      


ROMSTART:           0000 DEFINED AT LINE 1 IN constants.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 116 IN IOSerial.asm
                    > USED AT LINE 122 IN IOSerial.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 134 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 146 IN IOSerial.asm
                    > USED AT LINE 152 IN IOSerial.asm
                    > USED AT LINE 158 IN IOSerial.asm
                    > USED AT LINE 200 IN IOSerial.asm
                    > USED AT LINE 17 IN MAIN.asm
RAMSTART:           0800 DEFINED AT LINE 2 IN constants.asm
                    > USED AT LINE 1 IN ram.asm
ROMSIZE:            0800 DEFINED AT LINE 3 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 4 IN constants.asm
NO_MATCH:           00-1 DEFINED AT LINE 6 IN constants.asm
CTRL_H:             0008 DEFINED AT LINE 7 IN constants.asm
TOKENS:             0000 DEFINED AT LINE 9 IN constants.asm
COMMA_:             000, DEFINED AT LINE 11 IN constants.asm
COMMENT_:           000; DEFINED AT LINE 12 IN constants.asm
                    > USED AT LINE 107 IN MAIN.asm
DIRECT_:            000D DEFINED AT LINE 13 IN constants.asm
                    > USED AT LINE 151 IN MAIN.asm
ASMLOC_:            000$ DEFINED AT LINE 14 IN constants.asm
                    > USED AT LINE 164 IN MAIN.asm
END_:               000E DEFINED AT LINE 15 IN constants.asm
                    > USED AT LINE 55 IN MAIN.asm
EOF_:               0000 DEFINED AT LINE 16 IN constants.asm
                    > USED AT LINE 52 IN MAIN.asm
                    > USED AT LINE 93 IN MAIN.asm
FLAG_:              000F DEFINED AT LINE 17 IN constants.asm
                    > USED AT LINE 145 IN MAIN.asm
IDENT_:             000I DEFINED AT LINE 18 IN constants.asm
                    > USED AT LINE 154 IN MAIN.asm
LABEL_:             000L DEFINED AT LINE 19 IN constants.asm
                    > USED AT LINE 119 IN MAIN.asm
NEWLN_:             000
 DEFINED AT LINE 20 IN constants.asm
                    > USED AT LINE 98 IN MAIN.asm
NUM_:               0009 DEFINED AT LINE 21 IN constants.asm
                    > USED AT LINE 178 IN MAIN.asm
OPCODE_:            000C DEFINED AT LINE 22 IN constants.asm
                    > USED AT LINE 127 IN MAIN.asm
PARCLOSE_:          000) DEFINED AT LINE 23 IN constants.asm
PAROPEN_:           000( DEFINED AT LINE 24 IN constants.asm
REG_:               000R DEFINED AT LINE 25 IN constants.asm
                    > USED AT LINE 139 IN MAIN.asm
REGPAIR_:           000P DEFINED AT LINE 26 IN constants.asm
                    > USED AT LINE 133 IN MAIN.asm
UNKNOWN_:           00-1 DEFINED AT LINE 27 IN constants.asm
                    > USED AT LINE 183 IN MAIN.asm
OPCODE_IDX:         0000 DEFINED AT LINE 29 IN constants.asm
ADC_:               0000 DEFINED AT LINE 31 IN constants.asm
ADD_:               0001 DEFINED AT LINE 32 IN constants.asm
AND_:               0002 DEFINED AT LINE 33 IN constants.asm
BIT_:               0003 DEFINED AT LINE 34 IN constants.asm
CALL_:              0004 DEFINED AT LINE 35 IN constants.asm
CCF_:               0005 DEFINED AT LINE 36 IN constants.asm
CP_:                0006 DEFINED AT LINE 37 IN constants.asm
CPD_:               0007 DEFINED AT LINE 38 IN constants.asm
CPDR_:              0008 DEFINED AT LINE 39 IN constants.asm
CPI_:               0009 DEFINED AT LINE 40 IN constants.asm
CPIR_:              000A DEFINED AT LINE 41 IN constants.asm
CPL_:               000B DEFINED AT LINE 42 IN constants.asm
DAA_:               000C DEFINED AT LINE 43 IN constants.asm
DEC_:               000D DEFINED AT LINE 44 IN constants.asm
DI_:                000E DEFINED AT LINE 45 IN constants.asm
DJNZ_:              000F DEFINED AT LINE 46 IN constants.asm
EI_:                0010 DEFINED AT LINE 47 IN constants.asm
EX_:                0011 DEFINED AT LINE 48 IN constants.asm
EXX_:               0012 DEFINED AT LINE 49 IN constants.asm
HALT_:              0013 DEFINED AT LINE 50 IN constants.asm
IM_:                0014 DEFINED AT LINE 51 IN constants.asm
IN_:                0015 DEFINED AT LINE 52 IN constants.asm
INC_:               0016 DEFINED AT LINE 53 IN constants.asm
IND_:               0017 DEFINED AT LINE 54 IN constants.asm
INDR_:              0018 DEFINED AT LINE 55 IN constants.asm
INI_:               0019 DEFINED AT LINE 56 IN constants.asm
INIR_:              001A DEFINED AT LINE 57 IN constants.asm
JP_:                001B DEFINED AT LINE 58 IN constants.asm
JR_:                001C DEFINED AT LINE 59 IN constants.asm
LD_:                001D DEFINED AT LINE 60 IN constants.asm
LDD_:               001E DEFINED AT LINE 61 IN constants.asm
LDDR_:              001F DEFINED AT LINE 62 IN constants.asm
LDI_:               0020 DEFINED AT LINE 63 IN constants.asm
LDIR_:              0021 DEFINED AT LINE 64 IN constants.asm
NEG_:               0022 DEFINED AT LINE 65 IN constants.asm
NOP_:               0023 DEFINED AT LINE 66 IN constants.asm
OR_:                0024 DEFINED AT LINE 67 IN constants.asm
OTDR_:              0025 DEFINED AT LINE 68 IN constants.asm
OTIR_:              0026 DEFINED AT LINE 69 IN constants.asm
OUT_:               0027 DEFINED AT LINE 70 IN constants.asm
OUTD_:              0028 DEFINED AT LINE 71 IN constants.asm
OUTI_:              0029 DEFINED AT LINE 72 IN constants.asm
POP_:               002A DEFINED AT LINE 73 IN constants.asm
PUSH_:              002B DEFINED AT LINE 74 IN constants.asm
RES_:               002C DEFINED AT LINE 75 IN constants.asm
RET_:               002D DEFINED AT LINE 76 IN constants.asm
RETI_:              002E DEFINED AT LINE 77 IN constants.asm
RETN_:              002F DEFINED AT LINE 78 IN constants.asm
RL_:                0030 DEFINED AT LINE 79 IN constants.asm
RLA_:               0031 DEFINED AT LINE 80 IN constants.asm
RLC_:               0032 DEFINED AT LINE 81 IN constants.asm
RLCA_:              0033 DEFINED AT LINE 82 IN constants.asm
RLD_:               0034 DEFINED AT LINE 83 IN constants.asm
RR_:                0035 DEFINED AT LINE 84 IN constants.asm
RRA_:               0036 DEFINED AT LINE 85 IN constants.asm
RRC_:               0037 DEFINED AT LINE 86 IN constants.asm
RRCA_:              0038 DEFINED AT LINE 87 IN constants.asm
RRD_:               0039 DEFINED AT LINE 88 IN constants.asm
RST_:               003A DEFINED AT LINE 89 IN constants.asm
SBC_:               003B DEFINED AT LINE 90 IN constants.asm
SCF_:               003C DEFINED AT LINE 91 IN constants.asm
SET_:               0003 DEFINED AT LINE 139 IN constants.asm
SLA_:               003E DEFINED AT LINE 93 IN constants.asm
SRA_:               003F DEFINED AT LINE 94 IN constants.asm
SRL_:               0040 DEFINED AT LINE 95 IN constants.asm
SUB_:               0041 DEFINED AT LINE 96 IN constants.asm
XOR_:               0042 DEFINED AT LINE 97 IN constants.asm
REG_IDX:            0000 DEFINED AT LINE 99 IN constants.asm
B_:                 0000 DEFINED AT LINE 101 IN constants.asm
C_:                 0003 DEFINED AT LINE 128 IN constants.asm
D_:                 0002 DEFINED AT LINE 103 IN constants.asm
E_:                 0003 DEFINED AT LINE 104 IN constants.asm
H_:                 0004 DEFINED AT LINE 105 IN constants.asm
L_:                 0005 DEFINED AT LINE 106 IN constants.asm
MHL_:               0006 DEFINED AT LINE 107 IN constants.asm
A_:                 0007 DEFINED AT LINE 108 IN constants.asm
I_:                 0008 DEFINED AT LINE 109 IN constants.asm
R_:                 0009 DEFINED AT LINE 110 IN constants.asm
REG_PAIR_IDX:       0000 DEFINED AT LINE 112 IN constants.asm
BC_:                0000 DEFINED AT LINE 114 IN constants.asm
DE_:                0001 DEFINED AT LINE 115 IN constants.asm
HL_:                0002 DEFINED AT LINE 116 IN constants.asm
SP_:                0003 DEFINED AT LINE 117 IN constants.asm
AF_:                0004 DEFINED AT LINE 118 IN constants.asm
IX_:                0005 DEFINED AT LINE 119 IN constants.asm
IY_:                0006 DEFINED AT LINE 120 IN constants.asm
AFP_:               0007 DEFINED AT LINE 121 IN constants.asm
FLAG_IDX:           0000 DEFINED AT LINE 123 IN constants.asm
NZ_:                0000 DEFINED AT LINE 125 IN constants.asm
Z_:                 0001 DEFINED AT LINE 126 IN constants.asm
NC_:                0002 DEFINED AT LINE 127 IN constants.asm
PO_:                0004 DEFINED AT LINE 129 IN constants.asm
PE_:                0005 DEFINED AT LINE 130 IN constants.asm
P_:                 0006 DEFINED AT LINE 131 IN constants.asm
M_:                 0007 DEFINED AT LINE 132 IN constants.asm
DIRECTIVE_IDX:      0000 DEFINED AT LINE 134 IN constants.asm
ALIGN_:             0000 DEFINED AT LINE 136 IN constants.asm
DB_:                0001 DEFINED AT LINE 137 IN constants.asm
ORG_:               0002 DEFINED AT LINE 138 IN constants.asm
TEC_1:              0001 DEFINED AT LINE 143 IN constants.asm
RC2014:             0000 DEFINED AT LINE 144 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 146 IN constants.asm
LOADER:             0000 DEFINED AT LINE 148 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 149 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 33 IN IOSerial.asm
                    > USED AT LINE 476 IN IOSerial.asm
                    > USED AT LINE 498 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 34 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 322 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 36 IN IOSerial.asm
                    > USED AT LINE 326 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 475 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 46 IN IOSerial.asm
                    > USED AT LINE 497 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 50 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 51 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 52 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 53 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 54 IN IOSerial.asm
                    > USED AT LINE 497 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 55 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 56 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 57 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 61 IN IOSerial.asm
                    > USED AT LINE 497 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 62 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 63 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 64 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 68 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 72 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 73 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 74 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 75 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 76 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 77 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 78 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 79 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 87 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 88 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 89 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 90 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 91 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 92 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 93 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 94 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 107 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 108 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 109 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 113 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 163 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 481 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 187 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 193 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 196 IN IOSerial.asm
                    > USED AT LINE 457 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 469 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 305 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 308 IN IOSerial.asm
                    > USED AT LINE 312 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 320 IN IOSerial.asm
                    > USED AT LINE 467 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 321 IN IOSerial.asm
                    > USED AT LINE 325 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 445 IN IOSerial.asm
                    > USED AT LINE 536 IN MAIN.asm
PUTCHAR:            0085 DEFINED AT LINE 449 IN IOSerial.asm
                    > USED AT LINE 601 IN MAIN.asm
RESET:              008B DEFINED AT LINE 455 IN IOSerial.asm
                    > USED AT LINE 114 IN IOSerial.asm
START:              0180 DEFINED AT LINE 20 IN MAIN.asm
                    > USED AT LINE 6
INIT:               0198 DEFINED AT LINE 27 IN MAIN.asm
                    > USED AT LINE 22 IN MAIN.asm
PARSE:              01C1 DEFINED AT LINE 44 IN MAIN.asm
                    > USED AT LINE 25 IN MAIN.asm
STATEMENTLIST:      01E8 DEFINED AT LINE 50 IN MAIN.asm
                    > USED AT LINE 45 IN MAIN.asm
                    > USED AT LINE 57 IN MAIN.asm
STATEMENT:          020C DEFINED AT LINE 61 IN MAIN.asm
                    > USED AT LINE 54 IN MAIN.asm
MATCH:              020D DEFINED AT LINE 64 IN MAIN.asm
                    > USED AT LINE 56 IN MAIN.asm
NEXTTOKEN:          0216 DEFINED AT LINE 85 IN MAIN.asm
                    > USED AT LINE 67 IN MAIN.asm
NEXTTOKEN1:         0219 DEFINED AT LINE 87 IN MAIN.asm
                    > USED AT LINE 90 IN MAIN.asm
NEXTTOKEN2:         0227 DEFINED AT LINE 95 IN MAIN.asm
                    > USED AT LINE 92 IN MAIN.asm
NEXTTOKEN2X:        022E DEFINED AT LINE 100 IN MAIN.asm
                    > USED AT LINE 97 IN MAIN.asm
NEXTTOKEN3:         0233 DEFINED AT LINE 103 IN MAIN.asm
                    > USED AT LINE 106 IN MAIN.asm
NEXTTOKEN4:         023D DEFINED AT LINE 109 IN MAIN.asm
                    > USED AT LINE 102 IN MAIN.asm
NEXTTOKEN5:         0246 DEFINED AT LINE 114 IN MAIN.asm
                    > USED AT LINE 111 IN MAIN.asm
NEXTTOKEN6:         0253 DEFINED AT LINE 121 IN MAIN.asm
                    > USED AT LINE 118 IN MAIN.asm
NEXTTOKEN7Z:        0264 DEFINED AT LINE 129 IN MAIN.asm
                    > USED AT LINE 126 IN MAIN.asm
NEXTTOKEN7Y:        026F DEFINED AT LINE 135 IN MAIN.asm
                    > USED AT LINE 132 IN MAIN.asm
NEXTTOKEN7X:        027A DEFINED AT LINE 141 IN MAIN.asm
                    > USED AT LINE 138 IN MAIN.asm
                    > USED AT LINE 144 IN MAIN.asm
NEXTTOKEN7A:        0285 DEFINED AT LINE 147 IN MAIN.asm
NEXTTOKEN7B:        0290 DEFINED AT LINE 153 IN MAIN.asm
                    > USED AT LINE 150 IN MAIN.asm
NEXTTOKEN7:         0293 DEFINED AT LINE 156 IN MAIN.asm
                    > USED AT LINE 113 IN MAIN.asm
NEXTTOKEN8A:        02A8 DEFINED AT LINE 166 IN MAIN.asm
                    > USED AT LINE 163 IN MAIN.asm
NEXTTOKEN8:         02AD DEFINED AT LINE 169 IN MAIN.asm
                    > USED AT LINE 159 IN MAIN.asm
NEXTTOKEN9:         02B6 DEFINED AT LINE 174 IN MAIN.asm
                    > USED AT LINE 171 IN MAIN.asm
NEXTTOKEN9A:        02B9 DEFINED AT LINE 176 IN MAIN.asm
                    > USED AT LINE 168 IN MAIN.asm
NEXTTOKEN10:        02BF DEFINED AT LINE 180 IN MAIN.asm
                    > USED AT LINE 173 IN MAIN.asm
IDENT:              02C5 DEFINED AT LINE 204 IN MAIN.asm
                    > USED AT LINE 115 IN MAIN.asm
IDENT1:             02CB DEFINED AT LINE 208 IN MAIN.asm
                    > USED AT LINE 219 IN MAIN.asm
IDENT2:             02D9 DEFINED AT LINE 216 IN MAIN.asm
                    > USED AT LINE 213 IN MAIN.asm
IDENT3:             02DD DEFINED AT LINE 220 IN MAIN.asm
                    > USED AT LINE 215 IN MAIN.asm
ISSPACE:            02EA DEFINED AT LINE 244 IN MAIN.asm
                    > USED AT LINE 89 IN MAIN.asm
                    > USED AT LINE 161 IN MAIN.asm
ISALPHANUM:         02F0 DEFINED AT LINE 266 IN MAIN.asm
                    > USED AT LINE 112 IN MAIN.asm
                    > USED AT LINE 214 IN MAIN.asm
ISALPHA:            02F4 DEFINED AT LINE 286 IN MAIN.asm
                    > USED AT LINE 312 IN MAIN.asm
ISALPHA1:           02FA DEFINED AT LINE 290 IN MAIN.asm
                    > USED AT LINE 288 IN MAIN.asm
ISHEXDIGIT:         0301 DEFINED AT LINE 311 IN MAIN.asm
ISHEXDIGIT1:        0309 DEFINED AT LINE 316 IN MAIN.asm
ISDIGIT:            0309 DEFINED AT LINE 332 IN MAIN.asm
                    > USED AT LINE 172 IN MAIN.asm
                    > USED AT LINE 267 IN MAIN.asm
                    > USED AT LINE 313 IN MAIN.asm
NUMBER:             0310 DEFINED AT LINE 355 IN MAIN.asm
                    > USED AT LINE 175 IN MAIN.asm
NUMBER1:            0317 DEFINED AT LINE 360 IN MAIN.asm
                    > USED AT LINE 358 IN MAIN.asm
NUMBER2:            0326 DEFINED AT LINE 367 IN MAIN.asm
                    > USED AT LINE 364 IN MAIN.asm
NUMBER3:            032C DEFINED AT LINE 370 IN MAIN.asm
                    > USED AT LINE 366 IN MAIN.asm
HEX:                033C DEFINED AT LINE 392 IN MAIN.asm
                    > USED AT LINE 167 IN MAIN.asm
                    > USED AT LINE 365 IN MAIN.asm
HEX1:               033F DEFINED AT LINE 394 IN MAIN.asm
                    > USED AT LINE 421 IN MAIN.asm
HEX2:               034F DEFINED AT LINE 403 IN MAIN.asm
                    > USED AT LINE 401 IN MAIN.asm
UPPER:              0356 DEFINED AT LINE 408 IN MAIN.asm
                    > USED AT LINE 407 IN MAIN.asm
VALID:              0358 DEFINED AT LINE 410 IN MAIN.asm
                    > USED AT LINE 399 IN MAIN.asm
DECIMAL:            0367 DEFINED AT LINE 437 IN MAIN.asm
                    > USED AT LINE 369 IN MAIN.asm
DECIMAL1:           036A DEFINED AT LINE 439 IN MAIN.asm
                    > USED AT LINE 456 IN MAIN.asm
SEARCHSTR:          0385 DEFINED AT LINE 479 IN MAIN.asm
                    > USED AT LINE 125 IN MAIN.asm
                    > USED AT LINE 131 IN MAIN.asm
                    > USED AT LINE 137 IN MAIN.asm
                    > USED AT LINE 143 IN MAIN.asm
                    > USED AT LINE 149 IN MAIN.asm
                    > USED AT LINE 515 IN MAIN.asm
SEARCHSTR1:         038E DEFINED AT LINE 488 IN MAIN.asm
                    > USED AT LINE 494 IN MAIN.asm
SEARCHSTR2:         039B DEFINED AT LINE 500 IN MAIN.asm
                    > USED AT LINE 485 IN MAIN.asm
                    > USED AT LINE 491 IN MAIN.asm
NEXTCHAR:           03AF DEFINED AT LINE 534 IN MAIN.asm
                    > USED AT LINE 88 IN MAIN.asm
                    > USED AT LINE 104 IN MAIN.asm
                    > USED AT LINE 116 IN MAIN.asm
                    > USED AT LINE 160 IN MAIN.asm
                    > USED AT LINE 211 IN MAIN.asm
                    > USED AT LINE 362 IN MAIN.asm
                    > USED AT LINE 395 IN MAIN.asm
                    > USED AT LINE 440 IN MAIN.asm
PUSHBACKCHAR:       03BD DEFINED AT LINE 555 IN MAIN.asm
                    > USED AT LINE 122 IN MAIN.asm
                    > USED AT LINE 162 IN MAIN.asm
                    > USED AT LINE 177 IN MAIN.asm
                    > USED AT LINE 221 IN MAIN.asm
                    > USED AT LINE 368 IN MAIN.asm
                    > USED AT LINE 378 IN MAIN.asm
PROMPT:             03C3 DEFINED AT LINE 560 IN MAIN.asm
CRLF:               03CC DEFINED AT LINE 565 IN MAIN.asm
ERROR:              03D3 DEFINED AT LINE 570 IN MAIN.asm
                    > USED AT LINE 58 IN MAIN.asm
PRINT:              03D8 DEFINED AT LINE 575 IN MAIN.asm
                    > USED AT LINE 23 IN MAIN.asm
                    > USED AT LINE 46 IN MAIN.asm
                    > USED AT LINE 561 IN MAIN.asm
                    > USED AT LINE 566 IN MAIN.asm
PRINTSTR:           03DD DEFINED AT LINE 593 IN MAIN.asm
                    > USED AT LINE 572 IN MAIN.asm
                    > USED AT LINE 577 IN MAIN.asm
PRINTSTR1:          03E2 DEFINED AT LINE 599 IN MAIN.asm
                    > USED AT LINE 603 IN MAIN.asm
OPCODES:            03EA DEFINED AT LINE 1 IN data.asm
                    > USED AT LINE 124 IN MAIN.asm
REGISTERS:          04FD DEFINED AT LINE 72 IN data.asm
                    > USED AT LINE 136 IN MAIN.asm
REG_PAIRS:          0512 DEFINED AT LINE 86 IN data.asm
                    > USED AT LINE 130 IN MAIN.asm
FLAGS:              052C DEFINED AT LINE 98 IN data.asm
                    > USED AT LINE 142 IN MAIN.asm
                    > USED AT LINE 148 IN MAIN.asm
DIRECTIVES:         0541 DEFINED AT LINE 110 IN data.asm
RST08:              0800 DEFINED AT LINE 3 IN ram.asm
                    > USED AT LINE 118 IN IOSerial.asm
                    > USED AT LINE 458 IN IOSerial.asm
RST10:              0802 DEFINED AT LINE 4 IN ram.asm
                    > USED AT LINE 124 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
RST18:              0804 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 130 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
RST20:              0806 DEFINED AT LINE 6 IN ram.asm
                    > USED AT LINE 136 IN IOSerial.asm
                    > USED AT LINE 461 IN IOSerial.asm
RST28:              0808 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RST30:              080A DEFINED AT LINE 8 IN ram.asm
                    > USED AT LINE 148 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
BAUD:               080C DEFINED AT LINE 9 IN ram.asm
INTVEC:             080E DEFINED AT LINE 10 IN ram.asm
                    > USED AT LINE 154 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
NMIVEC:             0810 DEFINED AT LINE 11 IN ram.asm
                    > USED AT LINE 202 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
GETCVEC:            0812 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 446 IN IOSerial.asm
                    > USED AT LINE 468 IN IOSerial.asm
PUTCVEC:            0814 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
VTEMP1:             0816 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 361 IN MAIN.asm
                    > USED AT LINE 371 IN MAIN.asm
VTEMP2:             0818 DEFINED AT LINE 16 IN ram.asm
VPUSHBACK:          081A DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 29 IN MAIN.asm
                    > USED AT LINE 535 IN MAIN.asm
                    > USED AT LINE 537 IN MAIN.asm
                    > USED AT LINE 539 IN MAIN.asm
                    > USED AT LINE 557 IN MAIN.asm
VTOKEN:             081B DEFINED AT LINE 19 IN ram.asm
                    > USED AT LINE 30 IN MAIN.asm
                    > USED AT LINE 51 IN MAIN.asm
VTOKENVAL:          081C DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 37 IN MAIN.asm
VCHARPTR:           081E DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 32 IN MAIN.asm
VASMPTR:            0820 DEFINED AT LINE 22 IN ram.asm
                    > USED AT LINE 34 IN MAIN.asm
VSTRPTR:            0822 DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 36 IN MAIN.asm
                    > USED AT LINE 123 IN MAIN.asm
                    > USED AT LINE 205 IN MAIN.asm
                    > USED AT LINE 222 IN MAIN.asm
VSYMPTR:            0824 DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 39 IN MAIN.asm
VEXPRPTR:           0826 DEFINED AT LINE 25 IN ram.asm
                    > USED AT LINE 41 IN MAIN.asm
CHARS:              0828 DEFINED AT LINE 27 IN ram.asm
                    > USED AT LINE 31 IN MAIN.asm
STACK:              0A28 DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 456 IN IOSerial.asm
                    > USED AT LINE 21 IN MAIN.asm
STRINGS:            0A28 DEFINED AT LINE 31 IN ram.asm
                    > USED AT LINE 35 IN MAIN.asm
SYMBOLS:            0B28 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 38 IN MAIN.asm
EXPRS:              0C28 DEFINED AT LINE 33 IN ram.asm
                    > USED AT LINE 40 IN MAIN.asm
ASSEMBLY:           0D28 DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 33 IN MAIN.asm
