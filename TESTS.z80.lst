0000                          .ENGINE   mycomputer   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $3000   
0000                ROMSIZE:   EQU   $3000   
0000                RAMSIZE:   EQU   $0800   
0000                EOF:      EQU   -1   
0000                NULL:     EQU   0   
0000                CTRL_C:   EQU   3   
0000                CTRL_H:   EQU   8   
0000                ESC:      EQU   27   
0000                NO_MATCH:   EQU   -1   
0000                BUFFER_SIZE:   EQU   $80   
0000                HEAP_SIZE:   EQU   $100   
0000                TOKENS:      
0000                COLON_:   EQU   ":"   
0000                COMMA_:   EQU   ","   
0000                DOLLAR_:   EQU   "$"   
0000                LPAREN_:   EQU   "("   
0000                MINUS_:   EQU   "-"   
0000                NEWLN_:   EQU   "\n"   
0000                PLUS_:    EQU   "+"   
0000                RPAREN_:   EQU   ")"   
0000                EOF_:     EQU   0   
0000                DIRECT_:   EQU   1   
0000                IDENT_:   EQU   2   
0000                LABEL_:   EQU   3   
0000                NUM_:     EQU   4   
0000                OPCODE_:   EQU   5   
0000                OPELEM_:   EQU   6   ; op element: reg, rp, flag
0000                UNKNOWN_:   EQU   100   
0000                ALU_:     EQU   0x00   
0000                ROT_:     EQU   0x20   
0000                BLI_:     EQU   0x40   
0000                GEN1_:    EQU   0x60   
0000                GEN2_:    EQU   0x80   
0000                ALU_IDX:      
0000                ADD_:     EQU   0 | alu_   
0000                ADC_:     EQU   1 | alu_   
0000                SUB_:     EQU   2 | alu_   
0000                SBC_:     EQU   3 | alu_   
0000                AND_:     EQU   4 | alu_   
0000                XOR_:     EQU   5 | alu_   
0000                OR_:      EQU   6 | alu_   
0000                CP_:      EQU   7 | alu_   
0000                ROT_IDX:      
0000                RLC_:     EQU   0 | rot_   
0000                RRC_:     EQU   1 | rot_   
0000                RL_:      EQU   2 | rot_   
0000                RR_:      EQU   3 | rot_   
0000                SLA_:     EQU   4 | rot_   
0000                SRA_:     EQU   5 | rot_   
0000                SLL_:     EQU   6 | rot_   
0000                SRL_:     EQU   7 | rot_   
0000                BLI_IDX:      
0000                LDI_:     EQU   00 | bli_   
0000                CPI_:     EQU   01 | bli_   
0000                INI_:     EQU   02 | bli_   
0000                OUTI_:    EQU   03 | bli_   
0000                LDD_:     EQU   04 | bli_   
0000                CPD_:     EQU   05 | bli_   
0000                IND_:     EQU   06 | bli_   
0000                OUTD_:    EQU   07 | bli_   
0000                LDIR_:    EQU   08 | bli_   
0000                CPIR_:    EQU   09 | bli_   
0000                INIR_:    EQU   10 | bli_   
0000                OTIR_:    EQU   11 | bli_   
0000                LDDR_:    EQU   12 | bli_   
0000                CPDR_:    EQU   13 | bli_   
0000                INDR_:    EQU   14 | bli_   
0000                OTDR_:    EQU   15 | bli_   
0000                GEN1_IDX:      
0000                CCF_:     EQU   00 | gen1_   
0000                CPL_:     EQU   01 | gen1_   
0000                DAA_:     EQU   02 | gen1_   
0000                DI_:      EQU   03 | gen1_   
0000                EI_:      EQU   04 | gen1_   
0000                HALT_:    EQU   05 | gen1_   
0000                NOP_:     EQU   06 | gen1_   
0000                RLCA_:    EQU   07 | gen1_   
0000                RST_:     EQU   08 | gen2_   
0000                SCF_:     EQU   09 | gen1_   
0000                GEN2_IDX:      
0000                BIT_:     EQU   00 | gen2_   
0000                CALL_:    EQU   01 | gen2_   
0000                DEC_:     EQU   02 | gen2_   
0000                DJNZ_:    EQU   03 | gen2_   
0000                EX_:      EQU   04 | gen2_   
0000                EXX_:     EQU   05 | gen2_   
0000                IM_:      EQU   06 | gen2_   
0000                IN_:      EQU   07 | gen2_   
0000                INC_:     EQU   08 | gen2_   
0000                JP_:      EQU   09 | gen2_   
0000                JR_:      EQU   10 | gen2_   
0000                LD_:      EQU   11 | gen2_   
0000                NEG_:     EQU   12 | gen2_   
0000                OUT_:     EQU   13 | gen2_   
0000                POP_:     EQU   14 | gen2_   
0000                PUSH_:    EQU   15 | gen2_   
0000                RES_:     EQU   16 | gen2_   
0000                RET_:     EQU   17 | gen2_   
0000                RETI_:    EQU   18 | gen2_   
0000                RETN_:    EQU   19 | gen2_   
0000                RLA_:     EQU   20 | gen2_   
0000                RLD_:     EQU   21 | gen2_   
0000                RRA_:     EQU   22 | gen2_   
0000                RRCA_:    EQU   23 | gen2_   
0000                RRD_:     EQU   24 | gen2_   
0000                SET_:     EQU   25 | gen2_   
0000                REG_:     EQU   0x00   ; operand types
0000                RP_:      EQU   0x01   
0000                FLAG_:    EQU   0x02   
0000                IMMED_:   EQU   0x03   
0000                MEM_:     EQU   0x04   ; modifiers
0000                INDEX_:   EQU   0x08   
0000                REG8_IDX:      ; 8-bit registers
0000                B_:       EQU   0   ; B
0000                C_:       EQU   1   ; C
0000                D_:       EQU   2   ; D
0000                E_:       EQU   3   ; E
0000                H_:       EQU   4   ; H
0000                L_:       EQU   5   ; L
0000                MHL_:     EQU   6   ; (HL)
0000                A_:       EQU   7   ; A
0000                I_:       EQU   8   ; I
0000                R_:       EQU   9   ; R
0000                REG16_IDX:      ; 16-bit registers
0000                BC_:      EQU   0   
0000                DE_:      EQU   1   
0000                HL_:      EQU   2   
0000                SP_:      EQU   3   
0000                IX_:      EQU   4   
0000                IY_:      EQU   5   
0000                AFP_:     EQU   6   ; AF' (prime)
0000                AF_:      EQU   7   ; NOTE: AF has the same code as SP in some instructions
0000                FLAG_IDX:      
0000                NZ_:      EQU   0   
0000                Z_:       EQU   1   
0000                NC_:      EQU   2   
0000                C_:       EQU   3   
0000                PO_:      EQU   4   
0000                PE_:      EQU   5   
0000                P_:       EQU   6   
0000                M_:       EQU   7   
0000                DIRECTIVE_IDX:      
0000                ALIGN_:   EQU   0   
0000                DB_:      EQU   1   
0000                ORG_:     EQU   2   
0000                SET_:     EQU   3   
0000                             ; -----------------------------------------------------------------------------------------------
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                             ; *************************************************************************
0000                             ; 
0000                             ;       Serial routines 
0000                             ; 
0000                             ;       written by Craig Jones 
0000                             ; 
0000                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
0000                             ; 
0000                             ;       see the LICENSE file in this repo for more information 
0000                             ; 
0000                             ; *****************************************************************************
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8D 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 9A 31               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 9C 31               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 9E 31               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A A0 31               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A A2 31               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A A4 31               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A A8 31               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A AA 31               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   E5                     PUSH   HL   
0082   2A AC 31               LD   HL,(GETCVEC)   
0085   E3                     EX   (SP),HL   
0086   C9                     RET      
0087                             ; 
0087                PUTCHAR:      
0087   E5                     PUSH   HL   
0088   2A AE 31               LD   HL,(PUTCVEC)   
008B   E3                     EX   (SP),HL   
008C   C9                     RET      
008D                             ; 
008D                RESET:       
008D   31 80 31               LD   SP,stack   
0090   21 5F 00               LD   HL,IntRet   
0093   22 9A 31               LD   (RST08),HL   
0096   22 9C 31               LD   (RST10),HL   
0099   22 9E 31               LD   (RST18),HL   
009C   22 A0 31               LD   (RST20),HL   
009F   22 A2 31               LD   (RST28),HL   
00A2   22 A4 31               LD   (RST30),HL   
00A5   22 A8 31               LD   (INTVEC),HL   
00A8   22 AA 31               LD   (NMIVEC),HL   
00AB                             ; 
00AB   21 78 00               LD   HL,RXDATA   
00AE   22 AC 31               LD   (GETCVEC),HL   
00B1   21 6B 00               LD   HL,TXDATA   
00B4   22 AE 31               LD   (PUTCVEC),HL   
00B7                             ; 
00B7                          IF   TEC_1   
00B7                          IF   BITBANG = 0   
00B7                             ; 
00B7   3E 03                  LD   a,MRESET   
00B9   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00BB                             ; 
00BB                          ENDIF      
00BB                          ENDIF      
00BB                             ; 
00BB   CD 50 00               CALL   PWRUP   
00BE   ED 56                  IM   1   
00C0   FB                     EI      
00C1                             ; 
00C1                          IF   TEC_1   
00C1                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00C1                          ELSE      ;6850      
00C1                             ; 
00C1   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C3   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C5                             ; 
00C5                          ENDIF      
00C5                          ENDIF      
00C5                             ; 
00C5                             ; 
00C5   C3 00 40               JP   testsStart   
00C8                             ; *************************************************************************
00C8                             ; 
00C8                             ;       TecM8 1.0 Assembler for the Tec-1
00C8                             ; 
00C8                             ;       by John Hardy
00C8                             ; 
00C8                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3,29 June 2007
00C8                             ; 
00C8                             ;       see the LICENSE file in this repo for more information
00C8                             ; 
00C8                             ; *****************************************************************************
00C8                             ; **************************************************************************
00C8                             ; Page 0  Initialisation
00C8                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put TecM8 code from here	
0180                             ; *****************************************************************************
0180                             ; Routine: start
0180                             ; 
0180                             ; Purpose:
0180                             ;    Entry point of TecM8. Initializes the STACK pointer,calls the initialization
0180                             ;    routine,prints TecM8 version information,and jumps to the parsing routine.
0180                             ; 
0180                             ; Inputs:
0180                             ;    None
0180                             ; 
0180                             ; Outputs:
0180                             ;    None
0180                             ; 
0180                             ; Registers Destroyed:
0180                             ;    A,HL
0180                             ; *****************************************************************************
0180                START:       
0180   31 80 31               LD   sp,STACK   ; Initialize STACK pointer
0183   CD 98 01               CALL   init   ; Call initialization routine
0186   CD B5 05               CALL   print   ; Print TecM8 version information
0189   54 65 63 4D 38 20 30 2E 30 0D 0A 00 .CSTR   "TecM8 0.0\r\n"   
0195   C3 BD 01               JP   parse   ; Jump to the parsing routine
0198                             ; *****************************************************************************
0198                             ; Routine: init
0198                             ; 
0198                             ; Purpose:
0198                             ;    Initializes various pointers and variables used by TecM8.
0198                             ; 
0198                             ; Inputs:
0198                             ;    None
0198                             ; 
0198                             ; Outputs:
0198                             ;    None
0198                             ; 
0198                             ; Registers Destroyed:
0198                             ;    A,HL
0198                             ; *****************************************************************************
0198                INIT:        
0198   21 00 00               LD   hl,0   
019B   22 85 31               LD   (vTokenVal),hl   ; vTokenVal = 0
019E   22 8B 31               LD   (vSymPtr),hl   ; vSymPtr = 0
01A1   22 8D 31               LD   (vExprPtr),hl   ; vExprPtr = 0
01A4   AF                     XOR   a   
01A5   32 84 31               LD   (vToken),a   ; vToken = 0
01A8   32 87 31               LD   (vBufferPos),a   ; vBufferPos = 0
01AB   3E 0A                  LD   a,"\n"   ; put new line into first char of buffer
01AD   32 00 30               LD   (BUFFER),a   
01B0   21 B0 31               LD   hl,HEAP   ; vHeapPtr = HEAP
01B3   22 8F 31               LD   (vHeapPtr),hl   
01B6   21 B0 32               LD   hl,ASSEMBLY   ; vAsmPtr = ASSEMBLY
01B9   22 89 31               LD   (vAsmPtr),hl   
01BC   C9                     RET      
01BD                             ; *****************************************************************************
01BD                             ; Routine: parse
01BD                             ; 
01BD                             ; Purpose:
01BD                             ;    Parses the input program,calling the statementList routine,printing the
01BD                             ;    completion message,and halting the system.
01BD                             ; 
01BD                             ; Inputs:
01BD                             ;    None
01BD                             ; 
01BD                             ; Outputs:
01BD                             ;    None
01BD                             ; 
01BD                             ; Registers Destroyed:
01BD                             ;    None
01BD                             ; *****************************************************************************
01BD                PARSE:       
01BD   CD F7 01               CALL   statementList   ; Parse the input program
01C0   CD B5 05               CALL   print   ; Print completion message
01C3   50 61 72 73 69 6E 67 20 63 6F 6D 70 6C 65 74 65 64 20 73 75 63 63 65 73 73 66 75 6C 6C 79 2E 00 .CSTR   "Parsing completed successfully."   
01E3   76                     HALT      
01E4                PARSEERROR:      
01E4   55 6E 65 78 70 65 63 74 65 64 20 74 6F 6B 65 6E 2E 00 .CSTR   "Unexpected token."   
01F6   76                     HALT      
01F7                             ; *****************************************************************************
01F7                             ; Routine: statementList
01F7                             ; 
01F7                             ; Purpose:
01F7                             ;    Parses a list of statements,repeatedly calling the statement routine until
01F7                             ;    the end of file (EOF) token is encountered.
01F7                             ; 
01F7                             ; Inputs:
01F7                             ;    None
01F7                             ; 
01F7                             ; Outputs:
01F7                             ;    None
01F7                             ; 
01F7                             ; Registers Destroyed:
01F7                             ;    A
01F7                             ; *****************************************************************************
01F7                STATEMENTLIST:      
01F7   CD 5C 03               CALL   nextToken   ; Get the next token
01FA   CD 06 02               CALL   statement   ; Parse a statement
01FD   FE 00                  CP   EOF_   ; Check if it's the end of file
01FF   C8                     RET   z   ; If yes,return
0200   FE 0A                  CP   NEWLN_   
0202   20 E0                  JR   nz,parseError   
0204   18 F1                  JR   statementList   ; Repeat for the next statement
0206                             ; *****************************************************************************
0206                             ; Routine: statement
0206                             ; 
0206                             ; Purpose:
0206                             ;    Parses a single statement,checking its type (label,opcode,or directive)
0206                             ;    and performing corresponding actions.
0206                             ; 
0206                             ; Inputs:
0206                             ;    None
0206                             ; 
0206                             ; Outputs:
0206                             ;    None
0206                             ; 
0206                             ; Registers Destroyed:
0206                             ;    A
0206                             ; *****************************************************************************
0206                STATEMENT:      
0206   CD BF 04               CALL   isEndOfLine   
0209   C8                     RET   z   
020A   F5                     PUSH   af   ; save token type
020B   E5                     PUSH   hl   ; save token val
020C   21 FF FF               LD   hl,-1   ; operand H = value L = type
020F   22 92 31               LD   (vOperand1),hl   
0212   22 94 31               LD   (vOperand2),hl   
0215   AF                     XOR   a   
0216   32 91 31               LD   (vOpcode),a   
0219   32 96 31               LD   (vOpExpr),a   
021C   32 98 31               LD   (vOpDisp),a   
021F   E1                     POP   hl   ; restore token val
0220   F1                     POP   af   ; restore token type
0221   FE 03                  CP   LABEL_   ; Check if it's a label
0223   20 0A                  JR   nz,statement1   ; If not,jump to statement10
0225   ED 5B 89 31            LD   de,(vAsmPtr)   ; HL = symbol name DE = symbol value (assembler pointer)
0229   CD 43 03               CALL   addSymbol   ; Add label to symbol list
022C   CD 5C 03               CALL   nextToken   ; Get the next token
022F                STATEMENT1:      
022F   FE 05                  CP   OPCODE_   ; Check if it's an opcode
0231   28 05                  JR   z,instruction   ; Jump to parseInstruction routine
0233   FE 01                  CP   DIRECT_   ; Check if it's a directive
0235   28 3F                  JR   z,directive   
0237   C9                     RET      
0238                             ; *****************************************************************************
0238                             ; Routine: instruction
0238                             ; 
0238                             ; Purpose:
0238                             ;    Parses an instruction and its operands. Stores the opcode and operands
0238                             ;    in the corresponding variables. Handles both single and double operand
0238                             ;    instructions.
0238                             ; 
0238                             ; Inputs:
0238                             ;    HL - Points to the current token (opcode).
0238                             ; 
0238                             ; Outputs:
0238                             ;    vOpcode - Stores the parsed opcode.
0238                             ;    vOperand1 - Stores the first operand or -1 if there is only one operand.
0238                             ;    vOperand2 - Stores the second operand.
0238                             ; 
0238                             ; Registers Destroyed:
0238                             ;    A, AF
0238                             ; *****************************************************************************
0238                INSTRUCTION:      
0238   7D                     LD   a,l   ; Load the current token (opcode) into A
0239   32 91 31               LD   (vOpcode),a   ; Store the opcode in vOpcode
023C   CD 5C 03               CALL   nextToken   ; Get the next token
023F   CD BF 04               CALL   isEndOfLine   ; Check if the end of the line is reached
0242   C8                     RET   z   ; Return if it is the end of the line
0243   CD 77 02               CALL   operand   ; Parse the first operand
0246   22 92 31               LD   (vOperand1),hl   ; Store the first operand in vOperand1
0249   CD 5C 03               CALL   nextToken   ; Get the next token
024C   FE 2C                  CP   COMMA_   ; Check if the token is a comma
024E   20 18                  JR   nz,instruction1   ; If not, handle as a single operand instruction
0250   CD 5C 03               CALL   nextToken   ; Get the next token
0253   CD BF 04               CALL   isEndOfLine   ; Check if the end of the line is reached
0256   28 8C                  JR   z,parseError   ; Jump to parseError if it is the end of the line
0258   CD 77 02               CALL   operand   ; Parse the second operand
025B   22 94 31               LD   (vOperand2),hl   ; Store the second operand in vOperand2
025E   CD 5C 03               CALL   nextToken   ; Get the next token
0261   CD BF 04               CALL   isEndOfLine   ; Check if the end of the line is reached
0264   C2 E4 01               JP   nz,parseError   ; Jump to parseError if it is the end of the line
0267   C9                     RET      ; Return from the subroutine
0268                INSTRUCTION1:      
0268   F5                     PUSH   af   ; Save the token type (AF)
0269   3A 92 31               LD   a,(vOperand1)   ; Load the first operand into A
026C   32 94 31               LD   (vOperand2),a   ; Move the first operand to vOperand2
026F   3E FF                  LD   a,-1   ; Set vOperand1 to default value -1 (no operand)
0271   32 92 31               LD   (vOperand1),a   ; Store the default value in vOperand1
0274   F1                     POP   af   ; Restore the token type (AF)
0275   C9                     RET      ; Return from the subroutine
0276                DIRECTIVE:      
0276   C9                     RET      
0277                             ; *****************************************************************************
0277                             ; Routine: operand
0277                             ; 
0277                             ; Purpose:
0277                             ;    Parses and identifies different types of operands (registers,memory,
0277                             ;    immediate values,etc.) used in assembly instructions. Sets the appropriate
0277                             ;    flags based on the operand type.
0277                             ; 
0277                             ; Inputs:
0277                             ;    None (uses the current token from a token stream)
0277                             ; 
0277                             ; Outputs:
0277                             ;    H - Contains operand value
0277                             ;    L - Contains operand type.
0277                             ; 
0277                             ; Registers Destroyed:
0277                             ;    A,B,DE,HL
0277                             ; *****************************************************************************
0277                OPERAND:      
0277   FE 06                  CP   OPELEM_   ; Check if the token is an op element i.e. reg,rp or flag
0279   28 30                  JR   z,opElement   
027B   FE 28                  CP   LPAREN_   ; Check if the token is a left parenthesis
027D   28 0B                  JR   z,operand1   ; If so,handle as a memory reference
027F   CD E4 02               CALL   expression   ; Otherwise,treat as an expression
0282   22 96 31               LD   (vOpExpr),hl   ; Store the result of the operand expression
0285   26 00                  LD   h,0   
0287   2E 03                  LD   l,immed_   ; Set A to indicate an immediate value
0289   C9                     RET      
028A                OPERAND1:      
028A   CD 5C 03               CALL   nextToken   ; Memory reference. Get the next token
028D   FE 06                  CP   OPELEM_   ; Check if the next token is an op element
028F   20 05                  JR   nz,operand2   ; If not,handle as an expression inside parentheses
0291   CD B6 02               CALL   regPairIndirect   
0294   18 0A                  JR   operand7   
0296                OPERAND2:      
0296   CD E4 02               CALL   expression   ; Treat as a new expression
0299   22 96 31               LD   (vOpExpr),hl   ; Store the result of the expression
029C   26 00                  LD   h,0   
029E   2E 07                  LD   l,immed_ | mem_   ; Set A to indicate an immediate memory reference
02A0                OPERAND7:      
02A0   E5                     PUSH   HL   ; save HL
02A1   CD 5C 03               CALL   nextToken   ; Get the next token
02A4   FE 29                  CP   RPAREN_   ; Check if the next token is a right parenthesis
02A6   C2 E4 01               JP   nz,parseError   ; If not,handle as a parse error
02A9   E1                     POP   HL   ; restore HL
02AA   C9                     RET      
02AB                             ; *****************************************************************************
02AB                             ; Routine: opElement
02AB                             ; 
02AB                             ; Purpose:
02AB                             ;    Parses the op element (registers, register pairs, flags) sets the
02AB                             ;    appropriate flags based on the type of operand.
02AB                             ; 
02AB                             ; Inputs:
02AB                             ;    HL - Points to the current token value.
02AB                             ; 
02AB                             ; Outputs:
02AB                             ;    H - Contains operand value
02AB                             ;    L - Contains operand type.
02AB                             ; 
02AB                             ; Registers Destroyed:
02AB                             ;    AF, HL
02AB                             ; *****************************************************************************
02AB                OPELEMENT:      
02AB   7C                     LD   a,h   ; A = H = operand value
02AC   FE 04                  CP   IX_   
02AE   28 03                  JR   z,opElement2   
02B0   FE 05                  CP   IY_   
02B2   C0                     RET   nz   
02B3                OPELEMENT2:      
02B3   2E 09                  LD   l,index_ | rp_   
02B5   C9                     RET      
02B6                             ; *****************************************************************************
02B6                             ; Routine: regPairIndirect
02B6                             ; 
02B6                             ; Purpose:
02B6                             ;    Parses the register indirect memory address sets the
02B6                             ;    appropriate flags based on the type of operand.
02B6                             ; 
02B6                             ; Inputs:
02B6                             ;    HL - Points to the current token.
02B6                             ; 
02B6                             ; Outputs:
02B6                             ;    A - Contains operand information.
02B6                             ; 
02B6                             ; Registers Destroyed:
02B6                             ;    AF
02B6                             ; *****************************************************************************
02B6                REGPAIRINDIRECT:      
02B6   7D                     LD   a,l   ; A = operand type
02B7   FE 02                  CP   flag_   ; is type reg_ or rp_ ? no then error
02B9   CA E4 01               JP   z,parseError   
02BC   FE 00                  CP   reg_   
02BE   28 10                  JR   z,regPairIndirect1   
02C0   7C                     LD   a,h   ; A = operand value, type = rp
02C1   FE 02                  CP   HL_   
02C3   28 11                  JR   z,regPairIndirect2   
02C5   FE 04                  CP   IX_   
02C7   28 10                  JR   z,regPairIndirect3   
02C9   FE 05                  CP   IY_   
02CB   28 0C                  JR   z,regPairIndirect3   
02CD   2E 05                  LD   l,mem_ | rp_   ; Otherwise,set A to indicate a memory reference
02CF   C9                     RET      
02D0                REGPAIRINDIRECT1:      
02D0   7C                     LD   a,h   ; A = operand value, type = reg
02D1   FE 03                  CP   C_   
02D3   C2 E4 01               JP   nz,parseError   
02D6                REGPAIRINDIRECT2:      
02D6   2E 04                  LD   l,mem_ | reg_   ; (c) or (hl)
02D8   C9                     RET      
02D9                REGPAIRINDIRECT3:      
02D9   2E 0C                  LD   l,mem_ | reg_ | index_   ; (ix+disp) or (iy+disp)
02DB   E5                     PUSH   hl   ; Save HL on the stack
02DC   CD E4 02               CALL   expression   ; Treat as an expression
02DF   22 98 31               LD   (vOpDisp),hl   ; Store the result of the expression
02E2   E1                     POP   hl   ; Restore HL from the stack
02E3   C9                     RET      
02E4                             ; *****************************************************************************
02E4                             ; Routine: expression
02E4                             ; 
02E4                             ; Purpose:
02E4                             ;    Parses an expression as an array of tokens and stores it in an array.
02E4                             ;    Each token in the expression is appended to an array which is terminated by
02E4                             ;    a NULL token type.
02E4                             ;    The expression list pointer is updated to point to the start of the last token list.
02E4                             ; 
02E4                             ; Inputs:
02E4                             ;    A - token type
02E4                             ;    HL - token value
02E4                             ; 
02E4                             ; Outputs:
02E4                             ;    Updates the heap with the parsed expression and updates the expression list pointer.
02E4                             ; 
02E4                             ; Registers Destroyed:
02E4                             ;    AF,B,HL
02E4                             ; *****************************************************************************
02E4                EXPRESSION:      
02E4   06 00                  LD   b,0   ; Initialize nesting level
02E6   E5                     PUSH   hl   ; Save token value
02E7   ED 5B 8F 31            LD   de,(vHeapPtr)   ; Load the current heap pointer into DE
02EB   2A 8D 31               LD   hl,(vExprPtr)   ; Load the current expression list pointer into HL
02EE   CD D4 05               CALL   hpush   ; Push the pointer to the last symbol onto the heap
02F1   21 00 00               LD   hl,0   ; Append two words in header (for future use)
02F4   CD D4 05               CALL   hpush   
02F7   CD D4 05               CALL   hpush   
02FA   ED 53 8D 31            LD   (vExprPtr),de   ; Update the expression list pointer with the new address
02FE   E1                     POP   hl   ; HL = token value
02FF                EXPRESSION1:      
02FF   EB                     EX   de,hl   ; DE = token value
0300   6F                     LD   l,a   ; HL = token type
0301   26 00                  LD   h,0   
0303   CD D4 05               CALL   hpush   ; Push the token type
0306   EB                     EX   de,hl   ; HL = token value
0307   CD D4 05               CALL   hpush   ; Push the token value
030A   CD 5C 03               CALL   nextToken   ; Get the next token
030D   FE 28                  CP   "("   ; increase nesting?
030F   20 06                  JR   nz,expression2   
0311   04                     INC   b   
0312   CD 5C 03               CALL   nextToken   ; Get the next token
0315   18 E8                  JR   expression1   ; Repeat the main loop
0317                EXPRESSION2:      
0317   04                     INC   b   ; Check if nesting level is zero
0318   05                     DEC   b   
0319   28 0A                  JR   z,expression3   ; If yes,skip to expression3
031B   FE 29                  CP   ")"   ; if nesting > 0,decrease nesting?
031D   20 06                  JR   nz,expression3   
031F   05                     DEC   b   ; Decrease nesting level
0320   CD 5C 03               CALL   nextToken   ; Get the next token
0323   18 DA                  JR   expression1   ; Repeat the main loop
0325                EXPRESSION3:      
0325   FE 29                  CP   RPAREN_   ; Check if the end of the expression
0327   28 0B                  JR   z,expression4   
0329   FE 2C                  CP   COMMA_   
032B   28 07                  JR   z,expression4   
032D   CD BF 04               CALL   isEndOfLine   
0330   28 02                  JR   z,expression4   
0332   18 CB                  JR   expression1   
0334                EXPRESSION4:      
0334   EB                     EX   de,hl   
0335   21 00 00               LD   hl,NULL   ; Mark the end of the expression with NULL
0338   CD D4 05               CALL   hpush   ; Push NULL onto the heap
033B   EB                     EX   de,hl   
033C   CD 1D 04               CALL   pushBackToken   ; Rewind the token to the last valid one
033F   2A 8D 31               LD   hl,(vExprPtr)   
0342   C9                     RET      
0343                             ; *****************************************************************************
0343                             ; Routine: addSymbol
0343                             ; 
0343                             ; Purpose:
0343                             ;    Adds a new symbol to the symbol list. The symbol's name is in HL and the
0343                             ;    symbol's value is in DE. Updates the symbol list pointer and ensures
0343                             ;    the previous symbol's pointer is preserved.
0343                             ; 
0343                             ; Inputs:
0343                             ;    HL - Points to the name of the new symbol.
0343                             ;    DE - Contains the value of the new symbol.
0343                             ; 
0343                             ; Outputs:
0343                             ;    Updates the symbol list pointer in vSymPtr.
0343                             ; 
0343                             ; Registers Destroyed:
0343                             ;    DE,HL
0343                             ; *****************************************************************************
0343                ADDSYMBOL:      
0343   D5                     PUSH   de   
0344   E5                     PUSH   hl   ; Push symbol name onto the stack
0345   ED 5B 8F 31            LD   de,(vHeapPtr)   ; BC = symbol address from the heap pointer
0349   2A 8B 31               LD   hl,(vSymPtr)   ; Load the current symbol list pointer into HL
034C   CD D4 05               CALL   hpush   ; Push pointer to the last symbol onto the heap
034F   ED 53 8B 31            LD   (vSymPtr),de   ; Update the symbol list pointer with the new symbol address
0353   E1                     POP   hl   ; HL = symbol name
0354   CD D4 05               CALL   hpush   ; Push symbol name onto the heap
0357   E1                     POP   hl   ; HL = symbol value
0358   CD D4 05               CALL   hpush   ; Push symbol value onto the heap
035B   C9                     RET      ; Return from subroutine
035C                             ; *****************************************************************************
035C                             ; Routine: nextToken
035C                             ; 
035C                             ; Purpose:
035C                             ;    Parses the next token from the input stream,identifying various types of
035C                             ;    tokens such as identifiers,labels,opcodes,registers,flags,numbers,
035C                             ;    and special characters.
035C                             ; 
035C                             ; Inputs:
035C                             ;    None
035C                             ; 
035C                             ; Outputs:
035C                             ;    A - Token representing the type of the parsed element
035C                             ; 
035C                             ; Registers Destroyed:
035C                             ;    A,BC,DE,HL
035C                             ; *****************************************************************************
035C                NEXTTOKEN:      
035C   21 84 31               LD   hl,vToken   ; hl points to vToken
035F   7E                     LD   a,(hl)   ; load a with pushed back vToken
0360   CB 7F                  BIT   7,a   ; Check the high bit of token
0362   CA 6C 03               JP   z,nextToken1   ; If high bit clear,nothing pushed back
0365   CB BF                  RES   7,a   ; Clear high bit
0367   77                     LD   (hl),a   ; Store the character back in the BUFFER
0368   2A 85 31               LD   hl,(vTokenVal)   ; put token value into HL
036B   C9                     RET      ; Return with the pushed back character in A
036C                NEXTTOKEN1:      
036C   CD 2E 05               CALL   nextChar   ; Get the next character
036F   21 00 00               LD   hl,0   ; Initialize HL with 0
0372   FE 20                  CP   " "   ; is it space?
0374   28 F6                  JR   z,nextToken1   ; If yes,skip it and get the next character
0376   FE FF                  CP   EOF   ; Is it null (end of input)?
0378   20 03                  JR   nz,nextToken2   ; If not,continue to the next check
037A   3E 00                  LD   a,EOF_   ; If yes,return with EOF token
037C   C9                     RET      
037D                NEXTTOKEN2:      
037D   FE 5C                  CP   $5C   ; Is it a statement separator? "\"
037F   28 08                  JR   z,nextToken2a   ; If not,continue to the next check
0381   FE 3A                  CP   ":"   ; Is it a statement separator? ":"
0383   28 04                  JR   z,nextToken2a   ; If not,continue to the next check
0385   FE 0A                  CP   "\n"   ; Is it a new line
0387   20 03                  JR   nz,nextToken3   ; If not,continue to the next check
0389                NEXTTOKEN2A:      
0389   3E 0A                  LD   a,NEWLN_   ; If yes,return with NEWLIN token
038B   C9                     RET      ; Return with newline token
038C                NEXTTOKEN3:      
038C   FE 3B                  CP   ";"   ; Is it a comment?
038E   20 0C                  JR   nz,nextToken5   ; If not,continue to the next check
0390                NEXTTOKEN4:      
0390   CD 2E 05               CALL   nextChar   ; Get the next character in the comment
0393   FE 21                  CP   " "+1   ; Loop until the next control character
0395   30 F9                  JR   nc,nextToken4   
0397   CD 96 05               CALL   rewindChar   ; Push back the character
039A   18 D0                  JR   nextToken1   ; return with control char
039C                NEXTTOKEN5:      
039C   FE 5F                  CP   "_"   ; Is it an identifier?
039E   28 05                  JR   z,nextToken6   ; If yes,continue to the next check
03A0   CD C9 04               CALL   isAlpha   ; If not,check if it's alphabetic
03A3   30 34                  JR   nc,nextToken11   ; If not,continue to the next check
03A5                NEXTTOKEN6:      
03A5   CD 26 04               CALL   ident   ; Parse the identifier
03A8   FE 3A                  CP   ":"   ; Is it a label?
03AA   20 03                  JR   nz,nextToken7   ; If not,continue to the next check
03AC   3E 03                  LD   a,LABEL_   ; If yes,return A = LABEL HL = string
03AE   C9                     RET      
03AF                NEXTTOKEN7:      
03AF   CD 96 05               CALL   rewindChar   ; Push back the character
03B2   22 8F 31               LD   (vHeapPtr),hl   ; Restore string heap pointer to previous location
03B5   CD 46 04               CALL   searchOpcode   
03B8   20 06                  JR   nz,nextToken8   
03BA   6F                     LD   l,a   ; hl = opcode value
03BB   26 00                  LD   h,0   
03BD   3E 05                  LD   a,OPCODE_   ; Return with OPCODE token
03BF   C9                     RET      
03C0                NEXTTOKEN8:      
03C0   CD 73 04               CALL   searchOpElem   
03C3   20 03                  JR   nz,nextToken9   
03C5   3E 06                  LD   a,OPELEM_   ; Return with OPELEM token
03C7   C9                     RET      
03C8                NEXTTOKEN9:      
03C8   11 41 07               LD   de,directives   ; List of directives to search
03CB   CD 95 04               CALL   searchStr   
03CE   20 06                  JR   nz,nextToken10   
03D0   6F                     LD   l,a   ; hl = directive value
03D1   26 00                  LD   h,0   
03D3   3E 01                  LD   a,DIRECT_   ; Return with DIRECT token
03D5   C9                     RET      
03D6                NEXTTOKEN10:      
03D6   3E 02                  LD   a,IDENT_   ; Return with IDENT token
03D8   C9                     RET      
03D9                NEXTTOKEN11:      
03D9   21 00 00               LD   hl,0   
03DC   FE 24                  CP   "$"   ; Is it a hexadecimal number?
03DE   20 1A                  JR   nz,nextToken13   ; If not,continue to the next check
03E0   CD 2E 05               CALL   nextChar   ; Get the next character
03E3   CD C5 04               CALL   isAlphaNum   ; Check if it's the ASSEMBLY pointer
03E6   28 06                  JR   z,nextToken12   ; If not,continue to the next check
03E8   CD 96 05               CALL   rewindChar   ; Push back the character (flags unaffected)
03EB   3E 24                  LD   a,DOLLAR_   ; Return with DOLLAR token
03ED   C9                     RET      ; Return with the DOLLAR token
03EE                NEXTTOKEN12:      
03EE   CD 96 05               CALL   rewindChar   ; Push back the character (flags unaffected)
03F1   CD 01 05               CALL   hexadecimal   ; Process hexadecimal number
03F4   CD 96 05               CALL   rewindChar   ; Push back the character (flags unaffected)
03F7   3E 04                  LD   a,NUM_   ; Return with NUM token
03F9   C9                     RET      
03FA                NEXTTOKEN13:      
03FA   CD DB 04               CALL   isDigit   ; Check if it's a digit
03FD   30 0C                  JR   nc,nextToken14   ; Jump to the next check
03FF   CD 96 05               CALL   rewindChar   ; Push back the character (flags unaffected)
0402   CD E2 04               CALL   decimal   ; parse decimal
0405   CD 96 05               CALL   rewindChar   ; Push back the character (flags unaffected)
0408   3E 04                  LD   a,NUM_   ; Return with NUM token
040A   C9                     RET      
040B                NEXTTOKEN14:      
040B   FE 2B                  CP   "+"   ; If "+" then return PLUS token
040D   C8                     RET   z   
040E   FE 2D                  CP   "-"   ; If "-" then return MINUS token
0410   C8                     RET   z   
0411   FE 28                  CP   "("   ; If "(" then return LPAREN token
0413   C8                     RET   z   
0414   FE 29                  CP   ")"   ; If ")" then return LPAREN token
0416   C8                     RET   z   
0417   FE 2C                  CP   ","   ; If "," then return COMMA token
0419   C8                     RET   z   
041A   3E 64                  LD   a,UNKNOWN_   ; Return with UNKNOWN token
041C   C9                     RET      
041D                             ; *****************************************************************************
041D                             ; Routine: pushBackToken
041D                             ; 
041D                             ; Purpose:
041D                             ;    Pushes back a token into the pushback BUFFER to allow the token to be
041D                             ;    re-read by the nextToken routine.
041D                             ; 
041D                             ; Inputs:
041D                             ;    A  - token type
041D                             ;    HL - token value
041D                             ; 
041D                             ; Outputs:
041D                             ;    None
041D                             ; 
041D                             ; Registers Destroyed:
041D                             ;    A,DE
041D                             ; *****************************************************************************
041D                PUSHBACKTOKEN:      
041D   CB FF                  SET   7,a   ; Set the high bit of the token type (without affecting flags)
041F   32 84 31               LD   (vToken),a   ; push back the token
0422   22 85 31               LD   (vTokenVal),hl   ; push back the token value
0425   C9                     RET      
0426                             ; *****************************************************************************
0426                             ; Routine: ident
0426                             ; 
0426                             ; Purpose:
0426                             ;    Reads characters from the input stream until a charcter which is not an
0426                             ;    an underscore or an alphanumeric character is encountered. Writes the chars
0426                             ;    to a Pascal string and updates the top of the STRINGS heap pointer.
0426                             ;    It also calculates the length of the string and stores it at the beginning
0426                             ;    of the string.
0426                             ; 
0426                             ; Inputs:
0426                             ;    A - Current character read from the input stream
0426                             ;    vHeapPtr - Address of the top of heap pointer
0426                             ; 
0426                             ; Outputs:
0426                             ;    A - last character read from the input stream
0426                             ;    HL - identifier string
0426                             ; 
0426                             ; Registers Destroyed:
0426                             ;    DE,HL
0426                             ; *****************************************************************************
0426                IDENT:       
0426   2A 8F 31               LD   hl,(vHeapPtr)   ; Load the address of the top of STRINGS heap
0429   E5                     PUSH   hl   ; save start of string
042A   23                     INC   hl   ; Move to the next byte to skip the length byte
042B                IDENT1:      
042B   77                     LD   (hl),a   ; Write the current character to the string BUFFER
042C   23                     INC   hl   ; Move to the next position in the BUFFER
042D   E5                     PUSH   hl   
042E   CD 2E 05               CALL   nextChar   ; Get the next character from the input stream
0431   E1                     POP   hl   
0432   FE 5F                  CP   "_"   ; Compare with underscore character
0434   28 F5                  JR   z,ident1   ; If underscore,jump to ident2
0436   CD C5 04               CALL   isAlphanum   ; Check if the character is alphanumeric
0439   38 F0                  JR   c,ident1   ; If not alphanumeric,jump to ident3
043B                IDENT3:      
043B   22 8F 31               LD   (vHeapPtr),hl   ; Update the top of STRINGS heap pointer
043E   D1                     POP   de   ; restore start of string into de
043F   B7                     OR   a   ; Clear carry
0440   ED 52                  SBC   hl,de   ; Calculate the length of the string (HL = length,DE = string)
0442   2D                     DEC   l   ; reduce by one (length byte)
0443   EB                     EX   de,hl   ; Swap DE and HL (E = length,HL = string)
0444   73                     LD   (hl),e   ; Store the length at the beginning of the string BUFFER
0445   C9                     RET      
0446                             ; *****************************************************************************
0446                             ; Routine: searchOpcode
0446                             ; 
0446                             ; Purpose:
0446                             ;    Searches for a matching opcode in various lists of opcodes.
0446                             ; 
0446                             ; Inputs:
0446                             ;    HL - Points to the string to search for.
0446                             ; 
0446                             ; Outputs:
0446                             ;    ZF - Set if a match is found,cleared otherwise.
0446                             ;    A  - Contains the index of the matching opcode if a match is found,
0446                             ;         or the last checked index if no match is found.
0446                             ; 
0446                             ; Registers Destroyed:
0446                             ;    A,DE,F
0446                             ; *****************************************************************************
0446                SEARCHOPCODE:      
0446   11 01 06               LD   de,alu_opcodes   ; Point DE to the list of ALU opcodes
0449   CD 95 04               CALL   searchStr   ; Search for the string in ALU opcodes
044C   C8                     RET   z   ; If match found (ZF set),return
044D   11 E2 05               LD   de,rot_opcodes   ; Point DE to the list of ROT opcodes
0450   CD 95 04               CALL   searchStr   ; Search for the string in ROT opcodes
0453   CB EF                  SET   5,a   ; Set bit 5 in A to indicate ROT opcodes
0455   C8                     RET   z   ; If match found (ZF set),return
0456   11 20 06               LD   de,bli_opcodes   ; Point DE to the list of BLI opcodes
0459   CD 95 04               CALL   searchStr   ; Search for the string in BLI opcodes
045C   CB F7                  SET   6,a   ; Set bit 6 in A to indicate BLI opcodes
045E   C8                     RET   z   ; If match found (ZF set),return
045F   11 6B 06               LD   de,gen1_opcodes   ; Point DE to the list of general opcodes (set 1)
0462   CD 95 04               CALL   searchStr   ; Search for the string in general opcodes
0465   CB EF                  SET   5,a   ; Set bits 5 & 6 in A to indicate general opcodes (set 1)
0467   CB F7                  SET   6,a   
0469   C8                     RET   z   ; If match found (ZF set),return
046A   11 94 06               LD   de,gen2_opcodes   ; Point DE to the list of general opcodes (set 2)
046D   CD 95 04               CALL   searchStr   ; Search for the string in general opcodes
0470   CB FF                  SET   7,a   ; Set bit 7 in A to indicate general opcodes (set 2)
0472   C9                     RET      ; Return ZF = match
0473                             ; *****************************************************************************
0473                             ; Routine: searchOpElem
0473                             ; 
0473                             ; Purpose:
0473                             ;    Searches for an op element in the lists of 8-bit registers,16-bit registers,
0473                             ;    and flags. Sets appropriate flags based on the type of operand found.
0473                             ; 
0473                             ; Inputs:
0473                             ;    HL - Points to the start of the string to search for.
0473                             ; 
0473                             ; Outputs:
0473                             ;    H  - the value of the op element
0473                             ;    L  - The type of the op element
0473                             ;    ZF - Set if a match is found,cleared otherwise.
0473                             ; 
0473                             ; Registers Destroyed:
0473                             ;    A,DE,HL
0473                             ; *****************************************************************************
0473                SEARCHOPELEM:      
0473   11 FD 06               LD   de,reg8   ; Point DE to the list of 8-bit register operands
0476   CD 95 04               CALL   searchStr   ; Search for the string in reg8 operands
0479   20 04                  JR   nz,searchOpElem1   
047B   67                     LD   h,a   
047C   2E 00                  LD   l,reg_   
047E   C9                     RET      ; If match found (ZF set),return
047F                SEARCHOPELEM1:      
047F   11 12 07               LD   de,reg16   ; Point DE to the list of 16-bit register operands
0482   CD 95 04               CALL   searchStr   ; Search for the string in reg16 operands
0485   20 04                  JR   nz,searchOpElem2   
0487   67                     LD   h,a   
0488   2E 01                  LD   l,rp_   
048A   C9                     RET      ; If match found (ZF set),return
048B                SEARCHOPELEM2:      
048B   11 2C 07               LD   de,flags   ; Point DE to the list of flag operands
048E   CD 95 04               CALL   searchStr   ; Search for the string in flag operands
0491   67                     LD   h,a   
0492   2E 02                  LD   l,flag_   
0494   C9                     RET      ; Return ZF = match
0495                             ; *****************************************************************************
0495                             ; Routine: searchStr
0495                             ; 
0495                             ; Purpose:
0495                             ;    Search through a list of Pascal STRINGS for a match.
0495                             ; 
0495                             ; Inputs:
0495                             ;    HL - Points to the string to search for.
0495                             ;    DE - Points to the start of the list of STRINGS.
0495                             ; 
0495                             ; Outputs:
0495                             ;    ZF - True if match,false otherwise.
0495                             ;    A - Index of the matching string if a match is found,or -1 if no match
0495                             ;        is found.
0495                             ;    HL - Points to the string to search for.
0495                             ; 
0495                             ; Destroyed:
0495                             ;    A,B,C,D,E,A",F"
0495                             ; *****************************************************************************
0495                SEARCHSTR:      
0495   06 00                  LD   b,0   ; init b with index 0
0497                SEARCHSTR1:      
0497   CD AD 04               CALL   compareStr   ; compare strings
049A   20 02                  JR   nz,searchStr3   
049C   78                     LD   a,b   ; Load index of match
049D   C9                     RET      ; ZF = true
049E                SEARCHSTR3:      
049E   1A                     LD   a,(de)   ; Load length of current string
049F   3C                     INC   a   ; A = length byte plus length of string
04A0   83                     ADD   a,e   ; DE += A, move DE to point to next string
04A1   5F                     LD   e,a   
04A2   3E 00                  LD   a,0   
04A4   8A                     ADC   a,d   
04A5   57                     LD   d,a   
04A6   04                     INC   b   ; increase index
04A7   1A                     LD   a,(de)   ; A = length of next string
04A8   B7                     OR   a   ; If A != 0,continue searching
04A9   20 EC                  JR   nz,searchStr1   
04AB   3D                     DEC   a   ; A = NO_MATCH (i.e.,-1),ZF = false
04AC   C9                     RET      
04AD                             ; *****************************************************************************
04AD                             ; Routine: compareStr
04AD                             ; 
04AD                             ; Purpose:
04AD                             ;    Compares two Pascal strings. The comparison includes
04AD                             ;    the length byte and continues until all characters are compared or a
04AD                             ;    mismatch is found.
04AD                             ; 
04AD                             ; Inputs:
04AD                             ;    DE - Points to the start of string1
04AD                             ;    HL - Points to the start of string2
04AD                             ; 
04AD                             ; Outputs:
04AD                             ;    ZF - Set if the strings are equal
04AD                             ; 
04AD                             ; Registers Destroyed:
04AD                             ;    A
04AD                             ; *****************************************************************************
04AD                COMPARESTR:      
04AD   C5                     PUSH   bc   ; save BC,DE,HL
04AE   D5                     PUSH   de   
04AF   E5                     PUSH   hl   
04B0   1A                     LD   a,(de)   ; Load length of search string
04B1   47                     LD   b,a   ; Copy length to B for looping
04B2   04                     INC   b   ; Increase to include length byte
04B3                COMPARESTR2:      
04B3   1A                     LD   a,(de)   ; Load next character from search string
04B4   BE                     CP   (hl)   ; Compare with next character in current string
04B5   20 04                  JR   nz,compareStr3   ; break if characters are not equal
04B7   13                     INC   de   ; Move to next character in search string
04B8   23                     INC   hl   ; Move to next character in current string
04B9   10 F8                  DJNZ   compareStr2   ; Loop until all characters compared or mismatch
04BB                COMPARESTR3:      
04BB   E1                     POP   hl   ; restore BC,DE,HL
04BC   D1                     POP   de   
04BD   C1                     POP   bc   
04BE   C9                     RET      ; Return with ZF set if strings are equal
04BF                             ; *****************************************************************************
04BF                             ; Routine: isEndOfLine
04BF                             ; 
04BF                             ; Purpose:
04BF                             ;    Checks if the token is the end-of-file (EOF) or a newline (NEWLN).
04BF                             ; 
04BF                             ; Inputs:
04BF                             ;    A - The token to check.
04BF                             ; 
04BF                             ; Outputs:
04BF                             ;    Z flag - Set if the token is EOF or NEWLN, cleared otherwise.
04BF                             ; 
04BF                             ; Registers Destroyed:
04BF                             ;    None
04BF                             ; *****************************************************************************
04BF                ISENDOFLINE:      
04BF   FE 00                  CP   EOF_   ; Compare the current character with EOF_
04C1   C8                     RET   z   ; Return if the current character is EOF (Z flag set)
04C2   FE 0A                  CP   NEWLN_   ; Compare the current character with NEWLN_
04C4   C9                     RET      ; Return (Z flag set if NEWLN_, cleared otherwise)
04C5                             ; ; *****************************************************************************
04C5                             ; ; Routine: isIndexReg
04C5                             ; ;
04C5                             ; ; Purpose:
04C5                             ; ;    Checks if the current operand is an index register (IX or IY).
04C5                             ; ;
04C5                             ; ; Inputs:
04C5                             ; ;    A - The operand to check.
04C5                             ; ;
04C5                             ; ; Outputs:
04C5                             ; ;    ZF - Set if the operand is an index register (IX or IY).
04C5                             ; ;
04C5                             ; ; Registers Destroyed:
04C5                             ; ;    None
04C5                             ; ; *****************************************************************************
04C5                             ; isIndexReg:
04C5                             ;     cp IX_                      ; Compare operand with IX
04C5                             ;     ret z                       ; Return if equal (ZF is set)
04C5                             ;     cp IY_                      ; Compare operand with IY
04C5                             ;     ret                         ; Return (ZF is set if equal,cleared otherwise)
04C5                             ; *****************************************************************************
04C5                             ; Routine: isAlphaNum
04C5                             ; 
04C5                             ; Purpose:
04C5                             ;    Checks if the character in the A register is an alphanumeric character
04C5                             ;    (either uppercase or lowercase). If the character is alphabetic,it converts
04C5                             ;    it to uppercase and sets the carry flag. If the character is not alphabetic,
04C5                             ;    it clears the carry flag.
04C5                             ; 
04C5                             ; Input:
04C5                             ;    A - Contains the character to be checked.
04C5                             ; 
04C5                             ; Output:
04C5                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
04C5                             ;    CF - Set if the input character was alphabetic,cleared otherwise.
04C5                             ; 
04C5                             ; Destroyed:
04C5                             ;    C
04C5                             ; *****************************************************************************
04C5                ISALPHANUM:      
04C5   CD DB 04               CALL   isDigit   ; Check if it's a digit
04C8   C8                     RET   z   ; If it's not a digit,continue to isAlpha
04C9                             ; Falls through to isAlpha
04C9                             ; *****************************************************************************
04C9                             ; Routine: isAlpha
04C9                             ; 
04C9                             ; Purpose:
04C9                             ;    Checks if the character in the A register is an alphabetic character
04C9                             ;    (either uppercase or lowercase). If the character is alphabetic,it converts
04C9                             ;    it to uppercase and sets the carry flag.
04C9                             ; 
04C9                             ; Input:
04C9                             ;    A - Contains the character to be checked.
04C9                             ; 
04C9                             ; Output:
04C9                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
04C9                             ;    CF - Set if the input character was alphabetic,cleared otherwise.
04C9                             ; 
04C9                             ; Destroyed:
04C9                             ;    None
04C9                             ; *****************************************************************************
04C9                ISALPHA:      
04C9   FE 7B                  CP   "z"+1   ; Compare with "Z" + 1
04CB   D0                     RET   nc   ; Return if it's not alphabetic,no carry
04CC   FE 61                  CP   "a"   ; Compare with lowercase "a"
04CE   38 04                  JR   c,isAlpha1   ; Jump if it"s lower than "a'
04D0   D6 20                  SUB   $20   ; It's lowercase alpha so convert lowercase to uppercase
04D2   37                     SCF      ; no carry so set carry flag
04D3   C9                     RET      
04D4                ISALPHA1:      
04D4   FE 5B                  CP   "Z"+1   ; Compare with "Z" + 1
04D6   D0                     RET   nc   ; Return if it's not alphabetic,no carry
04D7   FE 41                  CP   "A"   ; Compare with "A"
04D9   3F                     CCF      ; Invert CF to set it if it's alphabetic
04DA   C9                     RET      
04DB                             ; *****************************************************************************
04DB                             ; Routine: isDigit
04DB                             ; 
04DB                             ; Purpose:
04DB                             ;    Checks if the character in the A register is a decimal digit (0-9). If
04DB                             ;    the character is a decimal digit,it sets the carry flag.
04DB                             ; 
04DB                             ; Input:
04DB                             ;    A - Contains the character to be checked.
04DB                             ; 
04DB                             ; Output:
04DB                             ;    CF - Set if the input character was a digit,cleared otherwise.
04DB                             ; 
04DB                             ; Destroyed:
04DB                             ;    None
04DB                             ; *****************************************************************************
04DB                ISDIGIT:      
04DB   FE 3A                  CP   "9"+1   ; Compare with "9" + 1
04DD   D0                     RET   nc   ; Return if it's not a digit
04DE   FE 30                  CP   "0"   ; Compare with "0"
04E0   3F                     CCF      ; Invert CF to set it if it's a digit
04E1   C9                     RET      
04E2                             ; *****************************************************************************
04E2                             ; Routine: decimal
04E2                             ; 
04E2                             ; Purpose:
04E2                             ;    Parse a decimal number.
04E2                             ; 
04E2                             ; Input:
04E2                             ;    None
04E2                             ; 
04E2                             ; Output:
04E2                             ;    HL - Parsed number.
04E2                             ; 
04E2                             ; Destroyed:
04E2                             ;    A,DE
04E2                             ; *****************************************************************************
04E2                DECIMAL:      
04E2   21 00 00               LD   hl,0   ; Initialize HL to 0
04E5                DECIMAL1:      
04E5   D5                     PUSH   de   
04E6   E5                     PUSH   hl   
04E7   CD 2E 05               CALL   nextChar   ; Get the next character
04EA   E1                     POP   hl   
04EB   D1                     POP   de   
04EC   D6 30                  SUB   "0"   ; Convert ASCII to binary
04EE   D8                     RET   c   ; Return if less than "0"
04EF   FE 0A                  CP   10   ; Compare with 10
04F1   D0                     RET   nc   ; Return if greater than 10
04F2   03                     INC   bc   ; Increment BC to point to next digit
04F3   54 5D                  LD   de,hl   ; Copy HL to DE
04F5   29                     ADD   hl,hl   ; Multiply HL by 2
04F6   29                     ADD   hl,hl   ; Multiply HL by 4
04F7   19                     ADD   hl,de   ; Add DE to HL to multiply by 5
04F8   29                     ADD   hl,hl   ; Multiply HL by 10
04F9   85                     ADD   a,l   ; Add A to HL
04FA   6F                     LD   l,a   ; Store result back in L
04FB   3E 00                  LD   a,0   ; Clear A
04FD   8C                     ADC   a,h   ; Add carry to H
04FE   67                     LD   h,a   ; Store result back in H
04FF   18 E4                  JR   decimal1   ; Jump back to start of loop
0501                             ; *****************************************************************************
0501                             ; Routine: hexadecimal
0501                             ; 
0501                             ; Purpose:
0501                             ;    Parse a hexadecimal number.
0501                             ; 
0501                             ; Input:
0501                             ;    None
0501                             ; 
0501                             ; Output:
0501                             ;    HL - Parsed number.
0501                             ; 
0501                             ; Destroyed:
0501                             ;    A
0501                             ; *****************************************************************************
0501                HEXADECIMAL:      
0501   21 00 00               LD   hl,0   ; Initialize HL to 0
0504                HEXADECIMAL1:      
0504   E5                     PUSH   hl   
0505   CD 2E 05               CALL   nextChar   ; Get the next character
0508   E1                     POP   hl   
0509   FE 30                  CP   "0"   ; Compare with ASCII "0"
050B   D8                     RET   c   ; Return if less than "0"
050C   FE 3A                  CP   "9"+1   ; Compare with ASCII "9" + 1
050E   38 0F                  JR   c,hexadecimal4   ; If less or equal,jump to valid
0510   FE 61                  CP   "a"   ; Compare with ASCII "a"
0512   38 02                  JR   c,hexadecimal2   ; If less,jump to hexadecimal2
0514   D6 20                  SUB   $20   ; Convert lowercase to uppercase
0516                HEXADECIMAL2:      
0516   FE 41                  CP   "A"   ; Compare with ASCII "A"
0518   D8                     RET   c   ; Return if less than "A"
0519   FE 47                  CP   "F"+1   ; Compare with ASCII "F" + 1
051B   38 00                  JR   c,hexadecimal3   ; If less or equal,jump to hexadecimal3
051D                HEXADECIMAL3:      
051D   D6 37                  SUB   $37   ; Convert ASCII to hexadecimal
051F                HEXADECIMAL4:      
051F   D6 30                  SUB   "0"   ; Convert ASCII to numeric value
0521   D8                     RET   c   ; Return if less than 0 (not a valid digit)
0522   FE 10                  CP   $10   ; Compare with 16
0524   D0                     RET   nc   ; Return if greater than 16 (not a valid digit)
0525   29                     ADD   hl,hl   ; Multiply by 16
0526   29                     ADD   hl,hl   ; Multiply by 16
0527   29                     ADD   hl,hl   ; Multiply by 16
0528   29                     ADD   hl,hl   ; Multiply by 16
0529   85                     ADD   a,l   ; Add new digit to HL
052A   6F                     LD   l,a   ; Store result back in L
052B   C3 04 05               JP   hexadecimal1   ; Jump back to hexadecimal1 to process next character
052E                             ; *****************************************************************************
052E                             ; Routine: nextChar
052E                             ; 
052E                             ; Purpose:
052E                             ;    Fetches the next character from the BUFFER. If the BUFFER is empty or
052E                             ;    contains a null character (0),it refills the BUFFER by calling nextLine.
052E                             ; 
052E                             ; Inputs:
052E                             ;    None
052E                             ; 
052E                             ; Outputs:
052E                             ;    A - The next character from the BUFFER
052E                             ; 
052E                             ; Registers Destroyed:
052E                             ;    A,D,E,HL
052E                             ; *****************************************************************************
052E                NEXTCHAR:      
052E   21 87 31               LD   hl,vBufferPos   ; Load the offset of BUFFER position variable
0531   7E                     LD   a,(hl)   ; Load the current position offset in the BUFFER into A
0532   FE 80                  CP   BUFFER_SIZE   ; Compare with BUFFER size
0534   CA 45 05               JP   z,nextLine   ; Jump to nextLine if end of BUFFER
0537   11 00 30               LD   de,BUFFER   ; Load the MSB of the BUFFER's address into D
053A   83                     ADD   a,e   ; de += a
053B   5F                     LD   e,a   
053C   3E 00                  LD   a,0   
053E   8A                     ADC   a,d   
053F   57                     LD   d,a   
0540   1A                     LD   a,(de)   ; Load the character at the current BUFFER position into A
0541   34                     INC   (hl)   ; Increment the BUFFER position offset
0542   FE 0A                  CP   "\n"   ; if a != null return else load a new line into buffer
0544   C0                     RET   nz   
0545                NEXTLINE:      
0545   21 00 30               LD   hl,BUFFER   ; Start of the BUFFER
0548   06 80                  LD   b,BUFFER_SIZE   ; Number of bytes to fill
054A                NEXTLINE1:      
054A   CD 81 00               CALL   getchar   ; Get a character from getchar
054D   FE FF                  CP   EOF   ; is it EOF
054F   28 32                  JR   z,nextLine6   
0551   B7                     OR   a   ; is it NULL?
0552   28 04                  JR   z,nextLine2   
0554   FE 03                  CP   CTRL_C   ; is it ctrl-C ?
0556   20 04                  JR   nz,nextLine3   
0558                NEXTLINE2:      
0558   3E FF                  LD   a,EOF   
055A   18 27                  JR   nextLine6   
055C                NEXTLINE3:      
055C   FE 08                  CP   "\b"   ; Check if character is backspace
055E   20 10                  JR   nz,nextLine4   ; If not,proceed to store the character
0560   3E 80                  LD   a,BUFFER_SIZE   
0562   90                     SUB   b   ; Check if at the start of the buffer
0563   28 E5                  JR   z,nextLine1   ; If at the start,ignore backspace
0565   2B                     DEC   hl   ; Move back in the buffer
0566   04                     INC   b   ; Adjust buffer size counter
0567   CD B5 05               CALL   print   ; Erase the character at the current cursor position
056A   1B 5B 50 00            .CSTR   ESC,"[P"   ; Escape sequence for erasing character
056E   18 DA                  JR   nextLine1   
0570                NEXTLINE4:      
0570   CD 87 00               CALL   putchar   ; Echo character to terminal
0573   FE 09                  CP   "\t"   
0575   20 04                  JR   nz,nextLine5   ; if a == CR or NL replace with null
0577   3E 20                  LD   a," "   
0579   18 08                  JR   nextLine6   
057B                NEXTLINE5:      
057B   FE 0D                  CP   "\r"   ; Check if character is carriage return
057D   20 04                  JR   nz,nextLine6   
057F   3E 0A                  LD   a,"\n"   
0581   18 00                  JR   nextLine6   
0583                NEXTLINE6:      
0583   77                     LD   (hl),a   ; Store the character in the BUFFER
0584   23                     INC   hl   ; Move to the next position in the BUFFER
0585   FE FF                  CP   EOF   ; Break loop if character is end of line
0587   28 06                  JR   z,nextLine7   
0589   FE 0A                  CP   "\n"   ; Break loop if character is end of line
058B   28 02                  JR   z,nextLine7   
058D   10 BB                  DJNZ   nextLine1   ; Repeat until BUFFER is full
058F                NEXTLINE7:      
058F   21 87 31               LD   hl,vBufferPos   
0592   36 00                  LD   (hl),0   
0594   18 98                  JR   nextChar   
0596                             ; *****************************************************************************
0596                             ; Routine: rewindChar
0596                             ; 
0596                             ; Purpose:
0596                             ;    Rewinds the BUFFER position by one character,effectively pushing back the
0596                             ;    BUFFER position by one character in the input stream.
0596                             ; 
0596                             ; Inputs:
0596                             ;    None
0596                             ; 
0596                             ; Outputs:
0596                             ;    None
0596                             ; 
0596                             ; Registers Destroyed:
0596                             ;    A
0596                             ; *****************************************************************************
0596                REWINDCHAR:      
0596   3A 87 31               LD   a,(vBufferPos)   ; Load the current position in the BUFFER into A
0599   B7                     OR   a   ; Check if the BUFFER position is zero
059A   C8                     RET   z   ; If zero,nothing to push back,return
059B   3D                     DEC   a   ; Decrement the BUFFER position
059C   32 87 31               LD   (vBufferPos),a   
059F   C9                     RET      
05A0                             ; *****************************************************************************
05A0                             ; Routine: prompt
05A0                             ; 
05A0                             ; Purpose:
05A0                             ;    Prints a prompt symbol ("> ") to indicate readiness for user input.
05A0                             ; 
05A0                             ; Inputs:
05A0                             ;    None
05A0                             ; 
05A0                             ; Outputs:
05A0                             ;    None
05A0                             ; 
05A0                             ; Registers Destroyed:
05A0                             ;    A,HL
05A0                             ; *****************************************************************************
05A0                PROMPT:      
05A0   CD B5 05               CALL   print   ; Print the null-terminated string (prompt message)
05A3   0D 0A 3E 20 00         .CSTR   "\r\n> "   ; Define the prompt message
05A8   C9                     RET      ; Return to the caller
05A9                             ; *****************************************************************************
05A9                             ; Routine: crlf
05A9                             ; 
05A9                             ; Purpose:
05A9                             ;    Prints a carriage return and line feed (new line) to the output.
05A9                             ; 
05A9                             ; Inputs:
05A9                             ;    None
05A9                             ; 
05A9                             ; Outputs:
05A9                             ;    None
05A9                             ; 
05A9                             ; Registers Destroyed:
05A9                             ;    A,HL
05A9                             ; *****************************************************************************
05A9                CRLF:        
05A9   CD B5 05               CALL   print   ; Print the null-terminated string (carriage return and line feed)
05AC   0D 0A 00               .CSTR   "\r\n"   ; Define the carriage return and line feed message
05AF   C9                     RET      ; Return to the caller
05B0                             ; *****************************************************************************
05B0                             ; Routine: error
05B0                             ; 
05B0                             ; Purpose:
05B0                             ;    Prints an error message and halts execution.
05B0                             ; 
05B0                             ; Inputs:
05B0                             ;    (Stack) - The address of the error message to be printed
05B0                             ; 
05B0                             ; Outputs:
05B0                             ;    None
05B0                             ; 
05B0                             ; Registers Destroyed:
05B0                             ;    A,HL
05B0                             ; *****************************************************************************
05B0                ERROR:       
05B0   E1                     POP   hl   ; Retrieve the "return" address which is the address of the error message
05B1   CD BC 05               CALL   printStr   ; Call the routine to print the null-terminated string
05B4   76                     HALT      ; Halt the CPU
05B5                             ; *****************************************************************************
05B5                             ; Routine: print
05B5                             ; 
05B5                             ; Purpose:
05B5                             ;    Prints a null-terminated string starting from the address in HL.
05B5                             ; 
05B5                             ; Inputs:
05B5                             ;    HL - Points to the start of the string to be printed
05B5                             ; 
05B5                             ; Outputs:
05B5                             ;    None
05B5                             ; 
05B5                             ; Registers Destroyed:
05B5                             ;    None
05B5                             ; *****************************************************************************
05B5                PRINT:       
05B5   E3                     EX   (sp),hl   ; Swap HL with the value on the stack to preserve HL
05B6   CD C9 05               CALL   printZStr   ; Call the routine to print the null-terminated string
05B9   23                     INC   hl   ; Increment HL to skip the null terminator
05BA   E3                     EX   (sp),hl   ; Restore the original value of HL from the stack
05BB   C9                     RET      ; Return to the caller
05BC                             ; *****************************************************************************
05BC                             ; Routine: printStr
05BC                             ; 
05BC                             ; Purpose:
05BC                             ;    Prints a Pascal string stored in memory.
05BC                             ; 
05BC                             ; Inputs:
05BC                             ;    HL - Points to the start of the string (first byte is the length)
05BC                             ; 
05BC                             ; Outputs:
05BC                             ;    None
05BC                             ; 
05BC                             ; Registers Destroyed:
05BC                             ;    A,B,HL
05BC                             ; *****************************************************************************
05BC                PRINTSTR:      
05BC   7E                     LD   a,(hl)   ; Load the length of the string
05BD   B7                     OR   a   ; Check if the length is zero
05BE   C8                     RET   z   ; If zero,return immediately
05BF   23                     INC   hl   ; Move HL to the start of the string data
05C0   47                     LD   b,a   ; Copy the length to B for looping
05C1                PRINTSTR1:      
05C1   7E                     LD   a,(hl)   ; Load the next character
05C2   CD 87 00               CALL   putchar   ; Call a routine that prints a single character
05C5   23                     INC   hl   ; Move to the next character
05C6   10 F9                  DJNZ   printStr1   ; Decrement B and jump if not zero
05C8   C9                     RET      ; Return from the routine
05C9                             ; *****************************************************************************
05C9                             ; Routine: printZStr
05C9                             ; 
05C9                             ; Purpose:
05C9                             ;    Prints a null-terminated string stored in memory.
05C9                             ; 
05C9                             ; Inputs:
05C9                             ;    HL - Points to the start of the string to be printed
05C9                             ; 
05C9                             ; Outputs:
05C9                             ;    None
05C9                             ; 
05C9                             ; Registers Destroyed:
05C9                             ;    A,HL
05C9                             ; *****************************************************************************
05C9                PRINTZSTR:      
05C9   18 04                  JR   printZStr2   ; Jump to the loop condition
05CB                PRINTZSTR1:      
05CB   CD 87 00               CALL   putchar   ; Print the current character
05CE   23                     INC   hl   ; Move to the next character
05CF                PRINTZSTR2:      
05CF   7E                     LD   a,(hl)   ; Load the current character
05D0   B7                     OR   a   ; Check if the character is null
05D1   20 F8                  JR   nz,printZStr1   ; If not null,continue printing
05D3   C9                     RET      ; Return when null character is encountered
05D4                             ; *****************************************************************************
05D4                             ; Routine: hpush
05D4                             ; 
05D4                             ; Purpose:
05D4                             ;    Pushes a 16-bit value onto the heap. The value to be pushed is in DE,
05D4                             ;    and the heap pointer is updated accordingly.
05D4                             ; 
05D4                             ; Inputs:
05D4                             ;    DE - The 16-bit value to be pushed onto the heap.
05D4                             ; 
05D4                             ; Outputs:
05D4                             ;    Updates the heap pointer in vHeapPtr.
05D4                             ; 
05D4                             ; Registers Destroyed:
05D4                             ;    DE,HL
05D4                             ; *****************************************************************************
05D4                HPUSH:       
05D4   D5                     PUSH   de   ; Save DE
05D5   EB                     EX   de,hl   ; Exchange DE and HL to move value to DE
05D6   2A 8F 31               LD   hl,(vHeapPtr)   ; Load the current top of the heap into HL
05D9   72                     LD   (hl),d   ; Store the high byte of DE (now in HL) on the heap
05DA   23                     INC   hl   ; Increment HL to point to the next heap position
05DB   73                     LD   (hl),e   ; Store the low byte of DE (now in HL) on the heap
05DC   23                     INC   hl   ; Increment HL to point to the new top of the heap
05DD   22 8F 31               LD   (vHeapPtr),hl   ; Update the heap pointer with the new top of the heap
05E0   D1                     POP   de   ; Restore DE
05E1   C9                     RET      ; Return from the subroutine
05E2                             ; ; *****************************************************************************
05E2                             ; ; Routine: hpop
05E2                             ; ;
05E2                             ; ; Purpose:
05E2                             ; ;    Pops a 16-bit value from the heap into HL. The heap pointer is updated
05E2                             ; ;    accordingly.
05E2                             ; ;
05E2                             ; ; Inputs:
05E2                             ; ;    None
05E2                             ; ;
05E2                             ; ; Outputs:
05E2                             ; ;    HL - Contains the 16-bit value popped from the heap.
05E2                             ; ;    Updates the heap pointer in vHeapPtr.
05E2                             ; ;
05E2                             ; ; Registers Destroyed:
05E2                             ; ;    DE,HL
05E2                             ; ; *****************************************************************************
05E2                             ; hpop:
05E2                             ;     push de                   ; Save DE
05E2                             ;     ld hl,(vHeapPtr)          ; Load the current top of the heap into HL
05E2                             ;     dec hl                    ; Decrement HL to point to the high byte of the value
05E2                             ;     ld l,(hl)                 ; Load the low byte of the value into L
05E2                             ;     dec hl                    ; Decrement HL to point to the low byte of the value
05E2                             ;     ld h,(hl)                 ; Load the high byte of the value into H
05E2                             ;     ld (vHeapPtr),hl          ; Update the heap pointer with the new top of the heap
05E2                             ;     ex de,hl                  ; Exchange DE and HL to move the value to HL
05E2                             ;     pop de                    ; Restore DE
05E2                             ;     ret                       ; Return from the subroutine
05E2                             ; *******************************************************************************
05E2                             ; *********  END OF MAIN   ******************************************************
05E2                             ; *******************************************************************************
05E2                ROT_OPCODES:      
05E2   03 52 4C 43            .PSTR   "RLC"   
05E6   03 52 52 43            .PSTR   "RRC"   
05EA   02 52 4C               .PSTR   "RL"   
05ED   02 52 52               .PSTR   "RR"   
05F0   03 53 4C 41            .PSTR   "SLA"   
05F4   03 53 52 41            .PSTR   "SRA"   
05F8   03 53 4C 4C            .PSTR   "SLL"   
05FC   03 53 52 4C            .PSTR   "SRL"   
0600   00                     .PSTR   ""   ; terminate list with a string of zero length
0601                ALU_OPCODES:      
0601   03 41 44 44            .PSTR   "ADD"   
0605   03 41 44 43            .PSTR   "ADC"   
0609   03 53 55 42            .PSTR   "SUB"   
060D   03 53 42 43            .PSTR   "SBC"   
0611   03 41 4E 44            .PSTR   "AND"   
0615   03 58 4F 52            .PSTR   "XOR"   
0619   02 4F 52               .PSTR   "OR"   
061C   02 43 50               .PSTR   "CP"   
061F   00                     .PSTR   ""   ; terminate list with a string of zero length
0620                BLI_OPCODES:      
0620   03 4C 44 49            .PSTR   "LDI"   
0624   03 43 50 49            .PSTR   "CPI"   
0628   03 49 4E 49            .PSTR   "INI"   
062C   04 4F 55 54 49         .PSTR   "OUTI"   
0631   03 4C 44 44            .PSTR   "LDD"   
0635   03 43 50 44            .PSTR   "CPD"   
0639   03 49 4E 44            .PSTR   "IND"   
063D   04 4F 55 54 44         .PSTR   "OUTD"   
0642   04 4C 44 49 52         .PSTR   "LDIR"   
0647   04 43 50 49 52         .PSTR   "CPIR"   
064C   04 49 4E 49 52         .PSTR   "INIR"   
0651   04 4F 54 49 52         .PSTR   "OTIR"   
0656   04 4C 44 44 52         .PSTR   "LDDR"   
065B   04 43 50 44 52         .PSTR   "CPDR"   
0660   04 49 4E 44 52         .PSTR   "INDR"   
0665   04 4F 54 44 52         .PSTR   "OTDR"   
066A   00                     .PSTR   ""   ; terminate list with a string of zero length
066B                GEN1_OPCODES:      
066B   03 43 43 46            .PSTR   "CCF"   
066F   03 43 50 4C            .PSTR   "CPL"   
0673   03 44 41 41            .PSTR   "DAA"   
0677   02 44 49               .PSTR   "DI"   
067A   02 45 49               .PSTR   "EI"   
067D   04 48 41 4C 54         .PSTR   "HALT"   
0682   03 4E 4F 50            .PSTR   "NOP"   
0686   04 52 4C 43 41         .PSTR   "RLCA"   
068B   03 52 53 54            .PSTR   "RST"   
068F   03 53 43 46            .PSTR   "SCF"   
0693   00                     .PSTR   ""   ; terminate list with a string of zero length
0694                GEN2_OPCODES:      
0694   03 42 49 54            .PSTR   "BIT"   
0698   04 43 41 4C 4C         .PSTR   "CALL"   
069D   03 44 45 43            .PSTR   "DEC"   
06A1   04 44 4A 4E 5A         .PSTR   "DJNZ"   
06A6   02 45 58               .PSTR   "EX"   
06A9   03 45 58 58            .PSTR   "EXX"   
06AD   02 49 4D               .PSTR   "IM"   
06B0   02 49 4E               .PSTR   "IN"   
06B3   03 49 4E 43            .PSTR   "INC"   
06B7   02 4A 50               .PSTR   "JP"   
06BA   02 4A 52               .PSTR   "JR"   
06BD   02 4C 44               .PSTR   "LD"   
06C0   03 4E 45 47            .PSTR   "NEG"   
06C4   03 4F 55 54            .PSTR   "OUT"   
06C8   03 50 4F 50            .PSTR   "POP"   
06CC   04 50 55 53 48         .PSTR   "PUSH"   
06D1   03 52 45 53            .PSTR   "RES"   
06D5   03 52 45 54            .PSTR   "RET"   
06D9   04 52 45 54 49         .PSTR   "RETI"   
06DE   04 52 45 54 4E         .PSTR   "RETN"   
06E3   03 52 4C 41            .PSTR   "RLA"   
06E7   03 52 4C 44            .PSTR   "RLD"   
06EB   03 52 52 41            .PSTR   "RRA"   
06EF   04 52 52 43 41         .PSTR   "RRCA"   
06F4   03 52 52 44            .PSTR   "RRD"   
06F8   03 53 45 54            .PSTR   "SET"   
06FC   00                     .PSTR   ""   ; terminate list with a string of zero length
06FD                REG8:        
06FD   01 42                  .PSTR   "B"   
06FF   01 43                  .PSTR   "C"   
0701   01 44                  .PSTR   "D"   
0703   01 45                  .PSTR   "E"   
0705   01 48                  .PSTR   "H"   
0707   01 4C                  .PSTR   "L"   
0709   01 20                  .PSTR   " "   ; don't match, stand-in for (HL)
070B   01 41                  .PSTR   "A"   
070D   01 49                  .PSTR   "I"   
070F   01 52                  .PSTR   "R"   
0711   00                     .PSTR   ""   ; terminate list with a string of zero length
0712                REG16:       
0712   02 42 43               .PSTR   "BC"   
0715   02 44 45               .PSTR   "DE"   
0718   02 48 4C               .PSTR   "HL"   
071B   02 53 50               .PSTR   "SP"   
071E   02 49 58               .PSTR   "IX"   
0721   02 49 59               .PSTR   "IY"   
0724   03 41 46 27            .PSTR   "AF'"   
0728   02 41 46               .PSTR   "AF"   ; NOTE: AF has the same code as SP in some instructions
072B   00                     .PSTR   ""   ; terminate list with a string of zero length
072C                FLAGS:       
072C   02 4E 5A               .PSTR   "NZ"   
072F   01 5A                  .PSTR   "Z"   
0731   02 4E 43               .PSTR   "NC"   
0734   01 43                  .PSTR   "C"   
0736   02 50 4F               .PSTR   "PO"   
0739   02 50 45               .PSTR   "PE"   
073C   01 50                  .PSTR   "P"   
073E   01 4D                  .PSTR   "M"   
0740   00                     .PSTR   ""   ; terminate list with a string of zero length
0741                DIRECTIVES:      
0741   06 2E 41 4C 49 47 4E   .PSTR   ".ALIGN"   
0748   03 2E 44 42            .PSTR   ".DB"   
074C   04 2E 4F 52 47         .PSTR   ".ORG"   
0751   04 2E 53 45 54         .PSTR   ".SET"   
0756   00                     .PSTR   ""   ; terminate list with a string of zero length
0757                             ; *******************************************************************************
0757                             ; *********  END OF DATA   ******************************************************
0757                             ; *******************************************************************************
3000                          .ORG   RAMSTART   
3000                          ALIGN   $100   
3000                BUFFER:   DS   BUFFER_SIZE   ; line BUFFER,page aligned
3080                          DS   $100   
3180                STACK:       ; grows down
3180                VTEMP1:   DS   2   ; temp var 1
3182                VTEMP2:   DS   2   ; temp var 2
3184                VTOKEN:   DS   1   ; BUFFER for pushed back token
3185                VTOKENVAL:   DS   2   ; BUFFER for pushed back token value
3187                VBUFFERPOS:   DS   2   ; pointer to char position into input BUFFER
3189                VASMPTR:   DS   2   ; pointer to ASSEMBLY point
318B                VSYMPTR:   DS   2   ; pointer to last symbol
318D                VEXPRPTR:   DS   2   ; pointer to last expression
318F                VHEAPPTR:   DS   2   ; pointer to Heap
3191                VOPCODE:   DS   1   
3192                VOPERAND1:   DS   2   ; lsb = type, msb = val
3194                VOPERAND2:   DS   2   ; lsb = type, msb = val
3196                VOPEXPR:   DS   2   
3198                VOPDISP:   DS   2   
319A                RST08:    DS   2   
319C                RST10:    DS   2   
319E                RST18:    DS   2   
31A0                RST20:    DS   2   
31A2                RST28:    DS   2   
31A4                RST30:    DS   2   
31A6                BAUD:     DS   2   
31A8                INTVEC:   DS   2   
31AA                NMIVEC:   DS   2   
31AC                GETCVEC:   DS   2   
31AE                PUTCVEC:   DS   2   
31B0                HEAP:     DS   HEAP_SIZE   ; expression heap - grows up
32B0                ASSEMBLY:      
4000                          .ORG   $4000   
4000                TESTSSTART:      
4000   31 80 31               LD   sp,STACK   
4003                             ; ; ------------------------------------------------------------
4003                             ; call describe
4003                             ; .cstr "parse opcode with a reg operand, an indexed indirect operand"
4003                             ; call test
4003                             ; .db "ld a,(ix + 0)"
4003                             ; .db 0
4003                             ; call expectOpData
4003                             ; .db LD_, reg_ | A_, MHL_ | mem_ | index_
4003                             ; ------------------------------------------------------------
4003   CD 3D 41               CALL   describe   
4006   70 61 72 73 65 20 6F 70 63 6F 64 65 20 77 69 74 68 20 61 20 72 65 67 20 6F 70 65 72 61 6E 64 2C 20 61 6E 20 72 70 20 69 6E 64 69 72 65 63 74 20 6F 70 65 72 61 6E 64 00 .CSTR   "parse opcode with a reg operand, an rp indirect operand"   
403E   CD 46 41               CALL   test   
4041   6C 64 20 61 2C 28 68 6C 29 DB   "ld a,(hl)"   
404A   00                     DB   0   
404B   CD 7A 41               CALL   expectOpData   
404E   8B 00 07 04 02         DB   LD_,reg_,A_,reg_ | mem_,HL_   
4053                             ; ------------------------------------------------------------
4053   CD 3D 41               CALL   describe   
4056   70 61 72 73 65 20 6F 70 63 6F 64 65 20 77 69 74 68 20 61 20 66 6C 61 67 20 6F 70 65 72 61 6E 64 2C 20 61 6E 20 69 6D 6D 65 64 69 61 74 65 20 6F 70 65 72 61 6E 64 00 .CSTR   "parse opcode with a flag operand, an immediate operand"   
408D   CD 46 41               CALL   test   
4090   6A 70 20 6E 7A 2C 30   DB   "jp nz,0"   
4097   00                     DB   0   
4098   CD 7A 41               CALL   expectOpData   
409B   89 02 00 03 FF         DB   JP_,flag_,NZ_,immed_,-1   
40A0                             ; ------------------------------------------------------------
40A0   CD 3D 41               CALL   describe   
40A3   70 61 72 73 65 20 6F 70 63 6F 64 65 20 77 69 74 68 20 61 6E 20 69 6D 6D 65 64 69 61 74 65 20 6F 70 65 72 61 6E 64 00 .CSTR   "parse opcode with an immediate operand"   
40CA   CD 46 41               CALL   test   
40CD   6A 70 20 30            DB   "jp 0"   
40D1   00                     DB   0   
40D2   CD 7A 41               CALL   expectOpData   
40D5   89 FF FF 03 FF         DB   JP_,-1,-1,immed_,-1   
40DA                             ; ------------------------------------------------------------
40DA   CD 3D 41               CALL   describe   
40DD   70 61 72 73 65 20 6F 70 63 6F 64 65 20 77 69 74 68 6F 75 74 20 6F 70 65 72 61 6E 64 73 00 .CSTR   "parse opcode without operands"   
40FB   CD 46 41               CALL   test   
40FE   68 61 6C 74            DB   "halt"   
4102   00                     DB   0   
4103   CD 7A 41               CALL   expectOpData   
4106   65 FF FF FF FF         DB   HALT_,-1,-1,-1,-1   
410B                             ; ------------------------------------------------------------
410B   CD 3D 41               CALL   describe   
410E   49 74 20 73 68 6F 75 6C 64 20 64 6F 20 6E 6F 74 68 69 6E 67 00 .CSTR   "It should do nothing"   
4123   CD 46 41               CALL   test   
4126   00                     DB   0   
4127   CD 5E 41               CALL   expect   
412A   00                     DB   0   
412B                             ; ------------------------------------------------------------
412B                             ; .cstr "It should assemble one instruction"
412B                             ; call expect
412B                             ; .db 01,$76
412B   CD B5 05               CALL   print   
412E   0D 0A 44 6F 6E 65 21 00 .CSTR   "\r\nDone!"   
4136   76                     HALT      
4137                             ; *****************************************************************************
4137                             ; Test variables
4137                             ; *****************************************************************************
4137                TBDESC:      
4137   00 00                  DW   0   ; Address of the description
4139                TBTEXT:      
4139   00 00                  DW   0   ; Address of the test text
413B                TBPTR:       
413B   00 00                  DW   0   ; Pointer to the current position in the test text
413D                             ; *****************************************************************************
413D                             ; Routine: describe
413D                             ; 
413D                             ; Purpose:
413D                             ;    Stores the address of a description string in tbDesc and then skips the string.
413D                             ; 
413D                             ; Inputs:
413D                             ;    HL - Address of the description string
413D                             ; 
413D                             ; Outputs:
413D                             ;    None
413D                             ; 
413D                             ; Registers Destroyed:
413D                             ;    HL
413D                             ; *****************************************************************************
413D                DESCRIBE:      
413D   E1                     POP   hl   ; Retrieve the return address (address of the description string)
413E   22 37 41               LD   (tbDesc),hl   ; Store the address in tbDesc
4141   CD 74 42               CALL   skipZStr   ; Skip the description string
4144   23                     INC   hl   ; Move to the next byte after the null terminator
4145   E9                     JP   (hl)   ; Jump to the address specified by the next byte
4146                             ; *****************************************************************************
4146                             ; Routine: test
4146                             ; 
4146                             ; Purpose:
4146                             ;    Stores the address of a test text in tbText and tbPtr,and then skips the string.
4146                             ; 
4146                             ; Inputs:
4146                             ;    HL - Address of the test text
4146                             ; 
4146                             ; Outputs:
4146                             ;    None
4146                             ; 
4146                             ; Registers Destroyed:
4146                             ;    HL
4146                             ; *****************************************************************************
4146                TEST:        
4146   E1                     POP   hl   ; Retrieve the return address (address of the test text)
4147   22 39 41               LD   (tbText),hl   ; Store the address in tbText
414A   22 3B 41               LD   (tbPtr),hl   ; Initialize tbPtr with the address of the test text
414D   CD 74 42               CALL   skipZStr   ; Skip the test text string
4150   23                     INC   hl   ; Move to the next byte after the null terminator
4151   E5                     PUSH   hl   ; push new return address
4152   CD 98 01               CALL   init   ; Initialize the environment
4155   21 4A 42               LD   hl,testGetCharImpl   ; Load the address of testGetCharImpl
4158   22 AC 31               LD   (GETCVEC),hl   ; Set the GETCVEC to point to testGetCharImpl
415B   C3 F7 01               JP   statementList   
415E                             ; *****************************************************************************
415E                             ; Routine: expect
415E                             ; 
415E                             ; Purpose:
415E                             ;    Initializes the environment,sets up the testGetCharImpl,executes the statementList,
415E                             ;    and compares the result with the expected output.
415E                             ; 
415E                             ; Inputs:
415E                             ;    None
415E                             ; 
415E                             ; Outputs:
415E                             ;    None
415E                             ; 
415E                             ; Registers Destroyed:
415E                             ;    HL,DE
415E                             ; *****************************************************************************
415E                EXPECT:      
415E   E1                     POP   hl   ; Retrieve the return address
415F   11 B0 32               LD   de,ASSEMBLY   ; Load the expected output address into DE
4162   CD AD 04               CALL   compareStr   ; Compare the result with the expected output
4165   20 01                  JR   nz,expect1   ; If comparison fails,jump to expect1
4167   E9                     JP   (hl)   ; If comparison succeeds,jump to the return address
4168                EXPECT1:      
4168   CD B5 05               CALL   print   ; Print the failure message
416B   46 61 69 6C 65 64 21 00 .CSTR   "Failed!"   
4173   2A 39 41               LD   hl,(tbText)   ; Load the address of the test text
4176   CD C9 05               CALL   printZStr   ; Print the test text
4179   76                     HALT      ; Halt the program
417A                             ; *****************************************************************************
417A                             ; Routine: expectOpData
417A                             ; 
417A                             ; Purpose:
417A                             ;    Validate the sequence of opcode and operands against expected values.
417A                             ;    Print error messages if any mismatch occurs and jump to the next handler.
417A                             ; 
417A                             ; Inputs:
417A                             ;    DE - Points to the expected op data
417A                             ;    HL - Points to the actual op data
417A                             ; 
417A                             ; Outputs:
417A                             ;    Updates DE and HL as it processes each byte in the sequences.
417A                             ; 
417A                             ; Registers Destroyed:
417A                             ;    A,DE,HL
417A                             ; *****************************************************************************
417A                EXPECTOPDATA:      
417A   CD A9 05               CALL   crlf   
417D   D1                     POP   de   ; Load DE with the return address pointing to the actual opcode/operand sequence
417E   21 91 31               LD   hl,vOpcode   ; Load HL with the address of the expected opcode/operand sequence
4181   CD F5 41               CALL   expectOpItem   ; Compare actual and expected opcode
4184   57 72 6F 6E 67 20 6F 70 63 6F 64 65 00 .CSTR   "Wrong opcode"   ; Error message if the opcode does not match
4191   CD F5 41               CALL   expectOpItem   ; Compare actual and expected first operand
4194   57 72 6F 6E 67 20 6F 70 65 72 61 6E 64 20 74 79 70 65 20 31 00 .CSTR   "Wrong operand type 1"   ; Error message if the first operand does not match
41A9   CD F5 41               CALL   expectOpItem   ; Compare actual and expected first operand
41AC   57 72 6F 6E 67 20 6F 70 65 72 61 6E 64 20 76 61 6C 75 65 20 31 00 .CSTR   "Wrong operand value 1"   ; Error message if the first operand does not match
41C2   CD F5 41               CALL   expectOpItem   ; Compare actual and expected second operand
41C5   57 72 6F 6E 67 20 6F 70 65 72 61 6E 64 20 74 79 70 65 20 32 00 .CSTR   "Wrong operand type 2"   ; Error message if the second operand does not match
41DA   CD F5 41               CALL   expectOpItem   ; Compare actual and expected first operand
41DD   57 72 6F 6E 67 20 6F 70 65 72 61 6E 64 20 76 61 6C 75 65 20 32 00 .CSTR   "Wrong operand value 2"   ; Error message if the first operand does not match
41F3   EB                     EX   de,hl   
41F4   E9                     JP   (hl)   ; Jump to the address after expected op data
41F5                             ; *****************************************************************************
41F5                             ; Routine: expectOpItem
41F5                             ; 
41F5                             ; Purpose:
41F5                             ;    Compare the actual and expected opcode/operand byte and handle mismatches.
41F5                             ; 
41F5                             ; Inputs:
41F5                             ;    DE - Points to the expected byte.
41F5                             ;    HL - Points to the actual byte.
41F5                             ; 
41F5                             ; Outputs:
41F5                             ;    Increments DE and HL to the next byte in the sequences.
41F5                             ;    Prints error messages if any mismatch occurs.
41F5                             ; 
41F5                             ; Registers Destroyed:
41F5                             ;    A,DE,HL
41F5                             ; *****************************************************************************
41F5                EXPECTOPITEM:      
41F5   1A                     LD   a,(de)   ; Load the expected byte into A from DE
41F6   FE FF                  CP   -1   ; skip?
41F8   28 03                  JR   z,expectOpItem1   
41FA   BE                     CP   (hl)   ; Compare expected with actual
41FB   20 09                  JR   nz,expectOpItem2   ; If bytes match Return if the bytes match
41FD                EXPECTOPITEM1:      
41FD   13                     INC   de   ; Move DE to point to next expected byte
41FE   23                     INC   hl   ; Move HL to point to next actual byte
41FF   E3                     EX   (sp),hl   ; HL = expected string to skip (sp) = actual*
4200   CD 74 42               CALL   skipZStr   ; Skip the message string
4203   23                     INC   hl   ; Move to the next byte after the null terminator
4204   E3                     EX   (sp),hl   ; HL = actual* (SP) = expected string to skip
4205   C9                     RET      ; return after message string
4206                EXPECTOPITEM2:      
4206   E3                     EX   (sp),hl   ; save hl, hl = expected message
4207   D5                     PUSH   de   ; save de
4208   E5                     PUSH   hl   ; save message
4209   CD A9 05               CALL   crlf   
420C   2A 37 41               LD   hl,(tbDesc)   ; Load the address of the test text
420F   CD C9 05               CALL   printZStr   ; Print the test description
4212   CD A9 05               CALL   crlf   
4215   E1                     POP   hl   ; HL = expected message
4216   CD C9 05               CALL   printZStr   ; Print the test description
4219   CD A9 05               CALL   crlf   
421C   CD A9 05               CALL   crlf   
421F   CD B5 05               CALL   print   ; Print error messages if the bytes do not match
4222   45 78 70 65 63 74 65 64 3A 20 00 .CSTR   "Expected: "   ; Print "Expected"
422D   E1                     POP   hl   
422E   7E                     LD   a,(hl)   ; Load the expected byte into A for printing
422F   CD 60 42               CALL   printHex2   ; Print the expected byte in hexadecimal
4232   CD A9 05               CALL   crlf   
4235   CD B5 05               CALL   print   ; Print "Received"
4238   41 63 74 75 61 6C 3A 20 00 .CSTR   "Actual: "   
4241   E1                     POP   hl   
4242   7E                     LD   a,(hl)   ; Load the actual byte into A for printing
4243   CD 60 42               CALL   printHex2   ; Print the actual byte in hexadecimal
4246   CD A9 05               CALL   crlf   
4249   76                     HALT      ; Halt the program
424A                             ; *****************************************************************************
424A                             ; Routine: testGetCharImpl
424A                             ; 
424A                             ; Purpose:
424A                             ;    Retrieves the next character from the test text.
424A                             ; 
424A                             ; Inputs:
424A                             ;    tbPtr - Pointer to the current position in the test text
424A                             ; 
424A                             ; Outputs:
424A                             ;    A - The next character from the test text
424A                             ; 
424A                             ; Registers Destroyed:
424A                             ;    A,HL
424A                             ; *****************************************************************************
424A                TESTGETCHARIMPL:      
424A   E5                     PUSH   hl   ; Save HL register
424B   2A 3B 41               LD   hl,(tbPtr)   ; Load the current pointer from tbPtr
424E   7E                     LD   a,(hl)   ; Load the next character from the test text
424F   23                     INC   hl   ; Move to the next character
4250   22 3B 41               LD   (tbPtr),hl   ; Update tbPtr with the new pointer
4253   E1                     POP   hl   ; Restore HL register
4254   C9                     RET      ; Return with the character in A
4255                             ; *****************************************************************************
4255                             ; Routine: printHex
4255                             ; 
4255                             ; Purpose:
4255                             ;    Displays the 16-bit value in the HL register as a hexadecimal number.
4255                             ; 
4255                             ; Inputs:
4255                             ;    HL - The 16-bit value to be displayed.
4255                             ; 
4255                             ; Outputs:
4255                             ;    None
4255                             ; 
4255                             ; Registers Destroyed:
4255                             ;    A,C
4255                             ; *****************************************************************************
4255                PRINTHEX:      
4255   C5                     PUSH   bc   ; Preserve the BC register pair
4256   7C                     LD   a,h   ; Load the high byte of HL into A
4257   CD 60 42               CALL   printHex2   ; Print the high byte as hex
425A   7D                     LD   a,l   ; Load the low byte of HL into A
425B   CD 60 42               CALL   printHex2   ; Print the low byte as hex
425E   C1                     POP   bc   ; Restore the BC register pair
425F   C9                     RET      ; Return from the routine
4260                             ; *****************************************************************************
4260                             ; Routine: printHex2
4260                             ; 
4260                             ; Purpose:
4260                             ;    Prints a single byte in hexadecimal format by printing its high and low nibbles.
4260                             ; 
4260                             ; Inputs:
4260                             ;    A - The byte to be printed.
4260                             ; 
4260                             ; Outputs:
4260                             ;    None.
4260                             ; 
4260                             ; Registers Destroyed:
4260                             ;    A,C
4260                             ; *****************************************************************************
4260                PRINTHEX2:      
4260   4F                     LD   c,a   ; Copy the value in A to C
4261   1F                     RRA      ; Shift the high nibble to the low nibble
4262   1F                     RRA      
4263   1F                     RRA      
4264   1F                     RRA      
4265   CD 69 42               CALL   printHex3   ; Print the high nibble as hex
4268   79                     LD   a,c   ; Restore the original value to A
4269                PRINTHEX3:      
4269   E6 0F                  AND   0x0F   ; Mask out the upper nibble
426B   C6 90                  ADD   a,0x90   ; Add 0x90 to adjust for the ASCII range
426D   27                     DAA      ; Decimal adjust A to get the correct ASCII value
426E   CE 40                  ADC   a,0x40   ; Add 0x40 to get the ASCII character for 0-9/A-F
4270   27                     DAA      ; Decimal adjust A to get the correct ASCII value
4271   C3 87 00               JP   putchar   ; Jump to the putchar routine to display the character
4274                             ; 
4274                             ; *****************************************************************************
4274                             ; Routine: skipZStr
4274                             ; 
4274                             ; Purpose:
4274                             ;    Skips over a null-terminated string in memory,advancing the HL register
4274                             ;    to the character following the null terminator.
4274                             ; 
4274                             ; Inputs:
4274                             ;    HL - Points to the start of the string to skip.
4274                             ; 
4274                             ; Outputs:
4274                             ;    HL - Points to the character immediately after the null terminator.
4274                             ; 
4274                             ; Registers Destroyed:
4274                             ;    A
4274                             ; *****************************************************************************
4274                SKIPZSTR:      
4274   18 01                  JR   skipZStr2   ; Jump to the character loading step
4276                SKIPZSTR1:      
4276   23                     INC   hl   ; Move to the next character
4277                SKIPZSTR2:      
4277   7E                     LD   a,(hl)   ; Load the current character
4278   B7                     OR   a   ; Check if the character is null
4279   20 FB                  JR   nz,skipZStr1   ; If not null,continue to the next character
427B   C9                     RET      ; Return when a null character is found
427C                             ; call test
427C                             ; ; .db "label1: LD A,42;comment\r\n"
427C                             ; ; .db "halt"
427C                             ; .db 0


ROMSTART:           0000 DEFINED AT LINE 1 IN constants.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 116 IN IOSerial.asm
                    > USED AT LINE 122 IN IOSerial.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 134 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 146 IN IOSerial.asm
                    > USED AT LINE 152 IN IOSerial.asm
                    > USED AT LINE 158 IN IOSerial.asm
                    > USED AT LINE 200 IN IOSerial.asm
                    > USED AT LINE 17 IN MAIN.asm
RAMSTART:           3000 DEFINED AT LINE 2 IN constants.asm
                    > USED AT LINE 1 IN ram.asm
ROMSIZE:            3000 DEFINED AT LINE 3 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 4 IN constants.asm
EOF:                00-1 DEFINED AT LINE 6 IN constants.asm
                    > USED AT LINE 505 IN MAIN.asm
                    > USED AT LINE 1117 IN MAIN.asm
                    > USED AT LINE 1125 IN MAIN.asm
                    > USED AT LINE 1158 IN MAIN.asm
NULL:               0000 DEFINED AT LINE 7 IN constants.asm
                    > USED AT LINE 434 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 8 IN constants.asm
                    > USED AT LINE 1121 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 9 IN constants.asm
ESC:                001B DEFINED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 1138 IN MAIN.asm
NO_MATCH:           00-1 DEFINED AT LINE 11 IN constants.asm
BUFFER_SIZE:        0080 DEFINED AT LINE 13 IN constants.asm
                    > USED AT LINE 1098 IN MAIN.asm
                    > USED AT LINE 1113 IN MAIN.asm
                    > USED AT LINE 1131 IN MAIN.asm
                    > USED AT LINE 5 IN ram.asm
HEAP_SIZE:          0100 DEFINED AT LINE 14 IN constants.asm
                    > USED AT LINE 39 IN ram.asm
TOKENS:             0000 DEFINED AT LINE 16 IN constants.asm
COLON_:             000: DEFINED AT LINE 18 IN constants.asm
COMMA_:             000, DEFINED AT LINE 19 IN constants.asm
                    > USED AT LINE 206 IN MAIN.asm
                    > USED AT LINE 424 IN MAIN.asm
DOLLAR_:            000$ DEFINED AT LINE 20 IN constants.asm
                    > USED AT LINE 583 IN MAIN.asm
LPAREN_:            000( DEFINED AT LINE 21 IN constants.asm
                    > USED AT LINE 255 IN MAIN.asm
MINUS_:             000- DEFINED AT LINE 22 IN constants.asm
NEWLN_:             000
 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 124 IN MAIN.asm
                    > USED AT LINE 518 IN MAIN.asm
                    > USED AT LINE 880 IN MAIN.asm
PLUS_:              000+ DEFINED AT LINE 24 IN constants.asm
RPAREN_:            000) DEFINED AT LINE 25 IN constants.asm
                    > USED AT LINE 280 IN MAIN.asm
                    > USED AT LINE 421 IN MAIN.asm
EOF_:               0000 DEFINED AT LINE 26 IN constants.asm
                    > USED AT LINE 122 IN MAIN.asm
                    > USED AT LINE 507 IN MAIN.asm
                    > USED AT LINE 878 IN MAIN.asm
DIRECT_:            0001 DEFINED AT LINE 27 IN constants.asm
                    > USED AT LINE 171 IN MAIN.asm
                    > USED AT LINE 567 IN MAIN.asm
IDENT_:             0002 DEFINED AT LINE 28 IN constants.asm
                    > USED AT LINE 571 IN MAIN.asm
LABEL_:             0003 DEFINED AT LINE 29 IN constants.asm
                    > USED AT LINE 160 IN MAIN.asm
                    > USED AT LINE 542 IN MAIN.asm
NUM_:               0004 DEFINED AT LINE 30 IN constants.asm
                    > USED AT LINE 590 IN MAIN.asm
                    > USED AT LINE 600 IN MAIN.asm
OPCODE_:            0005 DEFINED AT LINE 31 IN constants.asm
                    > USED AT LINE 168 IN MAIN.asm
                    > USED AT LINE 552 IN MAIN.asm
OPELEM_:            0006 DEFINED AT LINE 32 IN constants.asm
                    > USED AT LINE 252 IN MAIN.asm
                    > USED AT LINE 266 IN MAIN.asm
                    > USED AT LINE 558 IN MAIN.asm
UNKNOWN_:           0064 DEFINED AT LINE 33 IN constants.asm
                    > USED AT LINE 614 IN MAIN.asm
ALU_:               0000 DEFINED AT LINE 35 IN constants.asm
                    > USED AT LINE 43 IN constants.asm
                    > USED AT LINE 44 IN constants.asm
                    > USED AT LINE 45 IN constants.asm
                    > USED AT LINE 46 IN constants.asm
                    > USED AT LINE 47 IN constants.asm
                    > USED AT LINE 48 IN constants.asm
                    > USED AT LINE 49 IN constants.asm
                    > USED AT LINE 50 IN constants.asm
ROT_:               0020 DEFINED AT LINE 36 IN constants.asm
                    > USED AT LINE 54 IN constants.asm
                    > USED AT LINE 55 IN constants.asm
                    > USED AT LINE 56 IN constants.asm
                    > USED AT LINE 57 IN constants.asm
                    > USED AT LINE 58 IN constants.asm
                    > USED AT LINE 59 IN constants.asm
                    > USED AT LINE 60 IN constants.asm
                    > USED AT LINE 61 IN constants.asm
BLI_:               0040 DEFINED AT LINE 37 IN constants.asm
                    > USED AT LINE 65 IN constants.asm
                    > USED AT LINE 66 IN constants.asm
                    > USED AT LINE 67 IN constants.asm
                    > USED AT LINE 68 IN constants.asm
                    > USED AT LINE 69 IN constants.asm
                    > USED AT LINE 70 IN constants.asm
                    > USED AT LINE 71 IN constants.asm
                    > USED AT LINE 72 IN constants.asm
                    > USED AT LINE 73 IN constants.asm
                    > USED AT LINE 74 IN constants.asm
                    > USED AT LINE 75 IN constants.asm
                    > USED AT LINE 76 IN constants.asm
                    > USED AT LINE 77 IN constants.asm
                    > USED AT LINE 78 IN constants.asm
                    > USED AT LINE 79 IN constants.asm
                    > USED AT LINE 80 IN constants.asm
GEN1_:              0060 DEFINED AT LINE 38 IN constants.asm
                    > USED AT LINE 84 IN constants.asm
                    > USED AT LINE 85 IN constants.asm
                    > USED AT LINE 86 IN constants.asm
                    > USED AT LINE 87 IN constants.asm
                    > USED AT LINE 88 IN constants.asm
                    > USED AT LINE 89 IN constants.asm
                    > USED AT LINE 90 IN constants.asm
                    > USED AT LINE 91 IN constants.asm
                    > USED AT LINE 93 IN constants.asm
GEN2_:              0080 DEFINED AT LINE 39 IN constants.asm
                    > USED AT LINE 92 IN constants.asm
                    > USED AT LINE 97 IN constants.asm
                    > USED AT LINE 98 IN constants.asm
                    > USED AT LINE 99 IN constants.asm
                    > USED AT LINE 100 IN constants.asm
                    > USED AT LINE 101 IN constants.asm
                    > USED AT LINE 102 IN constants.asm
                    > USED AT LINE 103 IN constants.asm
                    > USED AT LINE 104 IN constants.asm
                    > USED AT LINE 105 IN constants.asm
                    > USED AT LINE 106 IN constants.asm
                    > USED AT LINE 107 IN constants.asm
                    > USED AT LINE 108 IN constants.asm
                    > USED AT LINE 109 IN constants.asm
                    > USED AT LINE 110 IN constants.asm
                    > USED AT LINE 111 IN constants.asm
                    > USED AT LINE 112 IN constants.asm
                    > USED AT LINE 113 IN constants.asm
                    > USED AT LINE 114 IN constants.asm
                    > USED AT LINE 115 IN constants.asm
                    > USED AT LINE 116 IN constants.asm
                    > USED AT LINE 117 IN constants.asm
                    > USED AT LINE 118 IN constants.asm
                    > USED AT LINE 119 IN constants.asm
                    > USED AT LINE 120 IN constants.asm
                    > USED AT LINE 121 IN constants.asm
                    > USED AT LINE 122 IN constants.asm
ALU_IDX:            0000 DEFINED AT LINE 41 IN constants.asm
ADD_:               0000 DEFINED AT LINE 43 IN constants.asm
ADC_:               0001 DEFINED AT LINE 44 IN constants.asm
SUB_:               0002 DEFINED AT LINE 45 IN constants.asm
SBC_:               0003 DEFINED AT LINE 46 IN constants.asm
AND_:               0004 DEFINED AT LINE 47 IN constants.asm
XOR_:               0005 DEFINED AT LINE 48 IN constants.asm
OR_:                0006 DEFINED AT LINE 49 IN constants.asm
CP_:                0007 DEFINED AT LINE 50 IN constants.asm
ROT_IDX:            0000 DEFINED AT LINE 52 IN constants.asm
RLC_:               0020 DEFINED AT LINE 54 IN constants.asm
RRC_:               0021 DEFINED AT LINE 55 IN constants.asm
RL_:                0022 DEFINED AT LINE 56 IN constants.asm
RR_:                0023 DEFINED AT LINE 57 IN constants.asm
SLA_:               0024 DEFINED AT LINE 58 IN constants.asm
SRA_:               0025 DEFINED AT LINE 59 IN constants.asm
SLL_:               0026 DEFINED AT LINE 60 IN constants.asm
SRL_:               0027 DEFINED AT LINE 61 IN constants.asm
BLI_IDX:            0000 DEFINED AT LINE 63 IN constants.asm
LDI_:               0040 DEFINED AT LINE 65 IN constants.asm
CPI_:               0041 DEFINED AT LINE 66 IN constants.asm
INI_:               0042 DEFINED AT LINE 67 IN constants.asm
OUTI_:              0043 DEFINED AT LINE 68 IN constants.asm
LDD_:               0044 DEFINED AT LINE 69 IN constants.asm
CPD_:               0045 DEFINED AT LINE 70 IN constants.asm
IND_:               0046 DEFINED AT LINE 71 IN constants.asm
OUTD_:              0047 DEFINED AT LINE 72 IN constants.asm
LDIR_:              0048 DEFINED AT LINE 73 IN constants.asm
CPIR_:              0049 DEFINED AT LINE 74 IN constants.asm
INIR_:              004A DEFINED AT LINE 75 IN constants.asm
OTIR_:              004B DEFINED AT LINE 76 IN constants.asm
LDDR_:              004C DEFINED AT LINE 77 IN constants.asm
CPDR_:              004D DEFINED AT LINE 78 IN constants.asm
INDR_:              004E DEFINED AT LINE 79 IN constants.asm
OTDR_:              004F DEFINED AT LINE 80 IN constants.asm
GEN1_IDX:           0000 DEFINED AT LINE 82 IN constants.asm
CCF_:               0060 DEFINED AT LINE 84 IN constants.asm
CPL_:               0061 DEFINED AT LINE 85 IN constants.asm
DAA_:               0062 DEFINED AT LINE 86 IN constants.asm
DI_:                0063 DEFINED AT LINE 87 IN constants.asm
EI_:                0064 DEFINED AT LINE 88 IN constants.asm
HALT_:              0065 DEFINED AT LINE 89 IN constants.asm
                    > USED AT LINE 76
NOP_:               0066 DEFINED AT LINE 90 IN constants.asm
RLCA_:              0067 DEFINED AT LINE 91 IN constants.asm
RST_:               0088 DEFINED AT LINE 92 IN constants.asm
SCF_:               0069 DEFINED AT LINE 93 IN constants.asm
GEN2_IDX:           0000 DEFINED AT LINE 95 IN constants.asm
BIT_:               0080 DEFINED AT LINE 97 IN constants.asm
CALL_:              0081 DEFINED AT LINE 98 IN constants.asm
DEC_:               0082 DEFINED AT LINE 99 IN constants.asm
DJNZ_:              0083 DEFINED AT LINE 100 IN constants.asm
EX_:                0084 DEFINED AT LINE 101 IN constants.asm
EXX_:               0085 DEFINED AT LINE 102 IN constants.asm
IM_:                0086 DEFINED AT LINE 103 IN constants.asm
IN_:                0087 DEFINED AT LINE 104 IN constants.asm
INC_:               0088 DEFINED AT LINE 105 IN constants.asm
JP_:                0089 DEFINED AT LINE 106 IN constants.asm
                    > USED AT LINE 51
                    > USED AT LINE 64
JR_:                008A DEFINED AT LINE 107 IN constants.asm
LD_:                008B DEFINED AT LINE 108 IN constants.asm
                    > USED AT LINE 39
NEG_:               008C DEFINED AT LINE 109 IN constants.asm
OUT_:               008D DEFINED AT LINE 110 IN constants.asm
POP_:               008E DEFINED AT LINE 111 IN constants.asm
PUSH_:              008F DEFINED AT LINE 112 IN constants.asm
RES_:               0090 DEFINED AT LINE 113 IN constants.asm
RET_:               0091 DEFINED AT LINE 114 IN constants.asm
RETI_:              0092 DEFINED AT LINE 115 IN constants.asm
RETN_:              0093 DEFINED AT LINE 116 IN constants.asm
RLA_:               0094 DEFINED AT LINE 117 IN constants.asm
RLD_:               0095 DEFINED AT LINE 118 IN constants.asm
RRA_:               0096 DEFINED AT LINE 119 IN constants.asm
RRCA_:              0097 DEFINED AT LINE 120 IN constants.asm
RRD_:               0098 DEFINED AT LINE 121 IN constants.asm
SET_:               0003 DEFINED AT LINE 172 IN constants.asm
REG_:               0000 DEFINED AT LINE 124 IN constants.asm
                    > USED AT LINE 333 IN MAIN.asm
                    > USED AT LINE 351 IN MAIN.asm
                    > USED AT LINE 355 IN MAIN.asm
                    > USED AT LINE 756 IN MAIN.asm
                    > USED AT LINE 39
RP_:                0001 DEFINED AT LINE 125 IN constants.asm
                    > USED AT LINE 310 IN MAIN.asm
                    > USED AT LINE 342 IN MAIN.asm
                    > USED AT LINE 764 IN MAIN.asm
FLAG_:              0002 DEFINED AT LINE 126 IN constants.asm
                    > USED AT LINE 331 IN MAIN.asm
                    > USED AT LINE 771 IN MAIN.asm
                    > USED AT LINE 51
IMMED_:             0003 DEFINED AT LINE 127 IN constants.asm
                    > USED AT LINE 261 IN MAIN.asm
                    > USED AT LINE 275 IN MAIN.asm
MEM_:               0004 DEFINED AT LINE 129 IN constants.asm
                    > USED AT LINE 275 IN MAIN.asm
                    > USED AT LINE 342 IN MAIN.asm
                    > USED AT LINE 351 IN MAIN.asm
                    > USED AT LINE 355 IN MAIN.asm
INDEX_:             0008 DEFINED AT LINE 130 IN constants.asm
                    > USED AT LINE 310 IN MAIN.asm
                    > USED AT LINE 355 IN MAIN.asm
REG8_IDX:           0000 DEFINED AT LINE 132 IN constants.asm
B_:                 0000 DEFINED AT LINE 134 IN constants.asm
C_:                 0003 DEFINED AT LINE 161 IN constants.asm
                    > USED AT LINE 347 IN MAIN.asm
D_:                 0002 DEFINED AT LINE 136 IN constants.asm
E_:                 0003 DEFINED AT LINE 137 IN constants.asm
H_:                 0004 DEFINED AT LINE 138 IN constants.asm
L_:                 0005 DEFINED AT LINE 139 IN constants.asm
MHL_:               0006 DEFINED AT LINE 140 IN constants.asm
A_:                 0007 DEFINED AT LINE 141 IN constants.asm
I_:                 0008 DEFINED AT LINE 142 IN constants.asm
R_:                 0009 DEFINED AT LINE 143 IN constants.asm
REG16_IDX:          0000 DEFINED AT LINE 145 IN constants.asm
BC_:                0000 DEFINED AT LINE 147 IN constants.asm
DE_:                0001 DEFINED AT LINE 148 IN constants.asm
HL_:                0002 DEFINED AT LINE 149 IN constants.asm
                    > USED AT LINE 336 IN MAIN.asm
SP_:                0003 DEFINED AT LINE 150 IN constants.asm
IX_:                0004 DEFINED AT LINE 151 IN constants.asm
                    > USED AT LINE 304 IN MAIN.asm
                    > USED AT LINE 338 IN MAIN.asm
IY_:                0005 DEFINED AT LINE 152 IN constants.asm
                    > USED AT LINE 306 IN MAIN.asm
                    > USED AT LINE 340 IN MAIN.asm
AFP_:               0006 DEFINED AT LINE 153 IN constants.asm
AF_:                0007 DEFINED AT LINE 154 IN constants.asm
FLAG_IDX:           0000 DEFINED AT LINE 156 IN constants.asm
NZ_:                0000 DEFINED AT LINE 158 IN constants.asm
Z_:                 0001 DEFINED AT LINE 159 IN constants.asm
NC_:                0002 DEFINED AT LINE 160 IN constants.asm
PO_:                0004 DEFINED AT LINE 162 IN constants.asm
PE_:                0005 DEFINED AT LINE 163 IN constants.asm
P_:                 0006 DEFINED AT LINE 164 IN constants.asm
M_:                 0007 DEFINED AT LINE 165 IN constants.asm
DIRECTIVE_IDX:      0000 DEFINED AT LINE 167 IN constants.asm
ALIGN_:             0000 DEFINED AT LINE 169 IN constants.asm
DB_:                0001 DEFINED AT LINE 170 IN constants.asm
ORG_:               0002 DEFINED AT LINE 171 IN constants.asm
TEC_1:              0001 DEFINED AT LINE 176 IN constants.asm
RC2014:             0000 DEFINED AT LINE 177 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 179 IN constants.asm
LOADER:             0000 DEFINED AT LINE 181 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 182 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 33 IN IOSerial.asm
                    > USED AT LINE 478 IN IOSerial.asm
                    > USED AT LINE 500 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 34 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 322 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 36 IN IOSerial.asm
                    > USED AT LINE 326 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 477 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 46 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 50 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 51 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 52 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 53 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 54 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 55 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 56 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 57 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 61 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 62 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 63 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 64 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 68 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 72 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 73 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 74 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 75 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 76 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 77 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 78 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 79 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 87 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 88 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 89 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 90 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 91 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 92 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 93 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 94 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 108 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 109 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 113 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 163 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 483 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 187 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 193 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 196 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 471 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 305 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 308 IN IOSerial.asm
                    > USED AT LINE 312 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 320 IN IOSerial.asm
                    > USED AT LINE 469 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 321 IN IOSerial.asm
                    > USED AT LINE 325 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 445 IN IOSerial.asm
                    > USED AT LINE 1116 IN MAIN.asm
PUTCHAR:            0087 DEFINED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 1142 IN MAIN.asm
                    > USED AT LINE 1304 IN MAIN.asm
                    > USED AT LINE 1329 IN MAIN.asm
                    > USED AT LINE 276 IN test.lib.asm
RESET:              008D DEFINED AT LINE 457 IN IOSerial.asm
                    > USED AT LINE 114 IN IOSerial.asm
START:              0180 DEFINED AT LINE 36 IN MAIN.asm
INIT:               0198 DEFINED AT LINE 59 IN MAIN.asm
                    > USED AT LINE 38 IN MAIN.asm
                    > USED AT LINE 58 IN test.lib.asm
PARSE:              01BD DEFINED AT LINE 92 IN MAIN.asm
                    > USED AT LINE 41 IN MAIN.asm
PARSEERROR:         01E4 DEFINED AT LINE 98 IN MAIN.asm
                    > USED AT LINE 125 IN MAIN.asm
                    > USED AT LINE 211 IN MAIN.asm
                    > USED AT LINE 217 IN MAIN.asm
                    > USED AT LINE 281 IN MAIN.asm
                    > USED AT LINE 332 IN MAIN.asm
                    > USED AT LINE 348 IN MAIN.asm
STATEMENTLIST:      01F7 DEFINED AT LINE 119 IN MAIN.asm
                    > USED AT LINE 93 IN MAIN.asm
                    > USED AT LINE 126 IN MAIN.asm
                    > USED AT LINE 61 IN test.lib.asm
STATEMENT:          0206 DEFINED AT LINE 145 IN MAIN.asm
                    > USED AT LINE 121 IN MAIN.asm
STATEMENT1:         022F DEFINED AT LINE 167 IN MAIN.asm
                    > USED AT LINE 161 IN MAIN.asm
INSTRUCTION:        0238 DEFINED AT LINE 196 IN MAIN.asm
                    > USED AT LINE 169 IN MAIN.asm
INSTRUCTION1:       0268 DEFINED AT LINE 220 IN MAIN.asm
                    > USED AT LINE 207 IN MAIN.asm
DIRECTIVE:          0276 DEFINED AT LINE 229 IN MAIN.asm
                    > USED AT LINE 172 IN MAIN.asm
OPERAND:            0277 DEFINED AT LINE 251 IN MAIN.asm
                    > USED AT LINE 203 IN MAIN.asm
                    > USED AT LINE 213 IN MAIN.asm
OPERAND1:           028A DEFINED AT LINE 264 IN MAIN.asm
                    > USED AT LINE 256 IN MAIN.asm
OPERAND2:           0296 DEFINED AT LINE 271 IN MAIN.asm
                    > USED AT LINE 267 IN MAIN.asm
OPERAND7:           02A0 DEFINED AT LINE 277 IN MAIN.asm
                    > USED AT LINE 269 IN MAIN.asm
OPELEMENT:          02AB DEFINED AT LINE 302 IN MAIN.asm
                    > USED AT LINE 253 IN MAIN.asm
OPELEMENT2:         02B3 DEFINED AT LINE 309 IN MAIN.asm
                    > USED AT LINE 305 IN MAIN.asm
REGPAIRINDIRECT:    02B6 DEFINED AT LINE 329 IN MAIN.asm
                    > USED AT LINE 268 IN MAIN.asm
REGPAIRINDIRECT1:   02D0 DEFINED AT LINE 345 IN MAIN.asm
                    > USED AT LINE 334 IN MAIN.asm
REGPAIRINDIRECT2:   02D6 DEFINED AT LINE 350 IN MAIN.asm
                    > USED AT LINE 337 IN MAIN.asm
REGPAIRINDIRECT3:   02D9 DEFINED AT LINE 354 IN MAIN.asm
                    > USED AT LINE 339 IN MAIN.asm
                    > USED AT LINE 341 IN MAIN.asm
EXPRESSION:         02E4 DEFINED AT LINE 382 IN MAIN.asm
                    > USED AT LINE 258 IN MAIN.asm
                    > USED AT LINE 272 IN MAIN.asm
                    > USED AT LINE 357 IN MAIN.asm
EXPRESSION1:        02FF DEFINED AT LINE 394 IN MAIN.asm
                    > USED AT LINE 406 IN MAIN.asm
                    > USED AT LINE 418 IN MAIN.asm
                    > USED AT LINE 430 IN MAIN.asm
EXPRESSION2:        0317 DEFINED AT LINE 408 IN MAIN.asm
                    > USED AT LINE 403 IN MAIN.asm
EXPRESSION3:        0325 DEFINED AT LINE 420 IN MAIN.asm
                    > USED AT LINE 411 IN MAIN.asm
                    > USED AT LINE 414 IN MAIN.asm
EXPRESSION4:        0334 DEFINED AT LINE 432 IN MAIN.asm
                    > USED AT LINE 422 IN MAIN.asm
                    > USED AT LINE 425 IN MAIN.asm
                    > USED AT LINE 428 IN MAIN.asm
ADDSYMBOL:          0343 DEFINED AT LINE 459 IN MAIN.asm
                    > USED AT LINE 164 IN MAIN.asm
NEXTTOKEN:          035C DEFINED AT LINE 490 IN MAIN.asm
                    > USED AT LINE 120 IN MAIN.asm
                    > USED AT LINE 165 IN MAIN.asm
                    > USED AT LINE 199 IN MAIN.asm
                    > USED AT LINE 205 IN MAIN.asm
                    > USED AT LINE 209 IN MAIN.asm
                    > USED AT LINE 215 IN MAIN.asm
                    > USED AT LINE 265 IN MAIN.asm
                    > USED AT LINE 279 IN MAIN.asm
                    > USED AT LINE 401 IN MAIN.asm
                    > USED AT LINE 405 IN MAIN.asm
                    > USED AT LINE 417 IN MAIN.asm
NEXTTOKEN1:         036C DEFINED AT LINE 500 IN MAIN.asm
                    > USED AT LINE 494 IN MAIN.asm
                    > USED AT LINE 504 IN MAIN.asm
                    > USED AT LINE 530 IN MAIN.asm
NEXTTOKEN2:         037D DEFINED AT LINE 510 IN MAIN.asm
                    > USED AT LINE 506 IN MAIN.asm
NEXTTOKEN2A:        0389 DEFINED AT LINE 517 IN MAIN.asm
                    > USED AT LINE 512 IN MAIN.asm
                    > USED AT LINE 514 IN MAIN.asm
NEXTTOKEN3:         038C DEFINED AT LINE 521 IN MAIN.asm
                    > USED AT LINE 516 IN MAIN.asm
NEXTTOKEN4:         0390 DEFINED AT LINE 525 IN MAIN.asm
                    > USED AT LINE 528 IN MAIN.asm
NEXTTOKEN5:         039C DEFINED AT LINE 532 IN MAIN.asm
                    > USED AT LINE 523 IN MAIN.asm
NEXTTOKEN6:         03A5 DEFINED AT LINE 538 IN MAIN.asm
                    > USED AT LINE 534 IN MAIN.asm
NEXTTOKEN7:         03AF DEFINED AT LINE 545 IN MAIN.asm
                    > USED AT LINE 541 IN MAIN.asm
NEXTTOKEN8:         03C0 DEFINED AT LINE 555 IN MAIN.asm
                    > USED AT LINE 549 IN MAIN.asm
NEXTTOKEN9:         03C8 DEFINED AT LINE 561 IN MAIN.asm
                    > USED AT LINE 557 IN MAIN.asm
NEXTTOKEN10:        03D6 DEFINED AT LINE 570 IN MAIN.asm
                    > USED AT LINE 564 IN MAIN.asm
NEXTTOKEN11:        03D9 DEFINED AT LINE 574 IN MAIN.asm
                    > USED AT LINE 536 IN MAIN.asm
NEXTTOKEN12:        03EE DEFINED AT LINE 586 IN MAIN.asm
                    > USED AT LINE 580 IN MAIN.asm
NEXTTOKEN13:        03FA DEFINED AT LINE 593 IN MAIN.asm
                    > USED AT LINE 577 IN MAIN.asm
NEXTTOKEN14:        040B DEFINED AT LINE 603 IN MAIN.asm
                    > USED AT LINE 595 IN MAIN.asm
PUSHBACKTOKEN:      041D DEFINED AT LINE 635 IN MAIN.asm
                    > USED AT LINE 437 IN MAIN.asm
IDENT:              0426 DEFINED AT LINE 663 IN MAIN.asm
                    > USED AT LINE 539 IN MAIN.asm
IDENT1:             042B DEFINED AT LINE 667 IN MAIN.asm
                    > USED AT LINE 674 IN MAIN.asm
                    > USED AT LINE 676 IN MAIN.asm
IDENT3:             043B DEFINED AT LINE 677 IN MAIN.asm
SEARCHOPCODE:       0446 DEFINED AT LINE 705 IN MAIN.asm
                    > USED AT LINE 548 IN MAIN.asm
SEARCHOPELEM:       0473 DEFINED AT LINE 751 IN MAIN.asm
                    > USED AT LINE 556 IN MAIN.asm
SEARCHOPELEM1:      047F DEFINED AT LINE 759 IN MAIN.asm
                    > USED AT LINE 754 IN MAIN.asm
SEARCHOPELEM2:      048B DEFINED AT LINE 767 IN MAIN.asm
                    > USED AT LINE 762 IN MAIN.asm
SEARCHSTR:          0495 DEFINED AT LINE 794 IN MAIN.asm
                    > USED AT LINE 563 IN MAIN.asm
                    > USED AT LINE 707 IN MAIN.asm
                    > USED AT LINE 711 IN MAIN.asm
                    > USED AT LINE 716 IN MAIN.asm
                    > USED AT LINE 721 IN MAIN.asm
                    > USED AT LINE 727 IN MAIN.asm
                    > USED AT LINE 753 IN MAIN.asm
                    > USED AT LINE 761 IN MAIN.asm
                    > USED AT LINE 769 IN MAIN.asm
SEARCHSTR1:         0497 DEFINED AT LINE 797 IN MAIN.asm
                    > USED AT LINE 816 IN MAIN.asm
SEARCHSTR3:         049E DEFINED AT LINE 803 IN MAIN.asm
                    > USED AT LINE 799 IN MAIN.asm
COMPARESTR:         04AD DEFINED AT LINE 839 IN MAIN.asm
                    > USED AT LINE 798 IN MAIN.asm
                    > USED AT LINE 83 IN test.lib.asm
COMPARESTR2:        04B3 DEFINED AT LINE 847 IN MAIN.asm
                    > USED AT LINE 853 IN MAIN.asm
COMPARESTR3:        04BB DEFINED AT LINE 855 IN MAIN.asm
                    > USED AT LINE 850 IN MAIN.asm
ISENDOFLINE:        04BF DEFINED AT LINE 877 IN MAIN.asm
                    > USED AT LINE 146 IN MAIN.asm
                    > USED AT LINE 200 IN MAIN.asm
                    > USED AT LINE 210 IN MAIN.asm
                    > USED AT LINE 216 IN MAIN.asm
                    > USED AT LINE 427 IN MAIN.asm
ISALPHANUM:         04C5 DEFINED AT LINE 925 IN MAIN.asm
                    > USED AT LINE 579 IN MAIN.asm
                    > USED AT LINE 675 IN MAIN.asm
ISALPHA:            04C9 DEFINED AT LINE 949 IN MAIN.asm
                    > USED AT LINE 535 IN MAIN.asm
ISALPHA1:           04D4 DEFINED AT LINE 957 IN MAIN.asm
                    > USED AT LINE 953 IN MAIN.asm
ISDIGIT:            04DB DEFINED AT LINE 981 IN MAIN.asm
                    > USED AT LINE 594 IN MAIN.asm
                    > USED AT LINE 926 IN MAIN.asm
DECIMAL:            04E2 DEFINED AT LINE 1004 IN MAIN.asm
                    > USED AT LINE 598 IN MAIN.asm
DECIMAL1:           04E5 DEFINED AT LINE 1006 IN MAIN.asm
                    > USED AT LINE 1027 IN MAIN.asm
HEXADECIMAL:        0501 DEFINED AT LINE 1045 IN MAIN.asm
                    > USED AT LINE 588 IN MAIN.asm
HEXADECIMAL1:       0504 DEFINED AT LINE 1047 IN MAIN.asm
                    > USED AT LINE 1076 IN MAIN.asm
HEXADECIMAL2:       0516 DEFINED AT LINE 1058 IN MAIN.asm
                    > USED AT LINE 1056 IN MAIN.asm
HEXADECIMAL3:       051D DEFINED AT LINE 1063 IN MAIN.asm
                    > USED AT LINE 1062 IN MAIN.asm
HEXADECIMAL4:       051F DEFINED AT LINE 1065 IN MAIN.asm
                    > USED AT LINE 1054 IN MAIN.asm
NEXTCHAR:           052E DEFINED AT LINE 1095 IN MAIN.asm
                    > USED AT LINE 501 IN MAIN.asm
                    > USED AT LINE 526 IN MAIN.asm
                    > USED AT LINE 578 IN MAIN.asm
                    > USED AT LINE 671 IN MAIN.asm
                    > USED AT LINE 1009 IN MAIN.asm
                    > USED AT LINE 1049 IN MAIN.asm
                    > USED AT LINE 1167 IN MAIN.asm
NEXTLINE:           0545 DEFINED AT LINE 1111 IN MAIN.asm
                    > USED AT LINE 1099 IN MAIN.asm
NEXTLINE1:          054A DEFINED AT LINE 1115 IN MAIN.asm
                    > USED AT LINE 1133 IN MAIN.asm
                    > USED AT LINE 1139 IN MAIN.asm
                    > USED AT LINE 1162 IN MAIN.asm
NEXTLINE2:          0558 DEFINED AT LINE 1124 IN MAIN.asm
                    > USED AT LINE 1120 IN MAIN.asm
NEXTLINE3:          055C DEFINED AT LINE 1128 IN MAIN.asm
                    > USED AT LINE 1122 IN MAIN.asm
NEXTLINE4:          0570 DEFINED AT LINE 1141 IN MAIN.asm
                    > USED AT LINE 1130 IN MAIN.asm
NEXTLINE5:          057B DEFINED AT LINE 1149 IN MAIN.asm
                    > USED AT LINE 1145 IN MAIN.asm
NEXTLINE6:          0583 DEFINED AT LINE 1155 IN MAIN.asm
                    > USED AT LINE 1118 IN MAIN.asm
                    > USED AT LINE 1126 IN MAIN.asm
                    > USED AT LINE 1147 IN MAIN.asm
                    > USED AT LINE 1151 IN MAIN.asm
                    > USED AT LINE 1153 IN MAIN.asm
NEXTLINE7:          058F DEFINED AT LINE 1164 IN MAIN.asm
                    > USED AT LINE 1159 IN MAIN.asm
                    > USED AT LINE 1161 IN MAIN.asm
REWINDCHAR:         0596 DEFINED AT LINE 1186 IN MAIN.asm
                    > USED AT LINE 529 IN MAIN.asm
                    > USED AT LINE 546 IN MAIN.asm
                    > USED AT LINE 582 IN MAIN.asm
                    > USED AT LINE 587 IN MAIN.asm
                    > USED AT LINE 589 IN MAIN.asm
                    > USED AT LINE 597 IN MAIN.asm
                    > USED AT LINE 599 IN MAIN.asm
PROMPT:             05A0 DEFINED AT LINE 1210 IN MAIN.asm
CRLF:               05A9 DEFINED AT LINE 1231 IN MAIN.asm
                    > USED AT LINE 113 IN test.lib.asm
                    > USED AT LINE 173 IN test.lib.asm
                    > USED AT LINE 176 IN test.lib.asm
                    > USED AT LINE 179 IN test.lib.asm
                    > USED AT LINE 180 IN test.lib.asm
                    > USED AT LINE 186 IN test.lib.asm
                    > USED AT LINE 192 IN test.lib.asm
ERROR:              05B0 DEFINED AT LINE 1252 IN MAIN.asm
PRINT:              05B5 DEFINED AT LINE 1273 IN MAIN.asm
                    > USED AT LINE 39 IN MAIN.asm
                    > USED AT LINE 94 IN MAIN.asm
                    > USED AT LINE 1137 IN MAIN.asm
                    > USED AT LINE 1211 IN MAIN.asm
                    > USED AT LINE 1232 IN MAIN.asm
                    > USED AT LINE 95
                    > USED AT LINE 88 IN test.lib.asm
                    > USED AT LINE 181 IN test.lib.asm
                    > USED AT LINE 187 IN test.lib.asm
PRINTSTR:           05BC DEFINED AT LINE 1296 IN MAIN.asm
                    > USED AT LINE 1254 IN MAIN.asm
PRINTSTR1:          05C1 DEFINED AT LINE 1302 IN MAIN.asm
                    > USED AT LINE 1306 IN MAIN.asm
PRINTZSTR:          05C9 DEFINED AT LINE 1325 IN MAIN.asm
                    > USED AT LINE 1275 IN MAIN.asm
                    > USED AT LINE 91 IN test.lib.asm
                    > USED AT LINE 175 IN test.lib.asm
                    > USED AT LINE 178 IN test.lib.asm
PRINTZSTR1:         05CB DEFINED AT LINE 1328 IN MAIN.asm
                    > USED AT LINE 1335 IN MAIN.asm
PRINTZSTR2:         05CF DEFINED AT LINE 1332 IN MAIN.asm
                    > USED AT LINE 1326 IN MAIN.asm
HPUSH:              05D4 DEFINED AT LINE 1354 IN MAIN.asm
                    > USED AT LINE 387 IN MAIN.asm
                    > USED AT LINE 389 IN MAIN.asm
                    > USED AT LINE 390 IN MAIN.asm
                    > USED AT LINE 398 IN MAIN.asm
                    > USED AT LINE 400 IN MAIN.asm
                    > USED AT LINE 435 IN MAIN.asm
                    > USED AT LINE 464 IN MAIN.asm
                    > USED AT LINE 467 IN MAIN.asm
                    > USED AT LINE 469 IN MAIN.asm
ROT_OPCODES:        05E2 DEFINED AT LINE 1 IN data.asm
                    > USED AT LINE 710 IN MAIN.asm
ALU_OPCODES:        0601 DEFINED AT LINE 13 IN data.asm
                    > USED AT LINE 706 IN MAIN.asm
BLI_OPCODES:        0620 DEFINED AT LINE 25 IN data.asm
                    > USED AT LINE 715 IN MAIN.asm
GEN1_OPCODES:       066B DEFINED AT LINE 45 IN data.asm
                    > USED AT LINE 720 IN MAIN.asm
GEN2_OPCODES:       0694 DEFINED AT LINE 59 IN data.asm
                    > USED AT LINE 726 IN MAIN.asm
REG8:               06FD DEFINED AT LINE 89 IN data.asm
                    > USED AT LINE 752 IN MAIN.asm
REG16:              0712 DEFINED AT LINE 103 IN data.asm
                    > USED AT LINE 760 IN MAIN.asm
FLAGS:              072C DEFINED AT LINE 115 IN data.asm
                    > USED AT LINE 768 IN MAIN.asm
DIRECTIVES:         0741 DEFINED AT LINE 127 IN data.asm
                    > USED AT LINE 562 IN MAIN.asm
BUFFER:             3000 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 68 IN MAIN.asm
                    > USED AT LINE 1100 IN MAIN.asm
                    > USED AT LINE 1112 IN MAIN.asm
STACK:              3180 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 458 IN IOSerial.asm
                    > USED AT LINE 37 IN MAIN.asm
                    > USED AT LINE 15
VTEMP1:             3180 DEFINED AT LINE 9 IN ram.asm
VTEMP2:             3182 DEFINED AT LINE 10 IN ram.asm
VTOKEN:             3184 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 65 IN MAIN.asm
                    > USED AT LINE 491 IN MAIN.asm
                    > USED AT LINE 637 IN MAIN.asm
VTOKENVAL:          3185 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 61 IN MAIN.asm
                    > USED AT LINE 497 IN MAIN.asm
                    > USED AT LINE 638 IN MAIN.asm
VBUFFERPOS:         3187 DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 66 IN MAIN.asm
                    > USED AT LINE 1096 IN MAIN.asm
                    > USED AT LINE 1165 IN MAIN.asm
                    > USED AT LINE 1187 IN MAIN.asm
                    > USED AT LINE 1191 IN MAIN.asm
VASMPTR:            3189 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 72 IN MAIN.asm
                    > USED AT LINE 163 IN MAIN.asm
VSYMPTR:            318B DEFINED AT LINE 16 IN ram.asm
                    > USED AT LINE 62 IN MAIN.asm
                    > USED AT LINE 463 IN MAIN.asm
                    > USED AT LINE 465 IN MAIN.asm
VEXPRPTR:           318D DEFINED AT LINE 17 IN ram.asm
                    > USED AT LINE 63 IN MAIN.asm
                    > USED AT LINE 386 IN MAIN.asm
                    > USED AT LINE 391 IN MAIN.asm
                    > USED AT LINE 438 IN MAIN.asm
VHEAPPTR:           318F DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 70 IN MAIN.asm
                    > USED AT LINE 385 IN MAIN.asm
                    > USED AT LINE 462 IN MAIN.asm
                    > USED AT LINE 547 IN MAIN.asm
                    > USED AT LINE 664 IN MAIN.asm
                    > USED AT LINE 678 IN MAIN.asm
                    > USED AT LINE 1357 IN MAIN.asm
                    > USED AT LINE 1362 IN MAIN.asm
VOPCODE:            3191 DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 155 IN MAIN.asm
                    > USED AT LINE 198 IN MAIN.asm
                    > USED AT LINE 115 IN test.lib.asm
VOPERAND1:          3192 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 152 IN MAIN.asm
                    > USED AT LINE 204 IN MAIN.asm
                    > USED AT LINE 222 IN MAIN.asm
                    > USED AT LINE 225 IN MAIN.asm
VOPERAND2:          3194 DEFINED AT LINE 22 IN ram.asm
                    > USED AT LINE 153 IN MAIN.asm
                    > USED AT LINE 214 IN MAIN.asm
                    > USED AT LINE 223 IN MAIN.asm
VOPEXPR:            3196 DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 156 IN MAIN.asm
                    > USED AT LINE 259 IN MAIN.asm
                    > USED AT LINE 273 IN MAIN.asm
VOPDISP:            3198 DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 157 IN MAIN.asm
                    > USED AT LINE 358 IN MAIN.asm
RST08:              319A DEFINED AT LINE 27 IN ram.asm
                    > USED AT LINE 118 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
RST10:              319C DEFINED AT LINE 28 IN ram.asm
                    > USED AT LINE 124 IN IOSerial.asm
                    > USED AT LINE 461 IN IOSerial.asm
RST18:              319E DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 130 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RST20:              31A0 DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 136 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
RST28:              31A2 DEFINED AT LINE 31 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
RST30:              31A4 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 148 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
BAUD:               31A6 DEFINED AT LINE 33 IN ram.asm
INTVEC:             31A8 DEFINED AT LINE 34 IN ram.asm
                    > USED AT LINE 154 IN IOSerial.asm
                    > USED AT LINE 466 IN IOSerial.asm
NMIVEC:             31AA DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 202 IN IOSerial.asm
                    > USED AT LINE 467 IN IOSerial.asm
GETCVEC:            31AC DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 447 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
                    > USED AT LINE 60 IN test.lib.asm
PUTCVEC:            31AE DEFINED AT LINE 37 IN ram.asm
                    > USED AT LINE 453 IN IOSerial.asm
                    > USED AT LINE 472 IN IOSerial.asm
HEAP:               31B0 DEFINED AT LINE 39 IN ram.asm
                    > USED AT LINE 69 IN MAIN.asm
ASSEMBLY:           32B0 DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 71 IN MAIN.asm
                    > USED AT LINE 82 IN test.lib.asm
TESTSSTART:         4000 DEFINED AT LINE 14
                    > USED AT LINE 6
TBDESC:             4137 DEFINED AT LINE 5 IN test.lib.asm
                    > USED AT LINE 30 IN test.lib.asm
                    > USED AT LINE 174 IN test.lib.asm
TBTEXT:             4139 DEFINED AT LINE 7 IN test.lib.asm
                    > USED AT LINE 53 IN test.lib.asm
                    > USED AT LINE 90 IN test.lib.asm
TBPTR:              413B DEFINED AT LINE 9 IN test.lib.asm
                    > USED AT LINE 54 IN test.lib.asm
                    > USED AT LINE 213 IN test.lib.asm
                    > USED AT LINE 216 IN test.lib.asm
DESCRIBE:           413D DEFINED AT LINE 28 IN test.lib.asm
                    > USED AT LINE 31
                    > USED AT LINE 43
                    > USED AT LINE 56
                    > USED AT LINE 68
                    > USED AT LINE 80
TEST:               4146 DEFINED AT LINE 51 IN test.lib.asm
                    > USED AT LINE 34
                    > USED AT LINE 46
                    > USED AT LINE 59
                    > USED AT LINE 71
                    > USED AT LINE 83
EXPECT:             415E DEFINED AT LINE 80 IN test.lib.asm
                    > USED AT LINE 86
EXPECT1:            4168 DEFINED AT LINE 87 IN test.lib.asm
                    > USED AT LINE 84 IN test.lib.asm
EXPECTOPDATA:       417A DEFINED AT LINE 112 IN test.lib.asm
                    > USED AT LINE 38
                    > USED AT LINE 50
                    > USED AT LINE 63
                    > USED AT LINE 75
EXPECTOPITEM:       41F5 DEFINED AT LINE 153 IN test.lib.asm
                    > USED AT LINE 117 IN test.lib.asm
                    > USED AT LINE 120 IN test.lib.asm
                    > USED AT LINE 123 IN test.lib.asm
                    > USED AT LINE 126 IN test.lib.asm
                    > USED AT LINE 129 IN test.lib.asm
EXPECTOPITEM1:      41FD DEFINED AT LINE 160 IN test.lib.asm
                    > USED AT LINE 156 IN test.lib.asm
EXPECTOPITEM2:      4206 DEFINED AT LINE 169 IN test.lib.asm
                    > USED AT LINE 158 IN test.lib.asm
TESTGETCHARIMPL:    424A DEFINED AT LINE 211 IN test.lib.asm
                    > USED AT LINE 59 IN test.lib.asm
PRINTHEX:           4255 DEFINED AT LINE 236 IN test.lib.asm
PRINTHEX2:          4260 DEFINED AT LINE 261 IN test.lib.asm
                    > USED AT LINE 185 IN test.lib.asm
                    > USED AT LINE 191 IN test.lib.asm
                    > USED AT LINE 239 IN test.lib.asm
                    > USED AT LINE 241 IN test.lib.asm
PRINTHEX3:          4269 DEFINED AT LINE 270 IN test.lib.asm
                    > USED AT LINE 267 IN test.lib.asm
SKIPZSTR:           4274 DEFINED AT LINE 295 IN test.lib.asm
                    > USED AT LINE 31 IN test.lib.asm
                    > USED AT LINE 55 IN test.lib.asm
                    > USED AT LINE 164 IN test.lib.asm
SKIPZSTR1:          4276 DEFINED AT LINE 298 IN test.lib.asm
                    > USED AT LINE 304 IN test.lib.asm
SKIPZSTR2:          4277 DEFINED AT LINE 301 IN test.lib.asm
                    > USED AT LINE 296 IN test.lib.asm
