0000                          .ENGINE   mycomputer   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $3000   
0000                ROMSIZE:   EQU   $3000   
0000                RAMSIZE:   EQU   $0800   
0000                EOF:      EQU   -1   
0000                NULL:     EQU   0   
0000                CTRL_C:   EQU   3   
0000                CTRL_H:   EQU   8   
0000                ESC:      EQU   27   
0000                NO_MATCH:   EQU   -1   
0000                BUFFER_SIZE:   EQU   $80   
0000                HEAP_SIZE:   EQU   $100   
0000                TOKENS:      
0000                COLON_:   EQU   ":"   
0000                COMMA_:   EQU   ","   
0000                DOLLAR_:   EQU   "$"   
0000                LPAREN_:   EQU   "("   
0000                MINUS_:   EQU   "-"   
0000                NEWLN_:   EQU   "\n"   
0000                PLUS_:    EQU   "+"   
0000                RPAREN_:   EQU   ")"   
0000                EOF_:     EQU   0   
0000                DIRECT_:   EQU   1   
0000                IDENT_:   EQU   2   
0000                LABEL_:   EQU   3   
0000                NUM_:     EQU   4   
0000                OPCODE_:   EQU   5   
0000                OPELEM_:   EQU   6   ; op element: reg, rp, flag
0000                UNKNOWN_:   EQU   100   
0000                ALU_:     EQU   0x00   
0000                ROT_:     EQU   0x20   
0000                BLI_:     EQU   0x40   
0000                GEN1_:    EQU   0x60   
0000                GEN2_:    EQU   0x80   
0000                ALU_IDX:      
0000                ADD_:     EQU   0 | alu_   
0000                ADC_:     EQU   1 | alu_   
0000                SUB_:     EQU   2 | alu_   
0000                SBC_:     EQU   3 | alu_   
0000                AND_:     EQU   4 | alu_   
0000                XOR_:     EQU   5 | alu_   
0000                OR_:      EQU   6 | alu_   
0000                CP_:      EQU   7 | alu_   
0000                ROT_IDX:      
0000                RLC_:     EQU   0 | rot_   
0000                RRC_:     EQU   1 | rot_   
0000                RL_:      EQU   2 | rot_   
0000                RR_:      EQU   3 | rot_   
0000                SLA_:     EQU   4 | rot_   
0000                SRA_:     EQU   5 | rot_   
0000                SLL_:     EQU   6 | rot_   
0000                SRL_:     EQU   7 | rot_   
0000                BLI_IDX:      
0000                LDI_:     EQU   00 | bli_   
0000                CPI_:     EQU   01 | bli_   
0000                INI_:     EQU   02 | bli_   
0000                OUTI_:    EQU   03 | bli_   
0000                LDD_:     EQU   04 | bli_   
0000                CPD_:     EQU   05 | bli_   
0000                IND_:     EQU   06 | bli_   
0000                OUTD_:    EQU   07 | bli_   
0000                LDIR_:    EQU   08 | bli_   
0000                CPIR_:    EQU   09 | bli_   
0000                INIR_:    EQU   10 | bli_   
0000                OTIR_:    EQU   11 | bli_   
0000                LDDR_:    EQU   12 | bli_   
0000                CPDR_:    EQU   13 | bli_   
0000                INDR_:    EQU   14 | bli_   
0000                OTDR_:    EQU   15 | bli_   
0000                GEN1_IDX:      
0000                CCF_:     EQU   00 | gen1_   
0000                CPL_:     EQU   01 | gen1_   
0000                DAA_:     EQU   02 | gen1_   
0000                DI_:      EQU   03 | gen1_   
0000                EI_:      EQU   04 | gen1_   
0000                HALT_:    EQU   05 | gen1_   
0000                NOP_:     EQU   06 | gen1_   
0000                RLCA_:    EQU   07 | gen1_   
0000                RST_:     EQU   08 | gen2_   
0000                SCF_:     EQU   09 | gen1_   
0000                GEN2_IDX:      
0000                BIT_:     EQU   00 | gen2_   
0000                CALL_:    EQU   01 | gen2_   
0000                DEC_:     EQU   02 | gen2_   
0000                DJNZ_:    EQU   03 | gen2_   
0000                EX_:      EQU   04 | gen2_   
0000                EXX_:     EQU   05 | gen2_   
0000                IM_:      EQU   06 | gen2_   
0000                IN_:      EQU   07 | gen2_   
0000                INC_:     EQU   08 | gen2_   
0000                JP_:      EQU   09 | gen2_   
0000                JR_:      EQU   10 | gen2_   
0000                LD_:      EQU   11 | gen2_   
0000                NEG_:     EQU   12 | gen2_   
0000                OUT_:     EQU   13 | gen2_   
0000                POP_:     EQU   14 | gen2_   
0000                PUSH_:    EQU   15 | gen2_   
0000                RES_:     EQU   16 | gen2_   
0000                RET_:     EQU   17 | gen2_   
0000                RETI_:    EQU   18 | gen2_   
0000                RETN_:    EQU   19 | gen2_   
0000                RLA_:     EQU   20 | gen2_   
0000                RLD_:     EQU   21 | gen2_   
0000                RRA_:     EQU   22 | gen2_   
0000                RRCA_:    EQU   23 | gen2_   
0000                RRD_:     EQU   24 | gen2_   
0000                SET_:     EQU   25 | gen2_   
0000                REG_:     EQU   0x00   
0000                RP_:      EQU   0x08   
0000                FLAG_:    EQU   0x10   
0000                IMMED_:   EQU   0x18   
0000                MEM_:     EQU   0x20   
0000                INDX_:    EQU   0x80   
0000                INDY_:    EQU   0xC0   
0000                REG8_IDX:      ; 8-bit registers
0000                B_:       EQU   0   ; B
0000                C_:       EQU   1   ; C
0000                D_:       EQU   2   ; D
0000                E_:       EQU   3   ; E
0000                H_:       EQU   4   ; H
0000                L_:       EQU   5   ; L
0000                MHL_:     EQU   6   ; (HL)
0000                A_:       EQU   7   ; A
0000                I_:       EQU   8   ; I
0000                R_:       EQU   9   ; R
0000                REG16_IDX:      ; 16-bit registers
0000                BC_:      EQU   0 | rp_   
0000                DE_:      EQU   1 | rp_   
0000                HL_:      EQU   2 | rp_   
0000                SP_:      EQU   3 | rp_   
0000                IX_:      EQU   5 | rp_   
0000                IY_:      EQU   6 | rp_   
0000                AFP_:     EQU   4 | rp_   ; AF' (prime)
0000                AF_:      EQU   7 | rp_   ; NOTE: AF has the same code as SP in some instructions
0000                FLAG_IDX:      
0000                NZ_:      EQU   0 | flag_   
0000                Z_:       EQU   1 | flag_   
0000                NC_:      EQU   2 | flag_   
0000                C_:       EQU   3 | flag_   
0000                PO_:      EQU   4 | flag_   
0000                PE_:      EQU   5 | flag_   
0000                P_:       EQU   6 | flag_   
0000                M_:       EQU   7 | flag_   
0000                DIRECTIVE_IDX:      
0000                ALIGN_:   EQU   0   
0000                DB_:      EQU   1   
0000                ORG_:     EQU   2   
0000                SET_:     EQU   3   
0000                             ; -----------------------------------------------------------------------------------------------
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                             ; *************************************************************************
0000                             ; 
0000                             ;       Serial routines 
0000                             ; 
0000                             ;       written by Craig Jones 
0000                             ; 
0000                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
0000                             ; 
0000                             ;       see the LICENSE file in this repo for more information 
0000                             ; 
0000                             ; *****************************************************************************
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8D 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 98 31               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 9A 31               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 9C 31               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A 9E 31               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A A0 31               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A A2 31               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A A6 31               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A A8 31               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   E5                     PUSH   HL   
0082   2A AA 31               LD   HL,(GETCVEC)   
0085   E3                     EX   (SP),HL   
0086   C9                     RET      
0087                             ; 
0087                PUTCHAR:      
0087   E5                     PUSH   HL   
0088   2A AC 31               LD   HL,(PUTCVEC)   
008B   E3                     EX   (SP),HL   
008C   C9                     RET      
008D                             ; 
008D                RESET:       
008D   31 80 31               LD   SP,stack   
0090   21 5F 00               LD   HL,IntRet   
0093   22 98 31               LD   (RST08),HL   
0096   22 9A 31               LD   (RST10),HL   
0099   22 9C 31               LD   (RST18),HL   
009C   22 9E 31               LD   (RST20),HL   
009F   22 A0 31               LD   (RST28),HL   
00A2   22 A2 31               LD   (RST30),HL   
00A5   22 A6 31               LD   (INTVEC),HL   
00A8   22 A8 31               LD   (NMIVEC),HL   
00AB                             ; 
00AB   21 78 00               LD   HL,RXDATA   
00AE   22 AA 31               LD   (GETCVEC),HL   
00B1   21 6B 00               LD   HL,TXDATA   
00B4   22 AC 31               LD   (PUTCVEC),HL   
00B7                             ; 
00B7                          IF   TEC_1   
00B7                          IF   BITBANG = 0   
00B7                             ; 
00B7   3E 03                  LD   a,MRESET   
00B9   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00BB                             ; 
00BB                          ENDIF      
00BB                          ENDIF      
00BB                             ; 
00BB   CD 50 00               CALL   PWRUP   
00BE   ED 56                  IM   1   
00C0   FB                     EI      
00C1                             ; 
00C1                          IF   TEC_1   
00C1                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00C1                          ELSE      ;6850      
00C1                             ; 
00C1   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C3   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C5                             ; 
00C5                          ENDIF      
00C5                          ENDIF      
00C5                             ; 
00C5                             ; 
00C5   C3 00 40               JP   testsStart   
00C8                             ; *************************************************************************
00C8                             ; 
00C8                             ;       TecM8 1.0 Assembler for the Tec-1
00C8                             ; 
00C8                             ;       by John Hardy
00C8                             ; 
00C8                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3,29 June 2007
00C8                             ; 
00C8                             ;       see the LICENSE file in this repo for more information
00C8                             ; 
00C8                             ; *****************************************************************************
00C8                             ; **************************************************************************
00C8                             ; Page 0  Initialisation
00C8                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put TecM8 code from here	
0180                             ; *****************************************************************************
0180                             ; Routine: start
0180                             ; 
0180                             ; Purpose:
0180                             ;    Entry point of TecM8. Initializes the STACK pointer,calls the initialization
0180                             ;    routine,prints TecM8 version information,and jumps to the parsing routine.
0180                             ; 
0180                             ; Inputs:
0180                             ;    None
0180                             ; 
0180                             ; Outputs:
0180                             ;    None
0180                             ; 
0180                             ; Registers Destroyed:
0180                             ;    A,HL
0180                             ; *****************************************************************************
0180                START:       
0180   31 80 31               LD   sp,STACK   ; Initialize STACK pointer
0183   CD 98 01               CALL   init   ; Call initialization routine
0186   CD A4 05               CALL   print   ; Print TecM8 version information
0189   54 65 63 4D 38 20 30 2E 30 0D 0A 00 .CSTR   "TecM8 0.0\r\n"   
0195   C3 BD 01               JP   parse   ; Jump to the parsing routine
0198                             ; *****************************************************************************
0198                             ; Routine: init
0198                             ; 
0198                             ; Purpose:
0198                             ;    Initializes various pointers and variables used by TecM8.
0198                             ; 
0198                             ; Inputs:
0198                             ;    None
0198                             ; 
0198                             ; Outputs:
0198                             ;    None
0198                             ; 
0198                             ; Registers Destroyed:
0198                             ;    A,HL
0198                             ; *****************************************************************************
0198                INIT:        
0198   21 00 00               LD   hl,0   
019B   22 85 31               LD   (vTokenVal),hl   ; vTokenVal = 0
019E   22 8B 31               LD   (vSymPtr),hl   ; vSymPtr = 0
01A1   22 8D 31               LD   (vExprPtr),hl   ; vExprPtr = 0
01A4   AF                     XOR   a   
01A5   32 84 31               LD   (vToken),a   ; vToken = 0
01A8   32 87 31               LD   (vBufferPos),a   ; vBufferPos = 0
01AB   3E 0A                  LD   a,"\n"   ; put new line into first char of buffer
01AD   32 00 30               LD   (BUFFER),a   
01B0   21 AE 31               LD   hl,HEAP   ; vHeapPtr = HEAP
01B3   22 8F 31               LD   (vHeapPtr),hl   
01B6   21 AE 32               LD   hl,ASSEMBLY   ; vAsmPtr = ASSEMBLY
01B9   22 89 31               LD   (vAsmPtr),hl   
01BC   C9                     RET      
01BD                             ; *****************************************************************************
01BD                             ; Routine: parse
01BD                             ; 
01BD                             ; Purpose:
01BD                             ;    Parses the input program,calling the statementList routine,printing the
01BD                             ;    completion message,and halting the system.
01BD                             ; 
01BD                             ; Inputs:
01BD                             ;    None
01BD                             ; 
01BD                             ; Outputs:
01BD                             ;    None
01BD                             ; 
01BD                             ; Registers Destroyed:
01BD                             ;    None
01BD                             ; *****************************************************************************
01BD                PARSE:       
01BD   CD F7 01               CALL   statementList   ; Parse the input program
01C0   CD A4 05               CALL   print   ; Print completion message
01C3   50 61 72 73 69 6E 67 20 63 6F 6D 70 6C 65 74 65 64 20 73 75 63 63 65 73 73 66 75 6C 6C 79 2E 00 .CSTR   "Parsing completed successfully."   
01E3   76                     HALT      
01E4                PARSEERROR:      
01E4   55 6E 65 78 70 65 63 74 65 64 20 74 6F 6B 65 6E 2E 00 .CSTR   "Unexpected token."   
01F6   76                     HALT      
01F7                             ; *****************************************************************************
01F7                             ; Routine: statementList
01F7                             ; 
01F7                             ; Purpose:
01F7                             ;    Parses a list of statements,repeatedly calling the statement routine until
01F7                             ;    the end of file (EOF) token is encountered.
01F7                             ; 
01F7                             ; Inputs:
01F7                             ;    None
01F7                             ; 
01F7                             ; Outputs:
01F7                             ;    None
01F7                             ; 
01F7                             ; Registers Destroyed:
01F7                             ;    A
01F7                             ; *****************************************************************************
01F7                STATEMENTLIST:      
01F7   CD 4B 03               CALL   nextToken   ; Get the next token
01FA   CD 06 02               CALL   statement   ; Parse a statement
01FD   FE 00                  CP   EOF_   ; Check if it's the end of file
01FF   C8                     RET   z   ; If yes,return
0200   FE 0A                  CP   NEWLN_   
0202   20 E0                  JR   nz,parseError   
0204   18 F1                  JR   statementList   ; Repeat for the next statement
0206                             ; *****************************************************************************
0206                             ; Routine: statement
0206                             ; 
0206                             ; Purpose:
0206                             ;    Parses a single statement,checking its type (label,opcode,or directive)
0206                             ;    and performing corresponding actions.
0206                             ; 
0206                             ; Inputs:
0206                             ;    None
0206                             ; 
0206                             ; Outputs:
0206                             ;    None
0206                             ; 
0206                             ; Registers Destroyed:
0206                             ;    A
0206                             ; *****************************************************************************
0206                STATEMENT:      
0206   CD A8 04               CALL   isEndOfLine   
0209   C8                     RET   z   
020A   F5                     PUSH   af   ; save token
020B   3E FF                  LD   a,-1   
020D   32 91 31               LD   (vOpcode),a   
0210   32 92 31               LD   (vOperand1),a   
0213   32 93 31               LD   (vOperand2),a   
0216   AF                     XOR   a   
0217   32 94 31               LD   (vOpExpr),a   
021A   32 96 31               LD   (vOpDisp),a   
021D   F1                     POP   af   ; restore token
021E   FE 03                  CP   LABEL_   ; Check if it's a label
0220   20 0A                  JR   nz,statement1   ; If not,jump to statement10
0222   ED 5B 89 31            LD   de,(vAsmPtr)   ; HL = symbol name DE = symbol value (assembler pointer)
0226   CD 32 03               CALL   addSymbol   ; Add label to symbol list
0229   CD 4B 03               CALL   nextToken   ; Get the next token
022C                STATEMENT1:      
022C   FE 05                  CP   OPCODE_   ; Check if it's an opcode
022E   28 05                  JR   z,instruction   ; Jump to parseInstruction routine
0230   FE 01                  CP   DIRECT_   ; Check if it's a directive
0232   28 3E                  JR   z,directive   
0234   C9                     RET      
0235                             ; *****************************************************************************
0235                             ; Routine: instruction
0235                             ; 
0235                             ; Purpose:
0235                             ;    Parses an instruction and its operands. Stores the opcode and operands
0235                             ;    in the corresponding variables. Handles both single and double operand
0235                             ;    instructions.
0235                             ; 
0235                             ; Inputs:
0235                             ;    HL - Points to the current token (opcode).
0235                             ; 
0235                             ; Outputs:
0235                             ;    vOpcode - Stores the parsed opcode.
0235                             ;    vOperand1 - Stores the first operand or -1 if there is only one operand.
0235                             ;    vOperand2 - Stores the second operand.
0235                             ; 
0235                             ; Registers Destroyed:
0235                             ;    A, AF
0235                             ; *****************************************************************************
0235                INSTRUCTION:      
0235   7D                     LD   a,l   ; Load the current token (opcode) into A
0236   32 91 31               LD   (vOpcode),a   ; Store the opcode in vOpcode
0239   CD 4B 03               CALL   nextToken   ; Get the next token
023C   CD A8 04               CALL   isEndOfLine   ; Check if the end of the line is reached
023F   C8                     RET   z   ; Return if it is the end of the line
0240   CD 73 02               CALL   operand   ; Parse the first operand
0243   32 92 31               LD   (vOperand1),a   ; Store the first operand in vOperand1
0246   CD 4B 03               CALL   nextToken   ; Get the next token
0249   FE 2C                  CP   COMMA_   ; Check if the token is a comma
024B   20 17                  JR   nz,instruction1   ; If not, handle as a single operand instruction
024D   CD 4B 03               CALL   nextToken   ; Get the next token
0250   CD A8 04               CALL   isEndOfLine   ; Check if the end of the line is reached
0253   28 8F                  JR   z,parseError   ; Jump to parseError if it is the end of the line
0255   CD 73 02               CALL   operand   ; Parse the second operand
0258   32 93 31               LD   (vOperand2),a   ; Store the second operand in vOperand2
025B   CD 4B 03               CALL   nextToken   ; Get the next token
025E   CD A8 04               CALL   isEndOfLine   ; Check if the end of the line is reached
0261   20 81                  JR   nz,parseError   ; Jump to parseError if it is the end of the line
0263   C9                     RET      ; Return from the subroutine
0264                INSTRUCTION1:      
0264   F5                     PUSH   af   ; Save the token type (AF)
0265   3A 92 31               LD   a,(vOperand1)   ; Load the first operand into A
0268   32 93 31               LD   (vOperand2),a   ; Move the first operand to vOperand2
026B   3E FF                  LD   a,-1   ; Set vOperand1 to default value -1 (no operand)
026D   32 92 31               LD   (vOperand1),a   ; Store the default value in vOperand1
0270   F1                     POP   af   ; Restore the token type (AF)
0271   C9                     RET      ; Return from the subroutine
0272                DIRECTIVE:      
0272   C9                     RET      
0273                             ; *****************************************************************************
0273                             ; Routine: operand
0273                             ; 
0273                             ; Purpose:
0273                             ;    Parses and identifies different types of operands (registers,memory,
0273                             ;    immediate values,etc.) used in assembly instructions. Sets the appropriate
0273                             ;    flags based on the operand type.
0273                             ; 
0273                             ; Inputs:
0273                             ;    None (uses the current token from a token stream)
0273                             ; 
0273                             ; Outputs:
0273                             ;    A - Contains operand information
0273                             ; 
0273                             ; Registers Destroyed:
0273                             ;    A,B,DE,HL
0273                             ; *****************************************************************************
0273                OPERAND:      
0273   FE 06                  CP   OPELEM_   ; Check if the token is an op element i.e. reg,rp or flag
0275   28 2A                  JR   z,opElement   
0277   FE 28                  CP   LPAREN_   ; Check if the token is a left parenthesis
0279   28 09                  JR   z,operand1   ; If so,handle as a memory reference
027B   CD D3 02               CALL   expression   ; Otherwise,treat as an expression
027E   22 94 31               LD   (vOpExpr),hl   ; Store the result of the operand expression
0281   3E 18                  LD   a,immed_   ; Set A to indicate an immediate value
0283   C9                     RET      
0284                OPERAND1:      
0284   CD 4B 03               CALL   nextToken   ; Memory reference. Get the next token
0287   FE 06                  CP   OPELEM_   ; Check if the next token is an op element
0289   20 05                  JR   nz,operand2   ; If not,handle as an expression inside parentheses
028B   CD AF 02               CALL   regPairIndirect   
028E   18 08                  JR   operand7   
0290                OPERAND2:      
0290   CD D3 02               CALL   expression   ; Treat as a new expression
0293   22 94 31               LD   (vOpExpr),hl   ; Store the result of the expression
0296   3E 38                  LD   a,immed_ | mem_   ; Set A to indicate an immediate memory reference
0298                OPERAND7:      
0298   CD 4B 03               CALL   nextToken   ; Get the next token
029B   FE 29                  CP   RPAREN_   ; Check if the next token is a right parenthesis
029D   C2 E4 01               JP   nz,parseError   ; If not,handle as a parse error
02A0   C9                     RET      
02A1                             ; *****************************************************************************
02A1                             ; Routine: opElement
02A1                             ; 
02A1                             ; Purpose:
02A1                             ;    Parses the op element (registers, register pairs, flags) sets the
02A1                             ;    appropriate flags based on the type of operand.
02A1                             ; 
02A1                             ; Inputs:
02A1                             ;    HL - Points to the current token.
02A1                             ; 
02A1                             ; Outputs:
02A1                             ;    A - Contains operand information.
02A1                             ; 
02A1                             ; Registers Destroyed:
02A1                             ;    AF, HL
02A1                             ; *****************************************************************************
02A1                OPELEMENT:      
02A1   7D                     LD   a,l   ; Otherwise,Load A with the lower byte of HL (operand)
02A2   FE 0D                  CP   IX_   
02A4   20 03                  JR   nz,opElement2   
02A6   3E 8A                  LD   a,HL_|indX_   
02A8   C9                     RET      
02A9                OPELEMENT2:      
02A9   FE 0E                  CP   IY_   
02AB   C0                     RET   nz   
02AC   3E CA                  LD   a,HL_|indY_   
02AE   C9                     RET      
02AF                             ; *****************************************************************************
02AF                             ; Routine: regPairIndirect
02AF                             ; 
02AF                             ; Purpose:
02AF                             ;    Parses the register indirect memory address sets the
02AF                             ;    appropriate flags based on the type of operand.
02AF                             ; 
02AF                             ; Inputs:
02AF                             ;    HL - Points to the current token.
02AF                             ; 
02AF                             ; Outputs:
02AF                             ;    A - Contains operand information.
02AF                             ; 
02AF                             ; Registers Destroyed:
02AF                             ;    AF, HL
02AF                             ; *****************************************************************************
02AF                REGPAIRINDIRECT:      
02AF   7D                     LD   a,l   ; Otherwise,Load A with the lower byte of HL (operand)
02B0   FE 0A                  CP   HL_   
02B2   20 03                  JR   nz,regPairIndirect2   
02B4   3E 26                  LD   a,MHL_|mem_   
02B6   C9                     RET      
02B7                REGPAIRINDIRECT2:      
02B7   FE 0D                  CP   IX_   
02B9   20 04                  JR   nz,regPairIndirect3   
02BB   3E A6                  LD   a,MHL_|indX_|mem_   
02BD   18 0B                  JR   regPairIndirect5   
02BF                REGPAIRINDIRECT3:      
02BF   FE 0E                  CP   IY_   
02C1   20 04                  JR   nz,regPairIndirect4   
02C3   3E E6                  LD   a,MHL_|indY_| mem_   
02C5   18 03                  JR   regPairIndirect5   
02C7                REGPAIRINDIRECT4:      
02C7   F6 20                  OR   mem_   ; Otherwise,set A to indicate a memory reference
02C9   C9                     RET      
02CA                REGPAIRINDIRECT5:      
02CA   F5                     PUSH   af   ; Save HL on the stack
02CB   CD D3 02               CALL   expression   ; Treat as an expression
02CE   22 96 31               LD   (vOpDisp),hl   ; Store the result of the expression
02D1   F1                     POP   af   ; Restore HL from the stack
02D2   C9                     RET      
02D3                             ; *****************************************************************************
02D3                             ; Routine: expression
02D3                             ; 
02D3                             ; Purpose:
02D3                             ;    Parses an expression as an array of tokens and stores it in an array.
02D3                             ;    Each token in the expression is appended to an array which is terminated by
02D3                             ;    a NULL token type.
02D3                             ;    The expression list pointer is updated to point to the start of the last token list.
02D3                             ; 
02D3                             ; Inputs:
02D3                             ;    A - token type
02D3                             ;    HL - token value
02D3                             ; 
02D3                             ; Outputs:
02D3                             ;    Updates the heap with the parsed expression and updates the expression list pointer.
02D3                             ; 
02D3                             ; Registers Destroyed:
02D3                             ;    AF,B,HL
02D3                             ; *****************************************************************************
02D3                EXPRESSION:      
02D3   06 00                  LD   b,0   ; Initialize nesting level
02D5   E5                     PUSH   hl   ; Save token value
02D6   ED 5B 8F 31            LD   de,(vHeapPtr)   ; Load the current heap pointer into DE
02DA   2A 8D 31               LD   hl,(vExprPtr)   ; Load the current expression list pointer into HL
02DD   CD C3 05               CALL   hpush   ; Push the pointer to the last symbol onto the heap
02E0   21 00 00               LD   hl,0   ; Append two words in header (for future use)
02E3   CD C3 05               CALL   hpush   
02E6   CD C3 05               CALL   hpush   
02E9   ED 53 8D 31            LD   (vExprPtr),de   ; Update the expression list pointer with the new address
02ED   E1                     POP   hl   ; HL = token value
02EE                EXPRESSION1:      
02EE   EB                     EX   de,hl   ; DE = token value
02EF   6F                     LD   l,a   ; HL = token type
02F0   26 00                  LD   h,0   
02F2   CD C3 05               CALL   hpush   ; Push the token type
02F5   EB                     EX   de,hl   ; HL = token value
02F6   CD C3 05               CALL   hpush   ; Push the token value
02F9   CD 4B 03               CALL   nextToken   ; Get the next token
02FC   FE 28                  CP   "("   ; increase nesting?
02FE   20 06                  JR   nz,expression2   
0300   04                     INC   b   
0301   CD 4B 03               CALL   nextToken   ; Get the next token
0304   18 E8                  JR   expression1   ; Repeat the main loop
0306                EXPRESSION2:      
0306   04                     INC   b   ; Check if nesting level is zero
0307   05                     DEC   b   
0308   28 0A                  JR   z,expression3   ; If yes,skip to expression3
030A   FE 29                  CP   ")"   ; if nesting > 0,decrease nesting?
030C   20 06                  JR   nz,expression3   
030E   05                     DEC   b   ; Decrease nesting level
030F   CD 4B 03               CALL   nextToken   ; Get the next token
0312   18 DA                  JR   expression1   ; Repeat the main loop
0314                EXPRESSION3:      
0314   FE 29                  CP   RPAREN_   ; Check if the end of the expression
0316   28 0B                  JR   z,expression4   
0318   FE 2C                  CP   COMMA_   
031A   28 07                  JR   z,expression4   
031C   CD A8 04               CALL   isEndOfLine   
031F   28 02                  JR   z,expression4   
0321   18 CB                  JR   expression1   
0323                EXPRESSION4:      
0323   EB                     EX   de,hl   
0324   21 00 00               LD   hl,NULL   ; Mark the end of the expression with NULL
0327   CD C3 05               CALL   hpush   ; Push NULL onto the heap
032A   EB                     EX   de,hl   
032B   CD 0F 04               CALL   pushBackToken   ; Rewind the token to the last valid one
032E   2A 8D 31               LD   hl,(vExprPtr)   
0331   C9                     RET      
0332                             ; *****************************************************************************
0332                             ; Routine: addSymbol
0332                             ; 
0332                             ; Purpose:
0332                             ;    Adds a new symbol to the symbol list. The symbol's name is in HL and the
0332                             ;    symbol's value is in DE. Updates the symbol list pointer and ensures
0332                             ;    the previous symbol's pointer is preserved.
0332                             ; 
0332                             ; Inputs:
0332                             ;    HL - Points to the name of the new symbol.
0332                             ;    DE - Contains the value of the new symbol.
0332                             ; 
0332                             ; Outputs:
0332                             ;    Updates the symbol list pointer in vSymPtr.
0332                             ; 
0332                             ; Registers Destroyed:
0332                             ;    DE,HL
0332                             ; *****************************************************************************
0332                ADDSYMBOL:      
0332   D5                     PUSH   de   
0333   E5                     PUSH   hl   ; Push symbol name onto the stack
0334   ED 5B 8F 31            LD   de,(vHeapPtr)   ; BC = symbol address from the heap pointer
0338   2A 8B 31               LD   hl,(vSymPtr)   ; Load the current symbol list pointer into HL
033B   CD C3 05               CALL   hpush   ; Push pointer to the last symbol onto the heap
033E   ED 53 8B 31            LD   (vSymPtr),de   ; Update the symbol list pointer with the new symbol address
0342   E1                     POP   hl   ; HL = symbol name
0343   CD C3 05               CALL   hpush   ; Push symbol name onto the heap
0346   E1                     POP   hl   ; HL = symbol value
0347   CD C3 05               CALL   hpush   ; Push symbol value onto the heap
034A   C9                     RET      ; Return from subroutine
034B                             ; *****************************************************************************
034B                             ; Routine: nextToken
034B                             ; 
034B                             ; Purpose:
034B                             ;    Parses the next token from the input stream,identifying various types of
034B                             ;    tokens such as identifiers,labels,opcodes,registers,flags,numbers,
034B                             ;    and special characters.
034B                             ; 
034B                             ; Inputs:
034B                             ;    None
034B                             ; 
034B                             ; Outputs:
034B                             ;    A - Token representing the type of the parsed element
034B                             ; 
034B                             ; Registers Destroyed:
034B                             ;    A,BC,DE,HL
034B                             ; *****************************************************************************
034B                NEXTTOKEN:      
034B   21 84 31               LD   hl,vToken   ; hl points to vToken
034E   7E                     LD   a,(hl)   ; load a with pushed back vToken
034F   CB 7F                  BIT   7,a   ; Check the high bit of token
0351   CA 5B 03               JP   z,nextToken1   ; If high bit clear,nothing pushed back
0354   CB BF                  RES   7,a   ; Clear high bit
0356   77                     LD   (hl),a   ; Store the character back in the BUFFER
0357   2A 85 31               LD   hl,(vTokenVal)   ; put token value into HL
035A   C9                     RET      ; Return with the pushed back character in A
035B                NEXTTOKEN1:      
035B   CD 1D 05               CALL   nextChar   ; Get the next character
035E   21 00 00               LD   hl,0   ; Initialize HL with 0
0361   FE 20                  CP   " "   ; is it space?
0363   28 F6                  JR   z,nextToken1   ; If yes,skip it and get the next character
0365   FE FF                  CP   EOF   ; Is it null (end of input)?
0367   20 03                  JR   nz,nextToken2   ; If not,continue to the next check
0369   3E 00                  LD   a,EOF_   ; If yes,return with EOF token
036B   C9                     RET      
036C                NEXTTOKEN2:      
036C   FE 5C                  CP   $5C   ; Is it a statement separator? "\"
036E   28 08                  JR   z,nextToken2a   ; If not,continue to the next check
0370   FE 3A                  CP   ":"   ; Is it a statement separator? ":"
0372   28 04                  JR   z,nextToken2a   ; If not,continue to the next check
0374   FE 0A                  CP   "\n"   ; Is it a new line
0376   20 03                  JR   nz,nextToken3   ; If not,continue to the next check
0378                NEXTTOKEN2A:      
0378   3E 0A                  LD   a,NEWLN_   ; If yes,return with NEWLIN token
037A   C9                     RET      ; Return with newline token
037B                NEXTTOKEN3:      
037B   FE 3B                  CP   ";"   ; Is it a comment?
037D   20 0C                  JR   nz,nextToken5   ; If not,continue to the next check
037F                NEXTTOKEN4:      
037F   CD 1D 05               CALL   nextChar   ; Get the next character in the comment
0382   FE 21                  CP   " "+1   ; Loop until the next control character
0384   30 F9                  JR   nc,nextToken4   
0386   CD 85 05               CALL   rewindChar   ; Push back the character
0389   18 D0                  JR   nextToken1   ; return with control char
038B                NEXTTOKEN5:      
038B   FE 5F                  CP   "_"   ; Is it an identifier?
038D   28 05                  JR   z,nextToken6   ; If yes,continue to the next check
038F   CD B8 04               CALL   isAlpha   ; If not,check if it's alphabetic
0392   30 37                  JR   nc,nextToken11   ; If not,continue to the next check
0394                NEXTTOKEN6:      
0394   CD 18 04               CALL   ident   ; Parse the identifier
0397   FE 3A                  CP   ":"   ; Is it a label?
0399   20 03                  JR   nz,nextToken7   ; If not,continue to the next check
039B   3E 03                  LD   a,LABEL_   ; If yes,return A = LABEL HL = string
039D   C9                     RET      
039E                NEXTTOKEN7:      
039E   CD 85 05               CALL   rewindChar   ; Push back the character
03A1   22 8F 31               LD   (vHeapPtr),hl   ; Restore string heap pointer to previous location
03A4   CD 50 04               CALL   searchOpcode   
03A7   20 06                  JR   nz,nextToken8   
03A9   6F                     LD   l,a   ; hl = opcode value
03AA   26 00                  LD   h,0   
03AC   3E 05                  LD   a,OPCODE_   ; Return with OPCODE token
03AE   C9                     RET      
03AF                NEXTTOKEN8:      
03AF   CD 7D 04               CALL   searchOpElem   
03B2   20 06                  JR   nz,nextToken9   
03B4   6F                     LD   l,a   ; hl = op element value
03B5   26 00                  LD   h,0   
03B7   3E 06                  LD   a,OPELEM_   ; Return with OPELEM token
03B9   C9                     RET      
03BA                NEXTTOKEN9:      
03BA   11 30 07               LD   de,directives   ; List of directives to search
03BD   CD 38 04               CALL   searchStr   
03C0   20 06                  JR   nz,nextToken10   
03C2   6F                     LD   l,a   ; hl = directive value
03C3   26 00                  LD   h,0   
03C5   3E 01                  LD   a,DIRECT_   ; Return with DIRECT token
03C7   C9                     RET      
03C8                NEXTTOKEN10:      
03C8   3E 02                  LD   a,IDENT_   ; Return with IDENT token
03CA   C9                     RET      
03CB                NEXTTOKEN11:      
03CB   21 00 00               LD   hl,0   
03CE   FE 24                  CP   "$"   ; Is it a hexadecimal number?
03D0   20 1A                  JR   nz,nextToken13   ; If not,continue to the next check
03D2   CD 1D 05               CALL   nextChar   ; Get the next character
03D5   CD B4 04               CALL   isAlphaNum   ; Check if it's the ASSEMBLY pointer
03D8   28 06                  JR   z,nextToken12   ; If not,continue to the next check
03DA   CD 85 05               CALL   rewindChar   ; Push back the character (flags unaffected)
03DD   3E 24                  LD   a,DOLLAR_   ; Return with DOLLAR token
03DF   C9                     RET      ; Return with the DOLLAR token
03E0                NEXTTOKEN12:      
03E0   CD 85 05               CALL   rewindChar   ; Push back the character (flags unaffected)
03E3   CD F0 04               CALL   hexadecimal   ; Process hexadecimal number
03E6   CD 85 05               CALL   rewindChar   ; Push back the character (flags unaffected)
03E9   3E 04                  LD   a,NUM_   ; Return with NUM token
03EB   C9                     RET      
03EC                NEXTTOKEN13:      
03EC   CD CA 04               CALL   isDigit   ; Check if it's a digit
03EF   30 0C                  JR   nc,nextToken14   ; Jump to the next check
03F1   CD 85 05               CALL   rewindChar   ; Push back the character (flags unaffected)
03F4   CD D1 04               CALL   decimal   ; parse decimal
03F7   CD 85 05               CALL   rewindChar   ; Push back the character (flags unaffected)
03FA   3E 04                  LD   a,NUM_   ; Return with NUM token
03FC   C9                     RET      
03FD                NEXTTOKEN14:      
03FD   FE 2B                  CP   "+"   ; If "+" then return PLUS token
03FF   C8                     RET   z   
0400   FE 2D                  CP   "-"   ; If "-" then return MINUS token
0402   C8                     RET   z   
0403   FE 28                  CP   "("   ; If "(" then return LPAREN token
0405   C8                     RET   z   
0406   FE 29                  CP   ")"   ; If ")" then return LPAREN token
0408   C8                     RET   z   
0409   FE 2C                  CP   ","   ; If "," then return COMMA token
040B   C8                     RET   z   
040C   3E 64                  LD   a,UNKNOWN_   ; Return with UNKNOWN token
040E   C9                     RET      
040F                             ; *****************************************************************************
040F                             ; Routine: pushBackToken
040F                             ; 
040F                             ; Purpose:
040F                             ;    Pushes back a token into the pushback BUFFER to allow the token to be
040F                             ;    re-read by the nextToken routine.
040F                             ; 
040F                             ; Inputs:
040F                             ;    A  - token type
040F                             ;    HL - token value
040F                             ; 
040F                             ; Outputs:
040F                             ;    None
040F                             ; 
040F                             ; Registers Destroyed:
040F                             ;    A,DE
040F                             ; *****************************************************************************
040F                PUSHBACKTOKEN:      
040F   CB FF                  SET   7,a   ; Set the high bit of the token type (without affecting flags)
0411   32 84 31               LD   (vToken),a   ; push back the token
0414   22 85 31               LD   (vTokenVal),hl   ; push back the token value
0417   C9                     RET      
0418                             ; *****************************************************************************
0418                             ; Routine: ident
0418                             ; 
0418                             ; Purpose:
0418                             ;    Reads characters from the input stream until a charcter which is not an
0418                             ;    an underscore or an alphanumeric character is encountered. Writes the chars
0418                             ;    to a Pascal string and updates the top of the STRINGS heap pointer.
0418                             ;    It also calculates the length of the string and stores it at the beginning
0418                             ;    of the string.
0418                             ; 
0418                             ; Inputs:
0418                             ;    A - Current character read from the input stream
0418                             ;    vHeapPtr - Address of the top of heap pointer
0418                             ; 
0418                             ; Outputs:
0418                             ;    A - last character read from the input stream
0418                             ;    HL - identifier string
0418                             ; 
0418                             ; Registers Destroyed:
0418                             ;    DE,HL
0418                             ; *****************************************************************************
0418                IDENT:       
0418   2A 8F 31               LD   hl,(vHeapPtr)   ; Load the address of the top of STRINGS heap
041B   E5                     PUSH   hl   ; save start of string
041C   23                     INC   hl   ; Move to the next byte to skip the length byte
041D                IDENT1:      
041D   77                     LD   (hl),a   ; Write the current character to the string BUFFER
041E   23                     INC   hl   ; Move to the next position in the BUFFER
041F   E5                     PUSH   hl   
0420   CD 1D 05               CALL   nextChar   ; Get the next character from the input stream
0423   E1                     POP   hl   
0424   FE 5F                  CP   "_"   ; Compare with underscore character
0426   28 F5                  JR   z,ident1   ; If underscore,jump to ident2
0428   CD B4 04               CALL   isAlphanum   ; Check if the character is alphanumeric
042B   38 F0                  JR   c,ident1   ; If not alphanumeric,jump to ident3
042D                IDENT3:      
042D   22 8F 31               LD   (vHeapPtr),hl   ; Update the top of STRINGS heap pointer
0430   D1                     POP   de   ; restore start of string into de
0431   B7                     OR   a   ; Clear carry
0432   ED 52                  SBC   hl,de   ; Calculate the length of the string (HL = length,DE = string)
0434   2D                     DEC   l   ; reduce by one (length byte)
0435   EB                     EX   de,hl   ; Swap DE and HL (E = length,HL = string)
0436   73                     LD   (hl),e   ; Store the length at the beginning of the string BUFFER
0437   C9                     RET      
0438                             ; *****************************************************************************
0438                             ; Routine: searchStr
0438                             ; 
0438                             ; Purpose:
0438                             ;    Search through a list of Pascal STRINGS for a match.
0438                             ; 
0438                             ; Inputs:
0438                             ;    HL - Points to the string to search for.
0438                             ;    DE - Points to the start of the list of STRINGS.
0438                             ; 
0438                             ; Outputs:
0438                             ;    ZF - True if match,false otherwise.
0438                             ;    A - Index of the matching string if a match is found,or -1 if no match
0438                             ;        is found.
0438                             ;    HL - Points to the string to search for.
0438                             ; 
0438                             ; Destroyed:
0438                             ;    A,B,C,D,E,A",F"
0438                             ; *****************************************************************************
0438                SEARCHSTR:      
0438   06 00                  LD   b,0   ; init b with index 0
043A                SEARCHSTR1:      
043A   CD 96 04               CALL   compareStr   ; compare strings
043D   20 02                  JR   nz,searchStr3   
043F   78                     LD   a,b   ; Load index of match
0440   C9                     RET      ; ZF = true
0441                SEARCHSTR3:      
0441   1A                     LD   a,(de)   ; Load length of current string
0442   3C                     INC   a   ; A = length byte plus length of string
0443   83                     ADD   a,e   ; DE += A, move DE to point to next string
0444   5F                     LD   e,a   
0445   3E 00                  LD   a,0   
0447   8A                     ADC   a,d   
0448   57                     LD   d,a   
0449   04                     INC   b   ; increase index
044A   1A                     LD   a,(de)   ; A = length of next string
044B   B7                     OR   a   ; If A != 0,continue searching
044C   20 EC                  JR   nz,searchStr1   
044E   3D                     DEC   a   ; A = NO_MATCH (i.e.,-1),ZF = false
044F   C9                     RET      
0450                             ; *****************************************************************************
0450                             ; Routine: searchOpcode
0450                             ; 
0450                             ; Purpose:
0450                             ;    Searches for a matching opcode in various lists of opcodes.
0450                             ; 
0450                             ; Inputs:
0450                             ;    HL - Points to the string to search for.
0450                             ; 
0450                             ; Outputs:
0450                             ;    ZF - Set if a match is found,cleared otherwise.
0450                             ;    A  - Contains the index of the matching opcode if a match is found,
0450                             ;         or the last checked index if no match is found.
0450                             ; 
0450                             ; Registers Destroyed:
0450                             ;    A,DE,F
0450                             ; *****************************************************************************
0450                SEARCHOPCODE:      
0450   11 F0 05               LD   de,alu_opcodes   ; Point DE to the list of ALU opcodes
0453   CD 38 04               CALL   searchStr   ; Search for the string in ALU opcodes
0456   C8                     RET   z   ; If match found (ZF set),return
0457   11 D1 05               LD   de,rot_opcodes   ; Point DE to the list of ROT opcodes
045A   CD 38 04               CALL   searchStr   ; Search for the string in ROT opcodes
045D   CB EF                  SET   5,a   ; Set bit 5 in A to indicate ROT opcodes
045F   C8                     RET   z   ; If match found (ZF set),return
0460   11 0F 06               LD   de,bli_opcodes   ; Point DE to the list of BLI opcodes
0463   CD 38 04               CALL   searchStr   ; Search for the string in BLI opcodes
0466   CB F7                  SET   6,a   ; Set bit 6 in A to indicate BLI opcodes
0468   C8                     RET   z   ; If match found (ZF set),return
0469   11 5A 06               LD   de,gen1_opcodes   ; Point DE to the list of general opcodes (set 1)
046C   CD 38 04               CALL   searchStr   ; Search for the string in general opcodes
046F   CB EF                  SET   5,a   ; Set bits 5 & 6 in A to indicate general opcodes (set 1)
0471   CB F7                  SET   6,a   
0473   C8                     RET   z   ; If match found (ZF set),return
0474   11 83 06               LD   de,gen2_opcodes   ; Point DE to the list of general opcodes (set 2)
0477   CD 38 04               CALL   searchStr   ; Search for the string in general opcodes
047A   CB FF                  SET   7,a   ; Set bit 7 in A to indicate general opcodes (set 2)
047C   C9                     RET      ; Return ZF = match
047D                             ; *****************************************************************************
047D                             ; Routine: searchOpElem
047D                             ; 
047D                             ; Purpose:
047D                             ;    Searches for an op element in the lists of 8-bit registers,16-bit registers,
047D                             ;    and flags. Sets appropriate flags based on the type of operand found.
047D                             ; 
047D                             ; Inputs:
047D                             ;    HL - Points to the start of the string to search for.
047D                             ; 
047D                             ; Outputs:
047D                             ;    A  - The index of the matching op element if a match is found,or -1 if no
047D                             ;         match is found.
047D                             ;    ZF - Set if a match is found,cleared otherwise.
047D                             ; 
047D                             ; Registers Destroyed:
047D                             ;    A,DE,HL
047D                             ; *****************************************************************************
047D                SEARCHOPELEM:      
047D   11 EC 06               LD   de,reg8   ; Point DE to the list of 8-bit register operands
0480   CD 38 04               CALL   searchStr   ; Search for the string in reg8 operands
0483   C8                     RET   z   ; If match found (ZF set),return
0484   11 01 07               LD   de,reg16   ; Point DE to the list of 16-bit register operands
0487   CD 38 04               CALL   searchStr   ; Search for the string in reg16 operands
048A   CB DF                  SET   3,a   ; Set bit 3 in A to indicate a register pair operand
048C   C8                     RET   z   ; If match found (ZF set),return
048D   11 1B 07               LD   de,flags   ; Point DE to the list of flag operands
0490   CD 38 04               CALL   searchStr   ; Search for the string in flag operands
0493   CB E7                  SET   4,a   ; Set bit 4 in A to indicate flag operand
0495   C9                     RET      ; Return ZF = match
0496                             ; *****************************************************************************
0496                             ; Routine: compareStr
0496                             ; 
0496                             ; Purpose:
0496                             ;    Compares two Pascal strings. The comparison includes
0496                             ;    the length byte and continues until all characters are compared or a
0496                             ;    mismatch is found.
0496                             ; 
0496                             ; Inputs:
0496                             ;    DE - Points to the start of string1
0496                             ;    HL - Points to the start of string2
0496                             ; 
0496                             ; Outputs:
0496                             ;    ZF - Set if the strings are equal
0496                             ; 
0496                             ; Registers Destroyed:
0496                             ;    A
0496                             ; *****************************************************************************
0496                COMPARESTR:      
0496   C5                     PUSH   bc   ; save BC,DE,HL
0497   D5                     PUSH   de   
0498   E5                     PUSH   hl   
0499   1A                     LD   a,(de)   ; Load length of search string
049A   47                     LD   b,a   ; Copy length to B for looping
049B   04                     INC   b   ; Increase to include length byte
049C                COMPARESTR2:      
049C   1A                     LD   a,(de)   ; Load next character from search string
049D   BE                     CP   (hl)   ; Compare with next character in current string
049E   20 04                  JR   nz,compareStr3   ; break if characters are not equal
04A0   13                     INC   de   ; Move to next character in search string
04A1   23                     INC   hl   ; Move to next character in current string
04A2   10 F8                  DJNZ   compareStr2   ; Loop until all characters compared or mismatch
04A4                COMPARESTR3:      
04A4   E1                     POP   hl   ; restore BC,DE,HL
04A5   D1                     POP   de   
04A6   C1                     POP   bc   
04A7   C9                     RET      ; Return with ZF set if strings are equal
04A8                             ; *****************************************************************************
04A8                             ; Routine: isEndOfLine
04A8                             ; 
04A8                             ; Purpose:
04A8                             ;    Checks if the token is the end-of-file (EOF) or a newline (NEWLN).
04A8                             ; 
04A8                             ; Inputs:
04A8                             ;    A - The token to check.
04A8                             ; 
04A8                             ; Outputs:
04A8                             ;    Z flag - Set if the token is EOF or NEWLN, cleared otherwise.
04A8                             ; 
04A8                             ; Registers Destroyed:
04A8                             ;    None
04A8                             ; *****************************************************************************
04A8                ISENDOFLINE:      
04A8   FE 00                  CP   EOF_   ; Compare the current character with EOF_
04AA   C8                     RET   z   ; Return if the current character is EOF (Z flag set)
04AB   FE 0A                  CP   NEWLN_   ; Compare the current character with NEWLN_
04AD   C9                     RET      ; Return (Z flag set if NEWLN_, cleared otherwise)
04AE                             ; *****************************************************************************
04AE                             ; Routine: isIndexReg
04AE                             ; 
04AE                             ; Purpose:
04AE                             ;    Checks if the current operand is an index register (IX or IY).
04AE                             ; 
04AE                             ; Inputs:
04AE                             ;    A - The operand to check.
04AE                             ; 
04AE                             ; Outputs:
04AE                             ;    ZF - Set if the operand is an index register (IX or IY).
04AE                             ; 
04AE                             ; Registers Destroyed:
04AE                             ;    None
04AE                             ; *****************************************************************************
04AE                ISINDEXREG:      
04AE   FE 0D                  CP   IX_   ; Compare operand with IX
04B0   C8                     RET   z   ; Return if equal (ZF is set)
04B1   FE 0E                  CP   IY_   ; Compare operand with IY
04B3   C9                     RET      ; Return (ZF is set if equal,cleared otherwise)
04B4                             ; *****************************************************************************
04B4                             ; Routine: isAlphaNum
04B4                             ; 
04B4                             ; Purpose:
04B4                             ;    Checks if the character in the A register is an alphanumeric character
04B4                             ;    (either uppercase or lowercase). If the character is alphabetic,it converts
04B4                             ;    it to uppercase and sets the carry flag. If the character is not alphabetic,
04B4                             ;    it clears the carry flag.
04B4                             ; 
04B4                             ; Input:
04B4                             ;    A - Contains the character to be checked.
04B4                             ; 
04B4                             ; Output:
04B4                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
04B4                             ;    CF - Set if the input character was alphabetic,cleared otherwise.
04B4                             ; 
04B4                             ; Destroyed:
04B4                             ;    C
04B4                             ; *****************************************************************************
04B4                ISALPHANUM:      
04B4   CD CA 04               CALL   isDigit   ; Check if it's a digit
04B7   C8                     RET   z   ; If it's not a digit,continue to isAlpha
04B8                             ; Falls through to isAlpha
04B8                             ; *****************************************************************************
04B8                             ; Routine: isAlpha
04B8                             ; 
04B8                             ; Purpose:
04B8                             ;    Checks if the character in the A register is an alphabetic character
04B8                             ;    (either uppercase or lowercase). If the character is alphabetic,it converts
04B8                             ;    it to uppercase and sets the carry flag.
04B8                             ; 
04B8                             ; Input:
04B8                             ;    A - Contains the character to be checked.
04B8                             ; 
04B8                             ; Output:
04B8                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
04B8                             ;    CF - Set if the input character was alphabetic,cleared otherwise.
04B8                             ; 
04B8                             ; Destroyed:
04B8                             ;    None
04B8                             ; *****************************************************************************
04B8                ISALPHA:      
04B8   FE 7B                  CP   "z"+1   ; Compare with "Z" + 1
04BA   D0                     RET   nc   ; Return if it's not alphabetic,no carry
04BB   FE 61                  CP   "a"   ; Compare with lowercase "a"
04BD   38 04                  JR   c,isAlpha1   ; Jump if it"s lower than "a'
04BF   D6 20                  SUB   $20   ; It's lowercase alpha so convert lowercase to uppercase
04C1   37                     SCF      ; no carry so set carry flag
04C2   C9                     RET      
04C3                ISALPHA1:      
04C3   FE 5B                  CP   "Z"+1   ; Compare with "Z" + 1
04C5   D0                     RET   nc   ; Return if it's not alphabetic,no carry
04C6   FE 41                  CP   "A"   ; Compare with "A"
04C8   3F                     CCF      ; Invert CF to set it if it's alphabetic
04C9   C9                     RET      
04CA                             ; *****************************************************************************
04CA                             ; Routine: isDigit
04CA                             ; 
04CA                             ; Purpose:
04CA                             ;    Checks if the character in the A register is a decimal digit (0-9). If
04CA                             ;    the character is a decimal digit,it sets the carry flag.
04CA                             ; 
04CA                             ; Input:
04CA                             ;    A - Contains the character to be checked.
04CA                             ; 
04CA                             ; Output:
04CA                             ;    CF - Set if the input character was a digit,cleared otherwise.
04CA                             ; 
04CA                             ; Destroyed:
04CA                             ;    None
04CA                             ; *****************************************************************************
04CA                ISDIGIT:      
04CA   FE 3A                  CP   "9"+1   ; Compare with "9" + 1
04CC   D0                     RET   nc   ; Return if it's not a digit
04CD   FE 30                  CP   "0"   ; Compare with "0"
04CF   3F                     CCF      ; Invert CF to set it if it's a digit
04D0   C9                     RET      
04D1                             ; *****************************************************************************
04D1                             ; Routine: decimal
04D1                             ; 
04D1                             ; Purpose:
04D1                             ;    Parse a decimal number.
04D1                             ; 
04D1                             ; Input:
04D1                             ;    None
04D1                             ; 
04D1                             ; Output:
04D1                             ;    HL - Parsed number.
04D1                             ; 
04D1                             ; Destroyed:
04D1                             ;    A,DE
04D1                             ; *****************************************************************************
04D1                DECIMAL:      
04D1   21 00 00               LD   hl,0   ; Initialize HL to 0
04D4                DECIMAL1:      
04D4   D5                     PUSH   de   
04D5   E5                     PUSH   hl   
04D6   CD 1D 05               CALL   nextChar   ; Get the next character
04D9   E1                     POP   hl   
04DA   D1                     POP   de   
04DB   D6 30                  SUB   "0"   ; Convert ASCII to binary
04DD   D8                     RET   c   ; Return if less than "0"
04DE   FE 0A                  CP   10   ; Compare with 10
04E0   D0                     RET   nc   ; Return if greater than 10
04E1   03                     INC   bc   ; Increment BC to point to next digit
04E2   54 5D                  LD   de,hl   ; Copy HL to DE
04E4   29                     ADD   hl,hl   ; Multiply HL by 2
04E5   29                     ADD   hl,hl   ; Multiply HL by 4
04E6   19                     ADD   hl,de   ; Add DE to HL to multiply by 5
04E7   29                     ADD   hl,hl   ; Multiply HL by 10
04E8   85                     ADD   a,l   ; Add A to HL
04E9   6F                     LD   l,a   ; Store result back in L
04EA   3E 00                  LD   a,0   ; Clear A
04EC   8C                     ADC   a,h   ; Add carry to H
04ED   67                     LD   h,a   ; Store result back in H
04EE   18 E4                  JR   decimal1   ; Jump back to start of loop
04F0                             ; *****************************************************************************
04F0                             ; Routine: hexadecimal
04F0                             ; 
04F0                             ; Purpose:
04F0                             ;    Parse a hexadecimal number.
04F0                             ; 
04F0                             ; Input:
04F0                             ;    None
04F0                             ; 
04F0                             ; Output:
04F0                             ;    HL - Parsed number.
04F0                             ; 
04F0                             ; Destroyed:
04F0                             ;    A
04F0                             ; *****************************************************************************
04F0                HEXADECIMAL:      
04F0   21 00 00               LD   hl,0   ; Initialize HL to 0
04F3                HEXADECIMAL1:      
04F3   E5                     PUSH   hl   
04F4   CD 1D 05               CALL   nextChar   ; Get the next character
04F7   E1                     POP   hl   
04F8   FE 30                  CP   "0"   ; Compare with ASCII "0"
04FA   D8                     RET   c   ; Return if less than "0"
04FB   FE 3A                  CP   "9"+1   ; Compare with ASCII "9" + 1
04FD   38 0F                  JR   c,hexadecimal4   ; If less or equal,jump to valid
04FF   FE 61                  CP   "a"   ; Compare with ASCII "a"
0501   38 02                  JR   c,hexadecimal2   ; If less,jump to hexadecimal2
0503   D6 20                  SUB   $20   ; Convert lowercase to uppercase
0505                HEXADECIMAL2:      
0505   FE 41                  CP   "A"   ; Compare with ASCII "A"
0507   D8                     RET   c   ; Return if less than "A"
0508   FE 47                  CP   "F"+1   ; Compare with ASCII "F" + 1
050A   38 00                  JR   c,hexadecimal3   ; If less or equal,jump to hexadecimal3
050C                HEXADECIMAL3:      
050C   D6 37                  SUB   $37   ; Convert ASCII to hexadecimal
050E                HEXADECIMAL4:      
050E   D6 30                  SUB   "0"   ; Convert ASCII to numeric value
0510   D8                     RET   c   ; Return if less than 0 (not a valid digit)
0511   FE 10                  CP   $10   ; Compare with 16
0513   D0                     RET   nc   ; Return if greater than 16 (not a valid digit)
0514   29                     ADD   hl,hl   ; Multiply by 16
0515   29                     ADD   hl,hl   ; Multiply by 16
0516   29                     ADD   hl,hl   ; Multiply by 16
0517   29                     ADD   hl,hl   ; Multiply by 16
0518   85                     ADD   a,l   ; Add new digit to HL
0519   6F                     LD   l,a   ; Store result back in L
051A   C3 F3 04               JP   hexadecimal1   ; Jump back to hexadecimal1 to process next character
051D                             ; *****************************************************************************
051D                             ; Routine: nextChar
051D                             ; 
051D                             ; Purpose:
051D                             ;    Fetches the next character from the BUFFER. If the BUFFER is empty or
051D                             ;    contains a null character (0),it refills the BUFFER by calling nextLine.
051D                             ; 
051D                             ; Inputs:
051D                             ;    None
051D                             ; 
051D                             ; Outputs:
051D                             ;    A - The next character from the BUFFER
051D                             ; 
051D                             ; Registers Destroyed:
051D                             ;    A,D,E,HL
051D                             ; *****************************************************************************
051D                NEXTCHAR:      
051D   21 87 31               LD   hl,vBufferPos   ; Load the offset of BUFFER position variable
0520   7E                     LD   a,(hl)   ; Load the current position offset in the BUFFER into A
0521   FE 80                  CP   BUFFER_SIZE   ; Compare with BUFFER size
0523   CA 34 05               JP   z,nextLine   ; Jump to nextLine if end of BUFFER
0526   11 00 30               LD   de,BUFFER   ; Load the MSB of the BUFFER's address into D
0529   83                     ADD   a,e   ; de += a
052A   5F                     LD   e,a   
052B   3E 00                  LD   a,0   
052D   8A                     ADC   a,d   
052E   57                     LD   d,a   
052F   1A                     LD   a,(de)   ; Load the character at the current BUFFER position into A
0530   34                     INC   (hl)   ; Increment the BUFFER position offset
0531   FE 0A                  CP   "\n"   ; if a != null return else load a new line into buffer
0533   C0                     RET   nz   
0534                NEXTLINE:      
0534   21 00 30               LD   hl,BUFFER   ; Start of the BUFFER
0537   06 80                  LD   b,BUFFER_SIZE   ; Number of bytes to fill
0539                NEXTLINE1:      
0539   CD 81 00               CALL   getchar   ; Get a character from getchar
053C   FE FF                  CP   EOF   ; is it EOF
053E   28 32                  JR   z,nextLine6   
0540   B7                     OR   a   ; is it NULL?
0541   28 04                  JR   z,nextLine2   
0543   FE 03                  CP   CTRL_C   ; is it ctrl-C ?
0545   20 04                  JR   nz,nextLine3   
0547                NEXTLINE2:      
0547   3E FF                  LD   a,EOF   
0549   18 27                  JR   nextLine6   
054B                NEXTLINE3:      
054B   FE 08                  CP   "\b"   ; Check if character is backspace
054D   20 10                  JR   nz,nextLine4   ; If not,proceed to store the character
054F   3E 80                  LD   a,BUFFER_SIZE   
0551   90                     SUB   b   ; Check if at the start of the buffer
0552   28 E5                  JR   z,nextLine1   ; If at the start,ignore backspace
0554   2B                     DEC   hl   ; Move back in the buffer
0555   04                     INC   b   ; Adjust buffer size counter
0556   CD A4 05               CALL   print   ; Erase the character at the current cursor position
0559   1B 5B 50 00            .CSTR   ESC,"[P"   ; Escape sequence for erasing character
055D   18 DA                  JR   nextLine1   
055F                NEXTLINE4:      
055F   CD 87 00               CALL   putchar   ; Echo character to terminal
0562   FE 09                  CP   "\t"   
0564   20 04                  JR   nz,nextLine5   ; if a == CR or NL replace with null
0566   3E 20                  LD   a," "   
0568   18 08                  JR   nextLine6   
056A                NEXTLINE5:      
056A   FE 0D                  CP   "\r"   ; Check if character is carriage return
056C   20 04                  JR   nz,nextLine6   
056E   3E 0A                  LD   a,"\n"   
0570   18 00                  JR   nextLine6   
0572                NEXTLINE6:      
0572   77                     LD   (hl),a   ; Store the character in the BUFFER
0573   23                     INC   hl   ; Move to the next position in the BUFFER
0574   FE FF                  CP   EOF   ; Break loop if character is end of line
0576   28 06                  JR   z,nextLine7   
0578   FE 0A                  CP   "\n"   ; Break loop if character is end of line
057A   28 02                  JR   z,nextLine7   
057C   10 BB                  DJNZ   nextLine1   ; Repeat until BUFFER is full
057E                NEXTLINE7:      
057E   21 87 31               LD   hl,vBufferPos   
0581   36 00                  LD   (hl),0   
0583   18 98                  JR   nextChar   
0585                             ; *****************************************************************************
0585                             ; Routine: rewindChar
0585                             ; 
0585                             ; Purpose:
0585                             ;    Rewinds the BUFFER position by one character,effectively pushing back the
0585                             ;    BUFFER position by one character in the input stream.
0585                             ; 
0585                             ; Inputs:
0585                             ;    None
0585                             ; 
0585                             ; Outputs:
0585                             ;    None
0585                             ; 
0585                             ; Registers Destroyed:
0585                             ;    A
0585                             ; *****************************************************************************
0585                REWINDCHAR:      
0585   3A 87 31               LD   a,(vBufferPos)   ; Load the current position in the BUFFER into A
0588   B7                     OR   a   ; Check if the BUFFER position is zero
0589   C8                     RET   z   ; If zero,nothing to push back,return
058A   3D                     DEC   a   ; Decrement the BUFFER position
058B   32 87 31               LD   (vBufferPos),a   
058E   C9                     RET      
058F                             ; *****************************************************************************
058F                             ; Routine: prompt
058F                             ; 
058F                             ; Purpose:
058F                             ;    Prints a prompt symbol ("> ") to indicate readiness for user input.
058F                             ; 
058F                             ; Inputs:
058F                             ;    None
058F                             ; 
058F                             ; Outputs:
058F                             ;    None
058F                             ; 
058F                             ; Registers Destroyed:
058F                             ;    A,HL
058F                             ; *****************************************************************************
058F                PROMPT:      
058F   CD A4 05               CALL   print   ; Print the null-terminated string (prompt message)
0592   0D 0A 3E 20 00         .CSTR   "\r\n> "   ; Define the prompt message
0597   C9                     RET      ; Return to the caller
0598                             ; *****************************************************************************
0598                             ; Routine: crlf
0598                             ; 
0598                             ; Purpose:
0598                             ;    Prints a carriage return and line feed (new line) to the output.
0598                             ; 
0598                             ; Inputs:
0598                             ;    None
0598                             ; 
0598                             ; Outputs:
0598                             ;    None
0598                             ; 
0598                             ; Registers Destroyed:
0598                             ;    A,HL
0598                             ; *****************************************************************************
0598                CRLF:        
0598   CD A4 05               CALL   print   ; Print the null-terminated string (carriage return and line feed)
059B   0D 0A 00               .CSTR   "\r\n"   ; Define the carriage return and line feed message
059E   C9                     RET      ; Return to the caller
059F                             ; *****************************************************************************
059F                             ; Routine: error
059F                             ; 
059F                             ; Purpose:
059F                             ;    Prints an error message and halts execution.
059F                             ; 
059F                             ; Inputs:
059F                             ;    (Stack) - The address of the error message to be printed
059F                             ; 
059F                             ; Outputs:
059F                             ;    None
059F                             ; 
059F                             ; Registers Destroyed:
059F                             ;    A,HL
059F                             ; *****************************************************************************
059F                ERROR:       
059F   E1                     POP   hl   ; Retrieve the "return" address which is the address of the error message
05A0   CD AB 05               CALL   printStr   ; Call the routine to print the null-terminated string
05A3   76                     HALT      ; Halt the CPU
05A4                             ; *****************************************************************************
05A4                             ; Routine: print
05A4                             ; 
05A4                             ; Purpose:
05A4                             ;    Prints a null-terminated string starting from the address in HL.
05A4                             ; 
05A4                             ; Inputs:
05A4                             ;    HL - Points to the start of the string to be printed
05A4                             ; 
05A4                             ; Outputs:
05A4                             ;    None
05A4                             ; 
05A4                             ; Registers Destroyed:
05A4                             ;    None
05A4                             ; *****************************************************************************
05A4                PRINT:       
05A4   E3                     EX   (sp),hl   ; Swap HL with the value on the stack to preserve HL
05A5   CD B8 05               CALL   printZStr   ; Call the routine to print the null-terminated string
05A8   23                     INC   hl   ; Increment HL to skip the null terminator
05A9   E3                     EX   (sp),hl   ; Restore the original value of HL from the stack
05AA   C9                     RET      ; Return to the caller
05AB                             ; *****************************************************************************
05AB                             ; Routine: printStr
05AB                             ; 
05AB                             ; Purpose:
05AB                             ;    Prints a Pascal string stored in memory.
05AB                             ; 
05AB                             ; Inputs:
05AB                             ;    HL - Points to the start of the string (first byte is the length)
05AB                             ; 
05AB                             ; Outputs:
05AB                             ;    None
05AB                             ; 
05AB                             ; Registers Destroyed:
05AB                             ;    A,B,HL
05AB                             ; *****************************************************************************
05AB                PRINTSTR:      
05AB   7E                     LD   a,(hl)   ; Load the length of the string
05AC   B7                     OR   a   ; Check if the length is zero
05AD   C8                     RET   z   ; If zero,return immediately
05AE   23                     INC   hl   ; Move HL to the start of the string data
05AF   47                     LD   b,a   ; Copy the length to B for looping
05B0                PRINTSTR1:      
05B0   7E                     LD   a,(hl)   ; Load the next character
05B1   CD 87 00               CALL   putchar   ; Call a routine that prints a single character
05B4   23                     INC   hl   ; Move to the next character
05B5   10 F9                  DJNZ   printStr1   ; Decrement B and jump if not zero
05B7   C9                     RET      ; Return from the routine
05B8                             ; *****************************************************************************
05B8                             ; Routine: printZStr
05B8                             ; 
05B8                             ; Purpose:
05B8                             ;    Prints a null-terminated string stored in memory.
05B8                             ; 
05B8                             ; Inputs:
05B8                             ;    HL - Points to the start of the string to be printed
05B8                             ; 
05B8                             ; Outputs:
05B8                             ;    None
05B8                             ; 
05B8                             ; Registers Destroyed:
05B8                             ;    A,HL
05B8                             ; *****************************************************************************
05B8                PRINTZSTR:      
05B8   18 04                  JR   printZStr2   ; Jump to the loop condition
05BA                PRINTZSTR1:      
05BA   CD 87 00               CALL   putchar   ; Print the current character
05BD   23                     INC   hl   ; Move to the next character
05BE                PRINTZSTR2:      
05BE   7E                     LD   a,(hl)   ; Load the current character
05BF   B7                     OR   a   ; Check if the character is null
05C0   20 F8                  JR   nz,printZStr1   ; If not null,continue printing
05C2   C9                     RET      ; Return when null character is encountered
05C3                             ; *****************************************************************************
05C3                             ; Routine: hpush
05C3                             ; 
05C3                             ; Purpose:
05C3                             ;    Pushes a 16-bit value onto the heap. The value to be pushed is in DE,
05C3                             ;    and the heap pointer is updated accordingly.
05C3                             ; 
05C3                             ; Inputs:
05C3                             ;    DE - The 16-bit value to be pushed onto the heap.
05C3                             ; 
05C3                             ; Outputs:
05C3                             ;    Updates the heap pointer in vHeapPtr.
05C3                             ; 
05C3                             ; Registers Destroyed:
05C3                             ;    DE,HL
05C3                             ; *****************************************************************************
05C3                HPUSH:       
05C3   D5                     PUSH   de   ; Save DE
05C4   EB                     EX   de,hl   ; Exchange DE and HL to move value to DE
05C5   2A 8F 31               LD   hl,(vHeapPtr)   ; Load the current top of the heap into HL
05C8   72                     LD   (hl),d   ; Store the high byte of DE (now in HL) on the heap
05C9   23                     INC   hl   ; Increment HL to point to the next heap position
05CA   73                     LD   (hl),e   ; Store the low byte of DE (now in HL) on the heap
05CB   23                     INC   hl   ; Increment HL to point to the new top of the heap
05CC   22 8F 31               LD   (vHeapPtr),hl   ; Update the heap pointer with the new top of the heap
05CF   D1                     POP   de   ; Restore DE
05D0   C9                     RET      ; Return from the subroutine
05D1                             ; ; *****************************************************************************
05D1                             ; ; Routine: hpop
05D1                             ; ;
05D1                             ; ; Purpose:
05D1                             ; ;    Pops a 16-bit value from the heap into HL. The heap pointer is updated
05D1                             ; ;    accordingly.
05D1                             ; ;
05D1                             ; ; Inputs:
05D1                             ; ;    None
05D1                             ; ;
05D1                             ; ; Outputs:
05D1                             ; ;    HL - Contains the 16-bit value popped from the heap.
05D1                             ; ;    Updates the heap pointer in vHeapPtr.
05D1                             ; ;
05D1                             ; ; Registers Destroyed:
05D1                             ; ;    DE,HL
05D1                             ; ; *****************************************************************************
05D1                             ; hpop:
05D1                             ;     push de                   ; Save DE
05D1                             ;     ld hl,(vHeapPtr)          ; Load the current top of the heap into HL
05D1                             ;     dec hl                    ; Decrement HL to point to the high byte of the value
05D1                             ;     ld l,(hl)                 ; Load the low byte of the value into L
05D1                             ;     dec hl                    ; Decrement HL to point to the low byte of the value
05D1                             ;     ld h,(hl)                 ; Load the high byte of the value into H
05D1                             ;     ld (vHeapPtr),hl          ; Update the heap pointer with the new top of the heap
05D1                             ;     ex de,hl                  ; Exchange DE and HL to move the value to HL
05D1                             ;     pop de                    ; Restore DE
05D1                             ;     ret                       ; Return from the subroutine
05D1                             ; *******************************************************************************
05D1                             ; *********  END OF MAIN   ******************************************************
05D1                             ; *******************************************************************************
05D1                ROT_OPCODES:      
05D1   03 52 4C 43            .PSTR   "RLC"   
05D5   03 52 52 43            .PSTR   "RRC"   
05D9   02 52 4C               .PSTR   "RL"   
05DC   02 52 52               .PSTR   "RR"   
05DF   03 53 4C 41            .PSTR   "SLA"   
05E3   03 53 52 41            .PSTR   "SRA"   
05E7   03 53 4C 4C            .PSTR   "SLL"   
05EB   03 53 52 4C            .PSTR   "SRL"   
05EF   00                     .PSTR   ""   ; terminate list with a string of zero length
05F0                ALU_OPCODES:      
05F0   03 41 44 44            .PSTR   "ADD"   
05F4   03 41 44 43            .PSTR   "ADC"   
05F8   03 53 55 42            .PSTR   "SUB"   
05FC   03 53 42 43            .PSTR   "SBC"   
0600   03 41 4E 44            .PSTR   "AND"   
0604   03 58 4F 52            .PSTR   "XOR"   
0608   02 4F 52               .PSTR   "OR"   
060B   02 43 50               .PSTR   "CP"   
060E   00                     .PSTR   ""   ; terminate list with a string of zero length
060F                BLI_OPCODES:      
060F   03 4C 44 49            .PSTR   "LDI"   
0613   03 43 50 49            .PSTR   "CPI"   
0617   03 49 4E 49            .PSTR   "INI"   
061B   04 4F 55 54 49         .PSTR   "OUTI"   
0620   03 4C 44 44            .PSTR   "LDD"   
0624   03 43 50 44            .PSTR   "CPD"   
0628   03 49 4E 44            .PSTR   "IND"   
062C   04 4F 55 54 44         .PSTR   "OUTD"   
0631   04 4C 44 49 52         .PSTR   "LDIR"   
0636   04 43 50 49 52         .PSTR   "CPIR"   
063B   04 49 4E 49 52         .PSTR   "INIR"   
0640   04 4F 54 49 52         .PSTR   "OTIR"   
0645   04 4C 44 44 52         .PSTR   "LDDR"   
064A   04 43 50 44 52         .PSTR   "CPDR"   
064F   04 49 4E 44 52         .PSTR   "INDR"   
0654   04 4F 54 44 52         .PSTR   "OTDR"   
0659   00                     .PSTR   ""   ; terminate list with a string of zero length
065A                GEN1_OPCODES:      
065A   03 43 43 46            .PSTR   "CCF"   
065E   03 43 50 4C            .PSTR   "CPL"   
0662   03 44 41 41            .PSTR   "DAA"   
0666   02 44 49               .PSTR   "DI"   
0669   02 45 49               .PSTR   "EI"   
066C   04 48 41 4C 54         .PSTR   "HALT"   
0671   03 4E 4F 50            .PSTR   "NOP"   
0675   04 52 4C 43 41         .PSTR   "RLCA"   
067A   03 52 53 54            .PSTR   "RST"   
067E   03 53 43 46            .PSTR   "SCF"   
0682   00                     .PSTR   ""   ; terminate list with a string of zero length
0683                GEN2_OPCODES:      
0683   03 42 49 54            .PSTR   "BIT"   
0687   04 43 41 4C 4C         .PSTR   "CALL"   
068C   03 44 45 43            .PSTR   "DEC"   
0690   04 44 4A 4E 5A         .PSTR   "DJNZ"   
0695   02 45 58               .PSTR   "EX"   
0698   03 45 58 58            .PSTR   "EXX"   
069C   02 49 4D               .PSTR   "IM"   
069F   02 49 4E               .PSTR   "IN"   
06A2   03 49 4E 43            .PSTR   "INC"   
06A6   02 4A 50               .PSTR   "JP"   
06A9   02 4A 52               .PSTR   "JR"   
06AC   02 4C 44               .PSTR   "LD"   
06AF   03 4E 45 47            .PSTR   "NEG"   
06B3   03 4F 55 54            .PSTR   "OUT"   
06B7   03 50 4F 50            .PSTR   "POP"   
06BB   04 50 55 53 48         .PSTR   "PUSH"   
06C0   03 52 45 53            .PSTR   "RES"   
06C4   03 52 45 54            .PSTR   "RET"   
06C8   04 52 45 54 49         .PSTR   "RETI"   
06CD   04 52 45 54 4E         .PSTR   "RETN"   
06D2   03 52 4C 41            .PSTR   "RLA"   
06D6   03 52 4C 44            .PSTR   "RLD"   
06DA   03 52 52 41            .PSTR   "RRA"   
06DE   04 52 52 43 41         .PSTR   "RRCA"   
06E3   03 52 52 44            .PSTR   "RRD"   
06E7   03 53 45 54            .PSTR   "SET"   
06EB   00                     .PSTR   ""   ; terminate list with a string of zero length
06EC                REG8:        
06EC   01 42                  .PSTR   "B"   
06EE   01 43                  .PSTR   "C"   
06F0   01 44                  .PSTR   "D"   
06F2   01 45                  .PSTR   "E"   
06F4   01 48                  .PSTR   "H"   
06F6   01 4C                  .PSTR   "L"   
06F8   01 20                  .PSTR   " "   ; don't match, stand-in for (HL)
06FA   01 41                  .PSTR   "A"   
06FC   01 49                  .PSTR   "I"   
06FE   01 52                  .PSTR   "R"   
0700   00                     .PSTR   ""   ; terminate list with a string of zero length
0701                REG16:       
0701   02 42 43               .PSTR   "BC"   
0704   02 44 45               .PSTR   "DE"   
0707   02 48 4C               .PSTR   "HL"   
070A   02 53 50               .PSTR   "SP"   
070D   02 49 58               .PSTR   "IX"   
0710   02 49 59               .PSTR   "IY"   
0713   03 41 46 27            .PSTR   "AF'"   
0717   02 41 46               .PSTR   "AF"   ; NOTE: AF has the same code as SP in some instructions
071A   00                     .PSTR   ""   ; terminate list with a string of zero length
071B                FLAGS:       
071B   02 4E 5A               .PSTR   "NZ"   
071E   01 5A                  .PSTR   "Z"   
0720   02 4E 43               .PSTR   "NC"   
0723   01 43                  .PSTR   "C"   
0725   02 50 4F               .PSTR   "PO"   
0728   02 50 45               .PSTR   "PE"   
072B   01 50                  .PSTR   "P"   
072D   01 4D                  .PSTR   "M"   
072F   00                     .PSTR   ""   ; terminate list with a string of zero length
0730                DIRECTIVES:      
0730   06 2E 41 4C 49 47 4E   .PSTR   ".ALIGN"   
0737   03 2E 44 42            .PSTR   ".DB"   
073B   04 2E 4F 52 47         .PSTR   ".ORG"   
0740   04 2E 53 45 54         .PSTR   ".SET"   
0745   00                     .PSTR   ""   ; terminate list with a string of zero length
0746                             ; *******************************************************************************
0746                             ; *********  END OF DATA   ******************************************************
0746                             ; *******************************************************************************
3000                          .ORG   RAMSTART   
3000                          ALIGN   $100   
3000                BUFFER:   DS   BUFFER_SIZE   ; line BUFFER,page aligned
3080                          DS   $100   
3180                STACK:       ; grows down
3180                VTEMP1:   DS   2   ; temp var 1
3182                VTEMP2:   DS   2   ; temp var 2
3184                VTOKEN:   DS   1   ; BUFFER for pushed back token
3185                VTOKENVAL:   DS   2   ; BUFFER for pushed back token value
3187                VBUFFERPOS:   DS   2   ; pointer to char position into input BUFFER
3189                VASMPTR:   DS   2   ; pointer to ASSEMBLY point
318B                VSYMPTR:   DS   2   ; pointer to last symbol
318D                VEXPRPTR:   DS   2   ; pointer to last expression
318F                VHEAPPTR:   DS   2   ; pointer to Heap
3191                VOPCODE:   DS   1   
3192                VOPERAND1:   DS   1   
3193                VOPERAND2:   DS   1   
3194                VOPEXPR:   DS   2   
3196                VOPDISP:   DS   2   
3198                RST08:    DS   2   
319A                RST10:    DS   2   
319C                RST18:    DS   2   
319E                RST20:    DS   2   
31A0                RST28:    DS   2   
31A2                RST30:    DS   2   
31A4                BAUD:     DS   2   
31A6                INTVEC:   DS   2   
31A8                NMIVEC:   DS   2   
31AA                GETCVEC:   DS   2   
31AC                PUTCVEC:   DS   2   
31AE                HEAP:     DS   HEAP_SIZE   ; expression heap - grows up
32AE                ASSEMBLY:      
4000                          .ORG   $4000   
4000                TESTSSTART:      
4000   31 80 31               LD   sp,STACK   
4003                             ; ; ------------------------------------------------------------
4003                             ; call describe
4003                             ; .cstr "It should do nothing"
4003                             ; call test
4003                             ; .db 0
4003                             ; call expect
4003                             ; .db 0
4003                             ; ; ------------------------------------------------------------
4003                             ; call describe
4003                             ; .cstr "parse opcode without operands"
4003                             ; call test
4003                             ; .db "halt"
4003                             ; .db 0
4003                             ; call expectOpData
4003                             ; .db HALT_, -1, -1
4003                             ; ; ------------------------------------------------------------
4003                             ; call describe
4003                             ; .cstr "parse opcode with an immediate operand"
4003                             ; call test
4003                             ; .db "jp 0"
4003                             ; .db 0
4003                             ; call expectOpData
4003                             ; .db JP_, -1, immed_
4003                             ; ; ------------------------------------------------------------
4003                             ; call describe
4003                             ; .cstr "parse opcode with a flag operand, an immediate operand"
4003                             ; call test
4003                             ; .db "jp nz,0"
4003                             ; .db 0
4003                             ; call expectOpData
4003                             ; .db JP_, NZ_, immed_
4003                             ; ; ------------------------------------------------------------
4003   CD 62 40               CALL   describe   
4006   70 61 72 73 65 20 6F 70 63 6F 64 65 20 77 69 74 68 20 61 20 72 65 67 20 6F 70 65 72 61 6E 64 2C 20 61 6E 20 72 65 67 20 69 6E 64 69 72 65 63 74 20 6F 70 65 72 61 6E 64 00 .CSTR   "parse opcode with a reg operand, an reg indirect operand"   
403F   CD 6B 40               CALL   test   
4042   6A 70 20 6E 7A 2C 30   DB   "jp nz,0"   
4049                             ; .db "ld a,(hl)"
4049   00                     DB   0   
404A   CD 9F 40               CALL   expectOpData   
404D   89 10 18               DB   JP_,NZ_,immed_   
4050                             ; ------------------------------------------------------------
4050                             ; .cstr "It should assemble one instruction"
4050                             ; call expect
4050                             ; .db 01,$76
4050   CD A4 05               CALL   print   
4053   0D 0A 44 6F 6E 65 21 00 .CSTR   "\r\nDone!"   
405B   76                     HALT      
405C                             ; *****************************************************************************
405C                             ; Test variables
405C                             ; *****************************************************************************
405C                TBDESC:      
405C   00 00                  DW   0   ; Address of the description
405E                TBTEXT:      
405E   00 00                  DW   0   ; Address of the test text
4060                TBPTR:       
4060   00 00                  DW   0   ; Pointer to the current position in the test text
4062                             ; *****************************************************************************
4062                             ; Routine: describe
4062                             ; 
4062                             ; Purpose:
4062                             ;    Stores the address of a description string in tbDesc and then skips the string.
4062                             ; 
4062                             ; Inputs:
4062                             ;    HL - Address of the description string
4062                             ; 
4062                             ; Outputs:
4062                             ;    None
4062                             ; 
4062                             ; Registers Destroyed:
4062                             ;    HL
4062                             ; *****************************************************************************
4062                DESCRIBE:      
4062   E1                     POP   hl   ; Retrieve the return address (address of the description string)
4063   22 5C 40               LD   (tbDesc),hl   ; Store the address in tbDesc
4066   CD 4D 41               CALL   skipZStr   ; Skip the description string
4069   23                     INC   hl   ; Move to the next byte after the null terminator
406A   E9                     JP   (hl)   ; Jump to the address specified by the next byte
406B                             ; *****************************************************************************
406B                             ; Routine: test
406B                             ; 
406B                             ; Purpose:
406B                             ;    Stores the address of a test text in tbText and tbPtr,and then skips the string.
406B                             ; 
406B                             ; Inputs:
406B                             ;    HL - Address of the test text
406B                             ; 
406B                             ; Outputs:
406B                             ;    None
406B                             ; 
406B                             ; Registers Destroyed:
406B                             ;    HL
406B                             ; *****************************************************************************
406B                TEST:        
406B   E1                     POP   hl   ; Retrieve the return address (address of the test text)
406C   22 5E 40               LD   (tbText),hl   ; Store the address in tbText
406F   22 60 40               LD   (tbPtr),hl   ; Initialize tbPtr with the address of the test text
4072   CD 4D 41               CALL   skipZStr   ; Skip the test text string
4075   23                     INC   hl   ; Move to the next byte after the null terminator
4076   E5                     PUSH   hl   ; push new return address
4077   CD 98 01               CALL   init   ; Initialize the environment
407A   21 23 41               LD   hl,testGetCharImpl   ; Load the address of testGetCharImpl
407D   22 AA 31               LD   (GETCVEC),hl   ; Set the GETCVEC to point to testGetCharImpl
4080   C3 F7 01               JP   statementList   
4083                             ; *****************************************************************************
4083                             ; Routine: expect
4083                             ; 
4083                             ; Purpose:
4083                             ;    Initializes the environment,sets up the testGetCharImpl,executes the statementList,
4083                             ;    and compares the result with the expected output.
4083                             ; 
4083                             ; Inputs:
4083                             ;    None
4083                             ; 
4083                             ; Outputs:
4083                             ;    None
4083                             ; 
4083                             ; Registers Destroyed:
4083                             ;    HL,DE
4083                             ; *****************************************************************************
4083                EXPECT:      
4083   E1                     POP   hl   ; Retrieve the return address
4084   11 AE 32               LD   de,ASSEMBLY   ; Load the expected output address into DE
4087   CD 96 04               CALL   compareStr   ; Compare the result with the expected output
408A   20 01                  JR   nz,expect1   ; If comparison fails,jump to expect1
408C   E9                     JP   (hl)   ; If comparison succeeds,jump to the return address
408D                EXPECT1:      
408D   CD A4 05               CALL   print   ; Print the failure message
4090   46 61 69 6C 65 64 21 00 .CSTR   "Failed!"   
4098   2A 5E 40               LD   hl,(tbText)   ; Load the address of the test text
409B   CD B8 05               CALL   printZStr   ; Print the test text
409E   76                     HALT      ; Halt the program
409F                             ; *****************************************************************************
409F                             ; Routine: expectOpData
409F                             ; 
409F                             ; Purpose:
409F                             ;    Validate the sequence of opcode and operands against expected values.
409F                             ;    Print error messages if any mismatch occurs and jump to the next handler.
409F                             ; 
409F                             ; Inputs:
409F                             ;    DE - Points to the expected op data
409F                             ;    HL - Points to the actual op data
409F                             ; 
409F                             ; Outputs:
409F                             ;    Updates DE and HL as it processes each byte in the sequences.
409F                             ; 
409F                             ; Registers Destroyed:
409F                             ;    A,DE,HL
409F                             ; *****************************************************************************
409F                EXPECTOPDATA:      
409F   D1                     POP   de   ; Load DE with the return address pointing to the actual opcode/operand sequence
40A0   21 91 31               LD   hl,vOpcode   ; Load HL with the address of the expected opcode/operand sequence
40A3   CD DB 40               CALL   expectOpItem   ; Compare actual and expected opcode
40A6   57 72 6F 6E 67 20 6F 70 63 6F 64 65 00 .CSTR   "Wrong opcode"   ; Error message if the opcode does not match
40B3   CD DB 40               CALL   expectOpItem   ; Compare actual and expected first operand
40B6   57 72 6F 6E 67 20 6F 70 65 72 61 6E 64 20 31 00 .CSTR   "Wrong operand 1"   ; Error message if the first operand does not match
40C6   CD DB 40               CALL   expectOpItem   ; Compare actual and expected second operand
40C9   57 72 6F 6E 67 20 6F 70 65 72 61 6E 64 20 32 00 .CSTR   "Wrong operand 2"   ; Error message if the second operand does not match
40D9   EB                     EX   de,hl   
40DA   E9                     JP   (hl)   ; Jump to the address after expected op data
40DB                             ; *****************************************************************************
40DB                             ; Routine: expectOpItem
40DB                             ; 
40DB                             ; Purpose:
40DB                             ;    Compare the actual and expected opcode/operand byte and handle mismatches.
40DB                             ; 
40DB                             ; Inputs:
40DB                             ;    DE - Points to the expected byte.
40DB                             ;    HL - Points to the actual byte.
40DB                             ; 
40DB                             ; Outputs:
40DB                             ;    Increments DE and HL to the next byte in the sequences.
40DB                             ;    Prints error messages if any mismatch occurs.
40DB                             ; 
40DB                             ; Registers Destroyed:
40DB                             ;    A,DE,HL
40DB                             ; *****************************************************************************
40DB                EXPECTOPITEM:      
40DB   1A                     LD   a,(de)   ; Load the expected byte into A from DE
40DC   BE                     CP   (hl)   ; Compare expected with actual
40DD   13                     INC   de   ; Move DE to point to next expected byte
40DE   23                     INC   hl   ; Move HL to point to next actual byte
40DF   20 07                  JR   nz,expectOpItem1   ; Return if the bytes match
40E1   E3                     EX   (sp),hl   ; HL = expected string to skip (sp) = actual*
40E2   CD 4D 41               CALL   skipZStr   ; Skip the message string
40E5   23                     INC   hl   ; Move to the next byte after the null terminator
40E6   E3                     EX   (sp),hl   ; HL = actual* (SP) = expected string to skip
40E7   C9                     RET      ; return after message string
40E8                EXPECTOPITEM1:      
40E8   CD 98 05               CALL   crlf   
40EB   CD 98 05               CALL   crlf   
40EE   2A 5C 40               LD   hl,(tbDesc)   ; Load the address of the test text
40F1   CD B8 05               CALL   printZStr   ; Print the test description
40F4   CD 98 05               CALL   crlf   
40F7   CD 98 05               CALL   crlf   
40FA   CD A4 05               CALL   print   ; Print error messages if the bytes do not match
40FD   45 78 70 65 63 74 65 64 3A 20 00 .CSTR   "Expected: "   ; Print "Expected"
4108   1A                     LD   a,(de)   ; Load the expected byte into A for printing
4109   CD 39 41               CALL   printHex2   ; Print the expected byte in hexadecimal
410C   CD 98 05               CALL   crlf   
410F   CD A4 05               CALL   print   ; Print "Received"
4112   41 63 74 75 61 6C 3A 20 00 .CSTR   "Actual: "   
411B   7E                     LD   a,(hl)   ; Load the actual byte into A for printing
411C   CD 39 41               CALL   printHex2   ; Print the actual byte in hexadecimal
411F   CD 98 05               CALL   crlf   
4122   76                     HALT      ; Halt the program
4123                             ; *****************************************************************************
4123                             ; Routine: testGetCharImpl
4123                             ; 
4123                             ; Purpose:
4123                             ;    Retrieves the next character from the test text.
4123                             ; 
4123                             ; Inputs:
4123                             ;    tbPtr - Pointer to the current position in the test text
4123                             ; 
4123                             ; Outputs:
4123                             ;    A - The next character from the test text
4123                             ; 
4123                             ; Registers Destroyed:
4123                             ;    A,HL
4123                             ; *****************************************************************************
4123                TESTGETCHARIMPL:      
4123   E5                     PUSH   hl   ; Save HL register
4124   2A 60 40               LD   hl,(tbPtr)   ; Load the current pointer from tbPtr
4127   7E                     LD   a,(hl)   ; Load the next character from the test text
4128   23                     INC   hl   ; Move to the next character
4129   22 60 40               LD   (tbPtr),hl   ; Update tbPtr with the new pointer
412C   E1                     POP   hl   ; Restore HL register
412D   C9                     RET      ; Return with the character in A
412E                             ; *****************************************************************************
412E                             ; Routine: printHex
412E                             ; 
412E                             ; Purpose:
412E                             ;    Displays the 16-bit value in the HL register as a hexadecimal number.
412E                             ; 
412E                             ; Inputs:
412E                             ;    HL - The 16-bit value to be displayed.
412E                             ; 
412E                             ; Outputs:
412E                             ;    None
412E                             ; 
412E                             ; Registers Destroyed:
412E                             ;    A,C
412E                             ; *****************************************************************************
412E                PRINTHEX:      
412E   C5                     PUSH   bc   ; Preserve the BC register pair
412F   7C                     LD   a,h   ; Load the high byte of HL into A
4130   CD 39 41               CALL   printHex2   ; Print the high byte as hex
4133   7D                     LD   a,l   ; Load the low byte of HL into A
4134   CD 39 41               CALL   printHex2   ; Print the low byte as hex
4137   C1                     POP   bc   ; Restore the BC register pair
4138   C9                     RET      ; Return from the routine
4139                             ; *****************************************************************************
4139                             ; Routine: printHex2
4139                             ; 
4139                             ; Purpose:
4139                             ;    Prints a single byte in hexadecimal format by printing its high and low nibbles.
4139                             ; 
4139                             ; Inputs:
4139                             ;    A - The byte to be printed.
4139                             ; 
4139                             ; Outputs:
4139                             ;    None.
4139                             ; 
4139                             ; Registers Destroyed:
4139                             ;    A,C
4139                             ; *****************************************************************************
4139                PRINTHEX2:      
4139   4F                     LD   c,a   ; Copy the value in A to C
413A   1F                     RRA      ; Shift the high nibble to the low nibble
413B   1F                     RRA      
413C   1F                     RRA      
413D   1F                     RRA      
413E   CD 42 41               CALL   printHex3   ; Print the high nibble as hex
4141   79                     LD   a,c   ; Restore the original value to A
4142                PRINTHEX3:      
4142   E6 0F                  AND   0x0F   ; Mask out the upper nibble
4144   C6 90                  ADD   a,0x90   ; Add 0x90 to adjust for the ASCII range
4146   27                     DAA      ; Decimal adjust A to get the correct ASCII value
4147   CE 40                  ADC   a,0x40   ; Add 0x40 to get the ASCII character for 0-9/A-F
4149   27                     DAA      ; Decimal adjust A to get the correct ASCII value
414A   C3 87 00               JP   putchar   ; Jump to the putchar routine to display the character
414D                             ; 
414D                             ; *****************************************************************************
414D                             ; Routine: skipZStr
414D                             ; 
414D                             ; Purpose:
414D                             ;    Skips over a null-terminated string in memory,advancing the HL register
414D                             ;    to the character following the null terminator.
414D                             ; 
414D                             ; Inputs:
414D                             ;    HL - Points to the start of the string to skip.
414D                             ; 
414D                             ; Outputs:
414D                             ;    HL - Points to the character immediately after the null terminator.
414D                             ; 
414D                             ; Registers Destroyed:
414D                             ;    A
414D                             ; *****************************************************************************
414D                SKIPZSTR:      
414D   18 01                  JR   skipZStr2   ; Jump to the character loading step
414F                SKIPZSTR1:      
414F   23                     INC   hl   ; Move to the next character
4150                SKIPZSTR2:      
4150   7E                     LD   a,(hl)   ; Load the current character
4151   B7                     OR   a   ; Check if the character is null
4152   20 FB                  JR   nz,skipZStr1   ; If not null,continue to the next character
4154   C9                     RET      ; Return when a null character is found
4155                             ; call test
4155                             ; ; .db "label1: LD A,42;comment\r\n"
4155                             ; ; .db "halt"
4155                             ; .db 0


ROMSTART:           0000 DEFINED AT LINE 1 IN constants.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 116 IN IOSerial.asm
                    > USED AT LINE 122 IN IOSerial.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 134 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 146 IN IOSerial.asm
                    > USED AT LINE 152 IN IOSerial.asm
                    > USED AT LINE 158 IN IOSerial.asm
                    > USED AT LINE 200 IN IOSerial.asm
                    > USED AT LINE 17 IN MAIN.asm
RAMSTART:           3000 DEFINED AT LINE 2 IN constants.asm
                    > USED AT LINE 1 IN ram.asm
ROMSIZE:            3000 DEFINED AT LINE 3 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 4 IN constants.asm
EOF:                00-1 DEFINED AT LINE 6 IN constants.asm
                    > USED AT LINE 496 IN MAIN.asm
                    > USED AT LINE 1103 IN MAIN.asm
                    > USED AT LINE 1111 IN MAIN.asm
                    > USED AT LINE 1144 IN MAIN.asm
NULL:               0000 DEFINED AT LINE 7 IN constants.asm
                    > USED AT LINE 425 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 8 IN constants.asm
                    > USED AT LINE 1107 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 9 IN constants.asm
ESC:                001B DEFINED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 1124 IN MAIN.asm
NO_MATCH:           00-1 DEFINED AT LINE 11 IN constants.asm
BUFFER_SIZE:        0080 DEFINED AT LINE 13 IN constants.asm
                    > USED AT LINE 1084 IN MAIN.asm
                    > USED AT LINE 1099 IN MAIN.asm
                    > USED AT LINE 1117 IN MAIN.asm
                    > USED AT LINE 5 IN ram.asm
HEAP_SIZE:          0100 DEFINED AT LINE 14 IN constants.asm
                    > USED AT LINE 39 IN ram.asm
TOKENS:             0000 DEFINED AT LINE 16 IN constants.asm
COLON_:             000: DEFINED AT LINE 18 IN constants.asm
COMMA_:             000, DEFINED AT LINE 19 IN constants.asm
                    > USED AT LINE 204 IN MAIN.asm
                    > USED AT LINE 415 IN MAIN.asm
DOLLAR_:            000$ DEFINED AT LINE 20 IN constants.asm
                    > USED AT LINE 576 IN MAIN.asm
LPAREN_:            000( DEFINED AT LINE 21 IN constants.asm
                    > USED AT LINE 252 IN MAIN.asm
MINUS_:             000- DEFINED AT LINE 22 IN constants.asm
NEWLN_:             000
 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 124 IN MAIN.asm
                    > USED AT LINE 509 IN MAIN.asm
                    > USED AT LINE 866 IN MAIN.asm
PLUS_:              000+ DEFINED AT LINE 24 IN constants.asm
RPAREN_:            000) DEFINED AT LINE 25 IN constants.asm
                    > USED AT LINE 274 IN MAIN.asm
                    > USED AT LINE 412 IN MAIN.asm
EOF_:               0000 DEFINED AT LINE 26 IN constants.asm
                    > USED AT LINE 122 IN MAIN.asm
                    > USED AT LINE 498 IN MAIN.asm
                    > USED AT LINE 864 IN MAIN.asm
DIRECT_:            0001 DEFINED AT LINE 27 IN constants.asm
                    > USED AT LINE 169 IN MAIN.asm
                    > USED AT LINE 560 IN MAIN.asm
IDENT_:             0002 DEFINED AT LINE 28 IN constants.asm
                    > USED AT LINE 564 IN MAIN.asm
LABEL_:             0003 DEFINED AT LINE 29 IN constants.asm
                    > USED AT LINE 158 IN MAIN.asm
                    > USED AT LINE 533 IN MAIN.asm
NUM_:               0004 DEFINED AT LINE 30 IN constants.asm
                    > USED AT LINE 583 IN MAIN.asm
                    > USED AT LINE 593 IN MAIN.asm
OPCODE_:            0005 DEFINED AT LINE 31 IN constants.asm
                    > USED AT LINE 166 IN MAIN.asm
                    > USED AT LINE 543 IN MAIN.asm
OPELEM_:            0006 DEFINED AT LINE 32 IN constants.asm
                    > USED AT LINE 249 IN MAIN.asm
                    > USED AT LINE 262 IN MAIN.asm
                    > USED AT LINE 551 IN MAIN.asm
UNKNOWN_:           0064 DEFINED AT LINE 33 IN constants.asm
                    > USED AT LINE 607 IN MAIN.asm
ALU_:               0000 DEFINED AT LINE 35 IN constants.asm
                    > USED AT LINE 43 IN constants.asm
                    > USED AT LINE 44 IN constants.asm
                    > USED AT LINE 45 IN constants.asm
                    > USED AT LINE 46 IN constants.asm
                    > USED AT LINE 47 IN constants.asm
                    > USED AT LINE 48 IN constants.asm
                    > USED AT LINE 49 IN constants.asm
                    > USED AT LINE 50 IN constants.asm
ROT_:               0020 DEFINED AT LINE 36 IN constants.asm
                    > USED AT LINE 54 IN constants.asm
                    > USED AT LINE 55 IN constants.asm
                    > USED AT LINE 56 IN constants.asm
                    > USED AT LINE 57 IN constants.asm
                    > USED AT LINE 58 IN constants.asm
                    > USED AT LINE 59 IN constants.asm
                    > USED AT LINE 60 IN constants.asm
                    > USED AT LINE 61 IN constants.asm
BLI_:               0040 DEFINED AT LINE 37 IN constants.asm
                    > USED AT LINE 65 IN constants.asm
                    > USED AT LINE 66 IN constants.asm
                    > USED AT LINE 67 IN constants.asm
                    > USED AT LINE 68 IN constants.asm
                    > USED AT LINE 69 IN constants.asm
                    > USED AT LINE 70 IN constants.asm
                    > USED AT LINE 71 IN constants.asm
                    > USED AT LINE 72 IN constants.asm
                    > USED AT LINE 73 IN constants.asm
                    > USED AT LINE 74 IN constants.asm
                    > USED AT LINE 75 IN constants.asm
                    > USED AT LINE 76 IN constants.asm
                    > USED AT LINE 77 IN constants.asm
                    > USED AT LINE 78 IN constants.asm
                    > USED AT LINE 79 IN constants.asm
                    > USED AT LINE 80 IN constants.asm
GEN1_:              0060 DEFINED AT LINE 38 IN constants.asm
                    > USED AT LINE 84 IN constants.asm
                    > USED AT LINE 85 IN constants.asm
                    > USED AT LINE 86 IN constants.asm
                    > USED AT LINE 87 IN constants.asm
                    > USED AT LINE 88 IN constants.asm
                    > USED AT LINE 89 IN constants.asm
                    > USED AT LINE 90 IN constants.asm
                    > USED AT LINE 91 IN constants.asm
                    > USED AT LINE 93 IN constants.asm
GEN2_:              0080 DEFINED AT LINE 39 IN constants.asm
                    > USED AT LINE 92 IN constants.asm
                    > USED AT LINE 97 IN constants.asm
                    > USED AT LINE 98 IN constants.asm
                    > USED AT LINE 99 IN constants.asm
                    > USED AT LINE 100 IN constants.asm
                    > USED AT LINE 101 IN constants.asm
                    > USED AT LINE 102 IN constants.asm
                    > USED AT LINE 103 IN constants.asm
                    > USED AT LINE 104 IN constants.asm
                    > USED AT LINE 105 IN constants.asm
                    > USED AT LINE 106 IN constants.asm
                    > USED AT LINE 107 IN constants.asm
                    > USED AT LINE 108 IN constants.asm
                    > USED AT LINE 109 IN constants.asm
                    > USED AT LINE 110 IN constants.asm
                    > USED AT LINE 111 IN constants.asm
                    > USED AT LINE 112 IN constants.asm
                    > USED AT LINE 113 IN constants.asm
                    > USED AT LINE 114 IN constants.asm
                    > USED AT LINE 115 IN constants.asm
                    > USED AT LINE 116 IN constants.asm
                    > USED AT LINE 117 IN constants.asm
                    > USED AT LINE 118 IN constants.asm
                    > USED AT LINE 119 IN constants.asm
                    > USED AT LINE 120 IN constants.asm
                    > USED AT LINE 121 IN constants.asm
                    > USED AT LINE 122 IN constants.asm
ALU_IDX:            0000 DEFINED AT LINE 41 IN constants.asm
ADD_:               0000 DEFINED AT LINE 43 IN constants.asm
ADC_:               0001 DEFINED AT LINE 44 IN constants.asm
SUB_:               0002 DEFINED AT LINE 45 IN constants.asm
SBC_:               0003 DEFINED AT LINE 46 IN constants.asm
AND_:               0004 DEFINED AT LINE 47 IN constants.asm
XOR_:               0005 DEFINED AT LINE 48 IN constants.asm
OR_:                0006 DEFINED AT LINE 49 IN constants.asm
CP_:                0007 DEFINED AT LINE 50 IN constants.asm
ROT_IDX:            0000 DEFINED AT LINE 52 IN constants.asm
RLC_:               0020 DEFINED AT LINE 54 IN constants.asm
RRC_:               0021 DEFINED AT LINE 55 IN constants.asm
RL_:                0022 DEFINED AT LINE 56 IN constants.asm
RR_:                0023 DEFINED AT LINE 57 IN constants.asm
SLA_:               0024 DEFINED AT LINE 58 IN constants.asm
SRA_:               0025 DEFINED AT LINE 59 IN constants.asm
SLL_:               0026 DEFINED AT LINE 60 IN constants.asm
SRL_:               0027 DEFINED AT LINE 61 IN constants.asm
BLI_IDX:            0000 DEFINED AT LINE 63 IN constants.asm
LDI_:               0040 DEFINED AT LINE 65 IN constants.asm
CPI_:               0041 DEFINED AT LINE 66 IN constants.asm
INI_:               0042 DEFINED AT LINE 67 IN constants.asm
OUTI_:              0043 DEFINED AT LINE 68 IN constants.asm
LDD_:               0044 DEFINED AT LINE 69 IN constants.asm
CPD_:               0045 DEFINED AT LINE 70 IN constants.asm
IND_:               0046 DEFINED AT LINE 71 IN constants.asm
OUTD_:              0047 DEFINED AT LINE 72 IN constants.asm
LDIR_:              0048 DEFINED AT LINE 73 IN constants.asm
CPIR_:              0049 DEFINED AT LINE 74 IN constants.asm
INIR_:              004A DEFINED AT LINE 75 IN constants.asm
OTIR_:              004B DEFINED AT LINE 76 IN constants.asm
LDDR_:              004C DEFINED AT LINE 77 IN constants.asm
CPDR_:              004D DEFINED AT LINE 78 IN constants.asm
INDR_:              004E DEFINED AT LINE 79 IN constants.asm
OTDR_:              004F DEFINED AT LINE 80 IN constants.asm
GEN1_IDX:           0000 DEFINED AT LINE 82 IN constants.asm
CCF_:               0060 DEFINED AT LINE 84 IN constants.asm
CPL_:               0061 DEFINED AT LINE 85 IN constants.asm
DAA_:               0062 DEFINED AT LINE 86 IN constants.asm
DI_:                0063 DEFINED AT LINE 87 IN constants.asm
EI_:                0064 DEFINED AT LINE 88 IN constants.asm
HALT_:              0065 DEFINED AT LINE 89 IN constants.asm
NOP_:               0066 DEFINED AT LINE 90 IN constants.asm
RLCA_:              0067 DEFINED AT LINE 91 IN constants.asm
RST_:               0088 DEFINED AT LINE 92 IN constants.asm
SCF_:               0069 DEFINED AT LINE 93 IN constants.asm
GEN2_IDX:           0000 DEFINED AT LINE 95 IN constants.asm
BIT_:               0080 DEFINED AT LINE 97 IN constants.asm
CALL_:              0081 DEFINED AT LINE 98 IN constants.asm
DEC_:               0082 DEFINED AT LINE 99 IN constants.asm
DJNZ_:              0083 DEFINED AT LINE 100 IN constants.asm
EX_:                0084 DEFINED AT LINE 101 IN constants.asm
EXX_:               0085 DEFINED AT LINE 102 IN constants.asm
IM_:                0086 DEFINED AT LINE 103 IN constants.asm
IN_:                0087 DEFINED AT LINE 104 IN constants.asm
INC_:               0088 DEFINED AT LINE 105 IN constants.asm
JP_:                0089 DEFINED AT LINE 106 IN constants.asm
                    > USED AT LINE 75
JR_:                008A DEFINED AT LINE 107 IN constants.asm
LD_:                008B DEFINED AT LINE 108 IN constants.asm
NEG_:               008C DEFINED AT LINE 109 IN constants.asm
OUT_:               008D DEFINED AT LINE 110 IN constants.asm
POP_:               008E DEFINED AT LINE 111 IN constants.asm
PUSH_:              008F DEFINED AT LINE 112 IN constants.asm
RES_:               0090 DEFINED AT LINE 113 IN constants.asm
RET_:               0091 DEFINED AT LINE 114 IN constants.asm
RETI_:              0092 DEFINED AT LINE 115 IN constants.asm
RETN_:              0093 DEFINED AT LINE 116 IN constants.asm
RLA_:               0094 DEFINED AT LINE 117 IN constants.asm
RLD_:               0095 DEFINED AT LINE 118 IN constants.asm
RRA_:               0096 DEFINED AT LINE 119 IN constants.asm
RRCA_:              0097 DEFINED AT LINE 120 IN constants.asm
RRD_:               0098 DEFINED AT LINE 121 IN constants.asm
SET_:               0003 DEFINED AT LINE 172 IN constants.asm
REG_:               0000 DEFINED AT LINE 124 IN constants.asm
RP_:                0008 DEFINED AT LINE 125 IN constants.asm
                    > USED AT LINE 147 IN constants.asm
                    > USED AT LINE 148 IN constants.asm
                    > USED AT LINE 149 IN constants.asm
                    > USED AT LINE 150 IN constants.asm
                    > USED AT LINE 151 IN constants.asm
                    > USED AT LINE 152 IN constants.asm
                    > USED AT LINE 153 IN constants.asm
                    > USED AT LINE 154 IN constants.asm
FLAG_:              0010 DEFINED AT LINE 126 IN constants.asm
                    > USED AT LINE 158 IN constants.asm
                    > USED AT LINE 159 IN constants.asm
                    > USED AT LINE 160 IN constants.asm
                    > USED AT LINE 161 IN constants.asm
                    > USED AT LINE 162 IN constants.asm
                    > USED AT LINE 163 IN constants.asm
                    > USED AT LINE 164 IN constants.asm
                    > USED AT LINE 165 IN constants.asm
IMMED_:             0018 DEFINED AT LINE 127 IN constants.asm
                    > USED AT LINE 257 IN MAIN.asm
                    > USED AT LINE 270 IN MAIN.asm
MEM_:               0020 DEFINED AT LINE 128 IN constants.asm
                    > USED AT LINE 270 IN MAIN.asm
                    > USED AT LINE 327 IN MAIN.asm
                    > USED AT LINE 333 IN MAIN.asm
                    > USED AT LINE 339 IN MAIN.asm
                    > USED AT LINE 343 IN MAIN.asm
INDX_:              0080 DEFINED AT LINE 129 IN constants.asm
                    > USED AT LINE 298 IN MAIN.asm
                    > USED AT LINE 333 IN MAIN.asm
INDY_:              00C0 DEFINED AT LINE 130 IN constants.asm
                    > USED AT LINE 304 IN MAIN.asm
                    > USED AT LINE 339 IN MAIN.asm
REG8_IDX:           0000 DEFINED AT LINE 132 IN constants.asm
B_:                 0000 DEFINED AT LINE 134 IN constants.asm
C_:                 0013 DEFINED AT LINE 161 IN constants.asm
D_:                 0002 DEFINED AT LINE 136 IN constants.asm
E_:                 0003 DEFINED AT LINE 137 IN constants.asm
H_:                 0004 DEFINED AT LINE 138 IN constants.asm
L_:                 0005 DEFINED AT LINE 139 IN constants.asm
MHL_:               0006 DEFINED AT LINE 140 IN constants.asm
                    > USED AT LINE 327 IN MAIN.asm
                    > USED AT LINE 333 IN MAIN.asm
                    > USED AT LINE 339 IN MAIN.asm
A_:                 0007 DEFINED AT LINE 141 IN constants.asm
I_:                 0008 DEFINED AT LINE 142 IN constants.asm
R_:                 0009 DEFINED AT LINE 143 IN constants.asm
REG16_IDX:          0000 DEFINED AT LINE 145 IN constants.asm
BC_:                0008 DEFINED AT LINE 147 IN constants.asm
DE_:                0009 DEFINED AT LINE 148 IN constants.asm
HL_:                000A DEFINED AT LINE 149 IN constants.asm
                    > USED AT LINE 298 IN MAIN.asm
                    > USED AT LINE 304 IN MAIN.asm
                    > USED AT LINE 325 IN MAIN.asm
SP_:                000B DEFINED AT LINE 150 IN constants.asm
IX_:                000D DEFINED AT LINE 151 IN constants.asm
                    > USED AT LINE 296 IN MAIN.asm
                    > USED AT LINE 331 IN MAIN.asm
                    > USED AT LINE 886 IN MAIN.asm
IY_:                000E DEFINED AT LINE 152 IN constants.asm
                    > USED AT LINE 302 IN MAIN.asm
                    > USED AT LINE 337 IN MAIN.asm
                    > USED AT LINE 888 IN MAIN.asm
AFP_:               000C DEFINED AT LINE 153 IN constants.asm
AF_:                000F DEFINED AT LINE 154 IN constants.asm
FLAG_IDX:           0000 DEFINED AT LINE 156 IN constants.asm
NZ_:                0010 DEFINED AT LINE 158 IN constants.asm
                    > USED AT LINE 75
Z_:                 0011 DEFINED AT LINE 159 IN constants.asm
NC_:                0012 DEFINED AT LINE 160 IN constants.asm
PO_:                0014 DEFINED AT LINE 162 IN constants.asm
PE_:                0015 DEFINED AT LINE 163 IN constants.asm
P_:                 0016 DEFINED AT LINE 164 IN constants.asm
M_:                 0017 DEFINED AT LINE 165 IN constants.asm
DIRECTIVE_IDX:      0000 DEFINED AT LINE 167 IN constants.asm
ALIGN_:             0000 DEFINED AT LINE 169 IN constants.asm
DB_:                0001 DEFINED AT LINE 170 IN constants.asm
ORG_:               0002 DEFINED AT LINE 171 IN constants.asm
TEC_1:              0001 DEFINED AT LINE 176 IN constants.asm
RC2014:             0000 DEFINED AT LINE 177 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 179 IN constants.asm
LOADER:             0000 DEFINED AT LINE 181 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 182 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 33 IN IOSerial.asm
                    > USED AT LINE 478 IN IOSerial.asm
                    > USED AT LINE 500 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 34 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 322 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 36 IN IOSerial.asm
                    > USED AT LINE 326 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 477 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 46 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 50 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 51 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 52 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 53 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 54 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 55 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 56 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 57 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 61 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 62 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 63 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 64 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 68 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 72 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 73 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 74 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 75 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 76 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 77 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 78 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 79 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 87 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 88 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 89 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 90 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 91 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 92 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 93 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 94 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 108 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 109 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 113 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 163 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 483 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 187 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 193 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 196 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 471 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 305 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 308 IN IOSerial.asm
                    > USED AT LINE 312 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 320 IN IOSerial.asm
                    > USED AT LINE 469 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 321 IN IOSerial.asm
                    > USED AT LINE 325 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 445 IN IOSerial.asm
                    > USED AT LINE 1102 IN MAIN.asm
PUTCHAR:            0087 DEFINED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 1128 IN MAIN.asm
                    > USED AT LINE 1290 IN MAIN.asm
                    > USED AT LINE 1315 IN MAIN.asm
                    > USED AT LINE 258 IN test.lib.asm
RESET:              008D DEFINED AT LINE 457 IN IOSerial.asm
                    > USED AT LINE 114 IN IOSerial.asm
START:              0180 DEFINED AT LINE 36 IN MAIN.asm
INIT:               0198 DEFINED AT LINE 59 IN MAIN.asm
                    > USED AT LINE 38 IN MAIN.asm
                    > USED AT LINE 58 IN test.lib.asm
PARSE:              01BD DEFINED AT LINE 92 IN MAIN.asm
                    > USED AT LINE 41 IN MAIN.asm
PARSEERROR:         01E4 DEFINED AT LINE 98 IN MAIN.asm
                    > USED AT LINE 125 IN MAIN.asm
                    > USED AT LINE 209 IN MAIN.asm
                    > USED AT LINE 215 IN MAIN.asm
                    > USED AT LINE 275 IN MAIN.asm
STATEMENTLIST:      01F7 DEFINED AT LINE 119 IN MAIN.asm
                    > USED AT LINE 93 IN MAIN.asm
                    > USED AT LINE 126 IN MAIN.asm
                    > USED AT LINE 61 IN test.lib.asm
STATEMENT:          0206 DEFINED AT LINE 145 IN MAIN.asm
                    > USED AT LINE 121 IN MAIN.asm
STATEMENT1:         022C DEFINED AT LINE 165 IN MAIN.asm
                    > USED AT LINE 159 IN MAIN.asm
INSTRUCTION:        0235 DEFINED AT LINE 194 IN MAIN.asm
                    > USED AT LINE 167 IN MAIN.asm
INSTRUCTION1:       0264 DEFINED AT LINE 218 IN MAIN.asm
                    > USED AT LINE 205 IN MAIN.asm
DIRECTIVE:          0272 DEFINED AT LINE 227 IN MAIN.asm
                    > USED AT LINE 170 IN MAIN.asm
OPERAND:            0273 DEFINED AT LINE 248 IN MAIN.asm
                    > USED AT LINE 201 IN MAIN.asm
                    > USED AT LINE 211 IN MAIN.asm
OPERAND1:           0284 DEFINED AT LINE 260 IN MAIN.asm
                    > USED AT LINE 253 IN MAIN.asm
OPERAND2:           0290 DEFINED AT LINE 267 IN MAIN.asm
                    > USED AT LINE 263 IN MAIN.asm
OPERAND7:           0298 DEFINED AT LINE 272 IN MAIN.asm
                    > USED AT LINE 265 IN MAIN.asm
OPELEMENT:          02A1 DEFINED AT LINE 294 IN MAIN.asm
                    > USED AT LINE 250 IN MAIN.asm
OPELEMENT2:         02A9 DEFINED AT LINE 301 IN MAIN.asm
                    > USED AT LINE 297 IN MAIN.asm
REGPAIRINDIRECT:    02AF DEFINED AT LINE 323 IN MAIN.asm
                    > USED AT LINE 264 IN MAIN.asm
REGPAIRINDIRECT2:   02B7 DEFINED AT LINE 330 IN MAIN.asm
                    > USED AT LINE 326 IN MAIN.asm
REGPAIRINDIRECT3:   02BF DEFINED AT LINE 336 IN MAIN.asm
                    > USED AT LINE 332 IN MAIN.asm
REGPAIRINDIRECT4:   02C7 DEFINED AT LINE 342 IN MAIN.asm
                    > USED AT LINE 338 IN MAIN.asm
REGPAIRINDIRECT5:   02CA DEFINED AT LINE 346 IN MAIN.asm
                    > USED AT LINE 334 IN MAIN.asm
                    > USED AT LINE 340 IN MAIN.asm
EXPRESSION:         02D3 DEFINED AT LINE 373 IN MAIN.asm
                    > USED AT LINE 255 IN MAIN.asm
                    > USED AT LINE 268 IN MAIN.asm
                    > USED AT LINE 348 IN MAIN.asm
EXPRESSION1:        02EE DEFINED AT LINE 385 IN MAIN.asm
                    > USED AT LINE 397 IN MAIN.asm
                    > USED AT LINE 409 IN MAIN.asm
                    > USED AT LINE 421 IN MAIN.asm
EXPRESSION2:        0306 DEFINED AT LINE 399 IN MAIN.asm
                    > USED AT LINE 394 IN MAIN.asm
EXPRESSION3:        0314 DEFINED AT LINE 411 IN MAIN.asm
                    > USED AT LINE 402 IN MAIN.asm
                    > USED AT LINE 405 IN MAIN.asm
EXPRESSION4:        0323 DEFINED AT LINE 423 IN MAIN.asm
                    > USED AT LINE 413 IN MAIN.asm
                    > USED AT LINE 416 IN MAIN.asm
                    > USED AT LINE 419 IN MAIN.asm
ADDSYMBOL:          0332 DEFINED AT LINE 450 IN MAIN.asm
                    > USED AT LINE 162 IN MAIN.asm
NEXTTOKEN:          034B DEFINED AT LINE 481 IN MAIN.asm
                    > USED AT LINE 120 IN MAIN.asm
                    > USED AT LINE 163 IN MAIN.asm
                    > USED AT LINE 197 IN MAIN.asm
                    > USED AT LINE 203 IN MAIN.asm
                    > USED AT LINE 207 IN MAIN.asm
                    > USED AT LINE 213 IN MAIN.asm
                    > USED AT LINE 261 IN MAIN.asm
                    > USED AT LINE 273 IN MAIN.asm
                    > USED AT LINE 392 IN MAIN.asm
                    > USED AT LINE 396 IN MAIN.asm
                    > USED AT LINE 408 IN MAIN.asm
NEXTTOKEN1:         035B DEFINED AT LINE 491 IN MAIN.asm
                    > USED AT LINE 485 IN MAIN.asm
                    > USED AT LINE 495 IN MAIN.asm
                    > USED AT LINE 521 IN MAIN.asm
NEXTTOKEN2:         036C DEFINED AT LINE 501 IN MAIN.asm
                    > USED AT LINE 497 IN MAIN.asm
NEXTTOKEN2A:        0378 DEFINED AT LINE 508 IN MAIN.asm
                    > USED AT LINE 503 IN MAIN.asm
                    > USED AT LINE 505 IN MAIN.asm
NEXTTOKEN3:         037B DEFINED AT LINE 512 IN MAIN.asm
                    > USED AT LINE 507 IN MAIN.asm
NEXTTOKEN4:         037F DEFINED AT LINE 516 IN MAIN.asm
                    > USED AT LINE 519 IN MAIN.asm
NEXTTOKEN5:         038B DEFINED AT LINE 523 IN MAIN.asm
                    > USED AT LINE 514 IN MAIN.asm
NEXTTOKEN6:         0394 DEFINED AT LINE 529 IN MAIN.asm
                    > USED AT LINE 525 IN MAIN.asm
NEXTTOKEN7:         039E DEFINED AT LINE 536 IN MAIN.asm
                    > USED AT LINE 532 IN MAIN.asm
NEXTTOKEN8:         03AF DEFINED AT LINE 546 IN MAIN.asm
                    > USED AT LINE 540 IN MAIN.asm
NEXTTOKEN9:         03BA DEFINED AT LINE 554 IN MAIN.asm
                    > USED AT LINE 548 IN MAIN.asm
NEXTTOKEN10:        03C8 DEFINED AT LINE 563 IN MAIN.asm
                    > USED AT LINE 557 IN MAIN.asm
NEXTTOKEN11:        03CB DEFINED AT LINE 567 IN MAIN.asm
                    > USED AT LINE 527 IN MAIN.asm
NEXTTOKEN12:        03E0 DEFINED AT LINE 579 IN MAIN.asm
                    > USED AT LINE 573 IN MAIN.asm
NEXTTOKEN13:        03EC DEFINED AT LINE 586 IN MAIN.asm
                    > USED AT LINE 570 IN MAIN.asm
NEXTTOKEN14:        03FD DEFINED AT LINE 596 IN MAIN.asm
                    > USED AT LINE 588 IN MAIN.asm
PUSHBACKTOKEN:      040F DEFINED AT LINE 628 IN MAIN.asm
                    > USED AT LINE 428 IN MAIN.asm
IDENT:              0418 DEFINED AT LINE 656 IN MAIN.asm
                    > USED AT LINE 530 IN MAIN.asm
IDENT1:             041D DEFINED AT LINE 660 IN MAIN.asm
                    > USED AT LINE 667 IN MAIN.asm
                    > USED AT LINE 669 IN MAIN.asm
IDENT3:             042D DEFINED AT LINE 670 IN MAIN.asm
SEARCHSTR:          0438 DEFINED AT LINE 700 IN MAIN.asm
                    > USED AT LINE 556 IN MAIN.asm
                    > USED AT LINE 746 IN MAIN.asm
                    > USED AT LINE 750 IN MAIN.asm
                    > USED AT LINE 755 IN MAIN.asm
                    > USED AT LINE 760 IN MAIN.asm
                    > USED AT LINE 766 IN MAIN.asm
                    > USED AT LINE 792 IN MAIN.asm
                    > USED AT LINE 796 IN MAIN.asm
                    > USED AT LINE 801 IN MAIN.asm
SEARCHSTR1:         043A DEFINED AT LINE 703 IN MAIN.asm
                    > USED AT LINE 722 IN MAIN.asm
SEARCHSTR3:         0441 DEFINED AT LINE 709 IN MAIN.asm
                    > USED AT LINE 705 IN MAIN.asm
SEARCHOPCODE:       0450 DEFINED AT LINE 744 IN MAIN.asm
                    > USED AT LINE 539 IN MAIN.asm
SEARCHOPELEM:       047D DEFINED AT LINE 790 IN MAIN.asm
                    > USED AT LINE 547 IN MAIN.asm
COMPARESTR:         0496 DEFINED AT LINE 825 IN MAIN.asm
                    > USED AT LINE 704 IN MAIN.asm
                    > USED AT LINE 83 IN test.lib.asm
COMPARESTR2:        049C DEFINED AT LINE 833 IN MAIN.asm
                    > USED AT LINE 839 IN MAIN.asm
COMPARESTR3:        04A4 DEFINED AT LINE 841 IN MAIN.asm
                    > USED AT LINE 836 IN MAIN.asm
ISENDOFLINE:        04A8 DEFINED AT LINE 863 IN MAIN.asm
                    > USED AT LINE 146 IN MAIN.asm
                    > USED AT LINE 198 IN MAIN.asm
                    > USED AT LINE 208 IN MAIN.asm
                    > USED AT LINE 214 IN MAIN.asm
                    > USED AT LINE 418 IN MAIN.asm
ISINDEXREG:         04AE DEFINED AT LINE 885 IN MAIN.asm
ISALPHANUM:         04B4 DEFINED AT LINE 911 IN MAIN.asm
                    > USED AT LINE 572 IN MAIN.asm
                    > USED AT LINE 668 IN MAIN.asm
ISALPHA:            04B8 DEFINED AT LINE 935 IN MAIN.asm
                    > USED AT LINE 526 IN MAIN.asm
ISALPHA1:           04C3 DEFINED AT LINE 943 IN MAIN.asm
                    > USED AT LINE 939 IN MAIN.asm
ISDIGIT:            04CA DEFINED AT LINE 967 IN MAIN.asm
                    > USED AT LINE 587 IN MAIN.asm
                    > USED AT LINE 912 IN MAIN.asm
DECIMAL:            04D1 DEFINED AT LINE 990 IN MAIN.asm
                    > USED AT LINE 591 IN MAIN.asm
DECIMAL1:           04D4 DEFINED AT LINE 992 IN MAIN.asm
                    > USED AT LINE 1013 IN MAIN.asm
HEXADECIMAL:        04F0 DEFINED AT LINE 1031 IN MAIN.asm
                    > USED AT LINE 581 IN MAIN.asm
HEXADECIMAL1:       04F3 DEFINED AT LINE 1033 IN MAIN.asm
                    > USED AT LINE 1062 IN MAIN.asm
HEXADECIMAL2:       0505 DEFINED AT LINE 1044 IN MAIN.asm
                    > USED AT LINE 1042 IN MAIN.asm
HEXADECIMAL3:       050C DEFINED AT LINE 1049 IN MAIN.asm
                    > USED AT LINE 1048 IN MAIN.asm
HEXADECIMAL4:       050E DEFINED AT LINE 1051 IN MAIN.asm
                    > USED AT LINE 1040 IN MAIN.asm
NEXTCHAR:           051D DEFINED AT LINE 1081 IN MAIN.asm
                    > USED AT LINE 492 IN MAIN.asm
                    > USED AT LINE 517 IN MAIN.asm
                    > USED AT LINE 571 IN MAIN.asm
                    > USED AT LINE 664 IN MAIN.asm
                    > USED AT LINE 995 IN MAIN.asm
                    > USED AT LINE 1035 IN MAIN.asm
                    > USED AT LINE 1153 IN MAIN.asm
NEXTLINE:           0534 DEFINED AT LINE 1097 IN MAIN.asm
                    > USED AT LINE 1085 IN MAIN.asm
NEXTLINE1:          0539 DEFINED AT LINE 1101 IN MAIN.asm
                    > USED AT LINE 1119 IN MAIN.asm
                    > USED AT LINE 1125 IN MAIN.asm
                    > USED AT LINE 1148 IN MAIN.asm
NEXTLINE2:          0547 DEFINED AT LINE 1110 IN MAIN.asm
                    > USED AT LINE 1106 IN MAIN.asm
NEXTLINE3:          054B DEFINED AT LINE 1114 IN MAIN.asm
                    > USED AT LINE 1108 IN MAIN.asm
NEXTLINE4:          055F DEFINED AT LINE 1127 IN MAIN.asm
                    > USED AT LINE 1116 IN MAIN.asm
NEXTLINE5:          056A DEFINED AT LINE 1135 IN MAIN.asm
                    > USED AT LINE 1131 IN MAIN.asm
NEXTLINE6:          0572 DEFINED AT LINE 1141 IN MAIN.asm
                    > USED AT LINE 1104 IN MAIN.asm
                    > USED AT LINE 1112 IN MAIN.asm
                    > USED AT LINE 1133 IN MAIN.asm
                    > USED AT LINE 1137 IN MAIN.asm
                    > USED AT LINE 1139 IN MAIN.asm
NEXTLINE7:          057E DEFINED AT LINE 1150 IN MAIN.asm
                    > USED AT LINE 1145 IN MAIN.asm
                    > USED AT LINE 1147 IN MAIN.asm
REWINDCHAR:         0585 DEFINED AT LINE 1172 IN MAIN.asm
                    > USED AT LINE 520 IN MAIN.asm
                    > USED AT LINE 537 IN MAIN.asm
                    > USED AT LINE 575 IN MAIN.asm
                    > USED AT LINE 580 IN MAIN.asm
                    > USED AT LINE 582 IN MAIN.asm
                    > USED AT LINE 590 IN MAIN.asm
                    > USED AT LINE 592 IN MAIN.asm
PROMPT:             058F DEFINED AT LINE 1196 IN MAIN.asm
CRLF:               0598 DEFINED AT LINE 1217 IN MAIN.asm
                    > USED AT LINE 159 IN test.lib.asm
                    > USED AT LINE 160 IN test.lib.asm
                    > USED AT LINE 163 IN test.lib.asm
                    > USED AT LINE 164 IN test.lib.asm
                    > USED AT LINE 169 IN test.lib.asm
                    > USED AT LINE 174 IN test.lib.asm
ERROR:              059F DEFINED AT LINE 1238 IN MAIN.asm
PRINT:              05A4 DEFINED AT LINE 1259 IN MAIN.asm
                    > USED AT LINE 39 IN MAIN.asm
                    > USED AT LINE 94 IN MAIN.asm
                    > USED AT LINE 1123 IN MAIN.asm
                    > USED AT LINE 1197 IN MAIN.asm
                    > USED AT LINE 1218 IN MAIN.asm
                    > USED AT LINE 83
                    > USED AT LINE 88 IN test.lib.asm
                    > USED AT LINE 165 IN test.lib.asm
                    > USED AT LINE 170 IN test.lib.asm
PRINTSTR:           05AB DEFINED AT LINE 1282 IN MAIN.asm
                    > USED AT LINE 1240 IN MAIN.asm
PRINTSTR1:          05B0 DEFINED AT LINE 1288 IN MAIN.asm
                    > USED AT LINE 1292 IN MAIN.asm
PRINTZSTR:          05B8 DEFINED AT LINE 1311 IN MAIN.asm
                    > USED AT LINE 1261 IN MAIN.asm
                    > USED AT LINE 91 IN test.lib.asm
                    > USED AT LINE 162 IN test.lib.asm
PRINTZSTR1:         05BA DEFINED AT LINE 1314 IN MAIN.asm
                    > USED AT LINE 1321 IN MAIN.asm
PRINTZSTR2:         05BE DEFINED AT LINE 1318 IN MAIN.asm
                    > USED AT LINE 1312 IN MAIN.asm
HPUSH:              05C3 DEFINED AT LINE 1340 IN MAIN.asm
                    > USED AT LINE 378 IN MAIN.asm
                    > USED AT LINE 380 IN MAIN.asm
                    > USED AT LINE 381 IN MAIN.asm
                    > USED AT LINE 389 IN MAIN.asm
                    > USED AT LINE 391 IN MAIN.asm
                    > USED AT LINE 426 IN MAIN.asm
                    > USED AT LINE 455 IN MAIN.asm
                    > USED AT LINE 458 IN MAIN.asm
                    > USED AT LINE 460 IN MAIN.asm
ROT_OPCODES:        05D1 DEFINED AT LINE 1 IN data.asm
                    > USED AT LINE 749 IN MAIN.asm
ALU_OPCODES:        05F0 DEFINED AT LINE 13 IN data.asm
                    > USED AT LINE 745 IN MAIN.asm
BLI_OPCODES:        060F DEFINED AT LINE 25 IN data.asm
                    > USED AT LINE 754 IN MAIN.asm
GEN1_OPCODES:       065A DEFINED AT LINE 45 IN data.asm
                    > USED AT LINE 759 IN MAIN.asm
GEN2_OPCODES:       0683 DEFINED AT LINE 59 IN data.asm
                    > USED AT LINE 765 IN MAIN.asm
REG8:               06EC DEFINED AT LINE 89 IN data.asm
                    > USED AT LINE 791 IN MAIN.asm
REG16:              0701 DEFINED AT LINE 103 IN data.asm
                    > USED AT LINE 795 IN MAIN.asm
FLAGS:              071B DEFINED AT LINE 115 IN data.asm
                    > USED AT LINE 800 IN MAIN.asm
DIRECTIVES:         0730 DEFINED AT LINE 127 IN data.asm
                    > USED AT LINE 555 IN MAIN.asm
BUFFER:             3000 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 68 IN MAIN.asm
                    > USED AT LINE 1086 IN MAIN.asm
                    > USED AT LINE 1098 IN MAIN.asm
STACK:              3180 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 458 IN IOSerial.asm
                    > USED AT LINE 37 IN MAIN.asm
                    > USED AT LINE 15
VTEMP1:             3180 DEFINED AT LINE 9 IN ram.asm
VTEMP2:             3182 DEFINED AT LINE 10 IN ram.asm
VTOKEN:             3184 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 65 IN MAIN.asm
                    > USED AT LINE 482 IN MAIN.asm
                    > USED AT LINE 630 IN MAIN.asm
VTOKENVAL:          3185 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 61 IN MAIN.asm
                    > USED AT LINE 488 IN MAIN.asm
                    > USED AT LINE 631 IN MAIN.asm
VBUFFERPOS:         3187 DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 66 IN MAIN.asm
                    > USED AT LINE 1082 IN MAIN.asm
                    > USED AT LINE 1151 IN MAIN.asm
                    > USED AT LINE 1173 IN MAIN.asm
                    > USED AT LINE 1177 IN MAIN.asm
VASMPTR:            3189 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 72 IN MAIN.asm
                    > USED AT LINE 161 IN MAIN.asm
VSYMPTR:            318B DEFINED AT LINE 16 IN ram.asm
                    > USED AT LINE 62 IN MAIN.asm
                    > USED AT LINE 454 IN MAIN.asm
                    > USED AT LINE 456 IN MAIN.asm
VEXPRPTR:           318D DEFINED AT LINE 17 IN ram.asm
                    > USED AT LINE 63 IN MAIN.asm
                    > USED AT LINE 377 IN MAIN.asm
                    > USED AT LINE 382 IN MAIN.asm
                    > USED AT LINE 429 IN MAIN.asm
VHEAPPTR:           318F DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 70 IN MAIN.asm
                    > USED AT LINE 376 IN MAIN.asm
                    > USED AT LINE 453 IN MAIN.asm
                    > USED AT LINE 538 IN MAIN.asm
                    > USED AT LINE 657 IN MAIN.asm
                    > USED AT LINE 671 IN MAIN.asm
                    > USED AT LINE 1343 IN MAIN.asm
                    > USED AT LINE 1348 IN MAIN.asm
VOPCODE:            3191 DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 151 IN MAIN.asm
                    > USED AT LINE 196 IN MAIN.asm
                    > USED AT LINE 114 IN test.lib.asm
VOPERAND1:          3192 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 152 IN MAIN.asm
                    > USED AT LINE 202 IN MAIN.asm
                    > USED AT LINE 220 IN MAIN.asm
                    > USED AT LINE 223 IN MAIN.asm
VOPERAND2:          3193 DEFINED AT LINE 22 IN ram.asm
                    > USED AT LINE 153 IN MAIN.asm
                    > USED AT LINE 212 IN MAIN.asm
                    > USED AT LINE 221 IN MAIN.asm
VOPEXPR:            3194 DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 155 IN MAIN.asm
                    > USED AT LINE 256 IN MAIN.asm
                    > USED AT LINE 269 IN MAIN.asm
VOPDISP:            3196 DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 156 IN MAIN.asm
                    > USED AT LINE 349 IN MAIN.asm
RST08:              3198 DEFINED AT LINE 27 IN ram.asm
                    > USED AT LINE 118 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
RST10:              319A DEFINED AT LINE 28 IN ram.asm
                    > USED AT LINE 124 IN IOSerial.asm
                    > USED AT LINE 461 IN IOSerial.asm
RST18:              319C DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 130 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RST20:              319E DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 136 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
RST28:              31A0 DEFINED AT LINE 31 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
RST30:              31A2 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 148 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
BAUD:               31A4 DEFINED AT LINE 33 IN ram.asm
INTVEC:             31A6 DEFINED AT LINE 34 IN ram.asm
                    > USED AT LINE 154 IN IOSerial.asm
                    > USED AT LINE 466 IN IOSerial.asm
NMIVEC:             31A8 DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 202 IN IOSerial.asm
                    > USED AT LINE 467 IN IOSerial.asm
GETCVEC:            31AA DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 447 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
                    > USED AT LINE 60 IN test.lib.asm
PUTCVEC:            31AC DEFINED AT LINE 37 IN ram.asm
                    > USED AT LINE 453 IN IOSerial.asm
                    > USED AT LINE 472 IN IOSerial.asm
HEAP:               31AE DEFINED AT LINE 39 IN ram.asm
                    > USED AT LINE 69 IN MAIN.asm
ASSEMBLY:           32AE DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 71 IN MAIN.asm
                    > USED AT LINE 82 IN test.lib.asm
TESTSSTART:         4000 DEFINED AT LINE 14
                    > USED AT LINE 6
TBDESC:             405C DEFINED AT LINE 5 IN test.lib.asm
                    > USED AT LINE 30 IN test.lib.asm
                    > USED AT LINE 161 IN test.lib.asm
TBTEXT:             405E DEFINED AT LINE 7 IN test.lib.asm
                    > USED AT LINE 53 IN test.lib.asm
                    > USED AT LINE 90 IN test.lib.asm
TBPTR:              4060 DEFINED AT LINE 9 IN test.lib.asm
                    > USED AT LINE 54 IN test.lib.asm
                    > USED AT LINE 195 IN test.lib.asm
                    > USED AT LINE 198 IN test.lib.asm
DESCRIBE:           4062 DEFINED AT LINE 28 IN test.lib.asm
                    > USED AT LINE 66
TEST:               406B DEFINED AT LINE 51 IN test.lib.asm
                    > USED AT LINE 69
EXPECT:             4083 DEFINED AT LINE 80 IN test.lib.asm
EXPECT1:            408D DEFINED AT LINE 87 IN test.lib.asm
                    > USED AT LINE 84 IN test.lib.asm
EXPECTOPDATA:       409F DEFINED AT LINE 112 IN test.lib.asm
                    > USED AT LINE 74
EXPECTOPITEM:       40DB DEFINED AT LINE 146 IN test.lib.asm
                    > USED AT LINE 116 IN test.lib.asm
                    > USED AT LINE 119 IN test.lib.asm
                    > USED AT LINE 122 IN test.lib.asm
EXPECTOPITEM1:      40E8 DEFINED AT LINE 158 IN test.lib.asm
                    > USED AT LINE 151 IN test.lib.asm
TESTGETCHARIMPL:    4123 DEFINED AT LINE 193 IN test.lib.asm
                    > USED AT LINE 59 IN test.lib.asm
PRINTHEX:           412E DEFINED AT LINE 218 IN test.lib.asm
PRINTHEX2:          4139 DEFINED AT LINE 243 IN test.lib.asm
                    > USED AT LINE 168 IN test.lib.asm
                    > USED AT LINE 173 IN test.lib.asm
                    > USED AT LINE 221 IN test.lib.asm
                    > USED AT LINE 223 IN test.lib.asm
PRINTHEX3:          4142 DEFINED AT LINE 252 IN test.lib.asm
                    > USED AT LINE 249 IN test.lib.asm
SKIPZSTR:           414D DEFINED AT LINE 277 IN test.lib.asm
                    > USED AT LINE 31 IN test.lib.asm
                    > USED AT LINE 55 IN test.lib.asm
                    > USED AT LINE 153 IN test.lib.asm
SKIPZSTR1:          414F DEFINED AT LINE 280 IN test.lib.asm
                    > USED AT LINE 286 IN test.lib.asm
SKIPZSTR2:          4150 DEFINED AT LINE 283 IN test.lib.asm
                    > USED AT LINE 278 IN test.lib.asm
