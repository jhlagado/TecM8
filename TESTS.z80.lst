0000                          .ENGINE   mycomputer   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $3000   
0000                ROMSIZE:   EQU   $3000   
0000                RAMSIZE:   EQU   $0800   
0000                EOF:      EQU   -1   
0000                NULL:     EQU   0   
0000                CTRL_C:   EQU   3   
0000                CTRL_H:   EQU   8   
0000                ESC:      EQU   27   
0000                NO_MATCH:   EQU   -1   
0000                BUFFER_SIZE:   EQU   $80   
0000                HEAP_SIZE:   EQU   $100   
0000                TOKENS:      
0000                COLON_:   EQU   ":"   
0000                COMMA_:   EQU   ","   
0000                DOLLAR_:   EQU   "$"   
0000                LPAREN_:   EQU   "("   
0000                MINUS_:   EQU   "-"   
0000                NEWLN_:   EQU   "\n"   
0000                PLUS_:    EQU   "+"   
0000                RPAREN_:   EQU   ")"   
0000                EOF_:     EQU   0   
0000                DIRECT_:   EQU   1   
0000                IDENT_:   EQU   2   
0000                LABEL_:   EQU   3   
0000                NUM_:     EQU   4   
0000                OPCODE_:   EQU   5   
0000                OPELEM_:   EQU   6   ; op element: reg, rp, flag
0000                UNKNOWN_:   EQU   100   
0000                ALU_:     EQU   0x00   
0000                ROT_:     EQU   0x20   
0000                BLI_:     EQU   0x40   
0000                GEN1_:    EQU   0x60   
0000                GEN2_:    EQU   0x80   
0000                ALU_IDX:      
0000                ADD_:     EQU   0 | alu_   
0000                ADC_:     EQU   1 | alu_   
0000                SUB_:     EQU   2 | alu_   
0000                SBC_:     EQU   3 | alu_   
0000                AND_:     EQU   4 | alu_   
0000                XOR_:     EQU   5 | alu_   
0000                OR_:      EQU   6 | alu_   
0000                CP_:      EQU   7 | alu_   
0000                ROT_IDX:      
0000                RLC_:     EQU   0 | rot_   
0000                RRC_:     EQU   1 | rot_   
0000                RL_:      EQU   2 | rot_   
0000                RR_:      EQU   3 | rot_   
0000                SLA_:     EQU   4 | rot_   
0000                SRA_:     EQU   5 | rot_   
0000                SLL_:     EQU   6 | rot_   
0000                SRL_:     EQU   7 | rot_   
0000                BLI_IDX:      
0000                LDI_:     EQU   00 | bli_   
0000                CPI_:     EQU   01 | bli_   
0000                INI_:     EQU   02 | bli_   
0000                OUTI_:    EQU   03 | bli_   
0000                LDD_:     EQU   04 | bli_   
0000                CPD_:     EQU   05 | bli_   
0000                IND_:     EQU   06 | bli_   
0000                OUTD_:    EQU   07 | bli_   
0000                LDIR_:    EQU   08 | bli_   
0000                CPIR_:    EQU   09 | bli_   
0000                INIR_:    EQU   10 | bli_   
0000                OTIR_:    EQU   11 | bli_   
0000                LDDR_:    EQU   12 | bli_   
0000                CPDR_:    EQU   13 | bli_   
0000                INDR_:    EQU   14 | bli_   
0000                OTDR_:    EQU   15 | bli_   
0000                GEN1_IDX:      
0000                CCF_:     EQU   00 | gen1_   
0000                CPL_:     EQU   01 | gen1_   
0000                DAA_:     EQU   02 | gen1_   
0000                DI_:      EQU   03 | gen1_   
0000                EI_:      EQU   04 | gen1_   
0000                HALT_:    EQU   05 | gen1_   
0000                NOP_:     EQU   06 | gen1_   
0000                RLCA_:    EQU   07 | gen1_   
0000                RST_:     EQU   08 | gen2_   
0000                SCF_:     EQU   09 | gen1_   
0000                GEN2_IDX:      
0000                BIT_:     EQU   00 | gen2_   
0000                CALL_:    EQU   01 | gen2_   
0000                DEC_:     EQU   02 | gen2_   
0000                DJNZ_:    EQU   03 | gen2_   
0000                EX_:      EQU   04 | gen2_   
0000                EXX_:     EQU   05 | gen2_   
0000                IM_:      EQU   06 | gen2_   
0000                IN_:      EQU   07 | gen2_   
0000                INC_:     EQU   08 | gen2_   
0000                JP_:      EQU   09 | gen2_   
0000                JR_:      EQU   10 | gen2_   
0000                LD_:      EQU   11 | gen2_   
0000                NEG_:     EQU   12 | gen2_   
0000                OUT_:     EQU   13 | gen2_   
0000                POP_:     EQU   14 | gen2_   
0000                PUSH_:    EQU   15 | gen2_   
0000                RES_:     EQU   16 | gen2_   
0000                RET_:     EQU   17 | gen2_   
0000                RETI_:    EQU   18 | gen2_   
0000                RETN_:    EQU   19 | gen2_   
0000                RLA_:     EQU   20 | gen2_   
0000                RLD_:     EQU   21 | gen2_   
0000                RRA_:     EQU   22 | gen2_   
0000                RRCA_:    EQU   23 | gen2_   
0000                RRD_:     EQU   24 | gen2_   
0000                SET_:     EQU   25 | gen2_   
0000                             ; operand types
0000                IMMED_:   EQU   0x00   ; immediate
0000                FLAG_:    EQU   0x01   ; flag
0000                REG_:     EQU   0x02   ; 8 bit reg
0000                RP_:      EQU   0x03   ; 16 bit reg pair
0000                INDIRECT_:   EQU   0x04   ; indirect HL
0000                INDEX_:   EQU   0x08   ; index reg
0000                FLAG_IDX:      
0000                NZ_:      EQU   0   
0000                Z_:       EQU   1   
0000                NC_:      EQU   2   
0000                CF_:      EQU   3   ; note: carry flag is CF_
0000                PO_:      EQU   4   
0000                PE_:      EQU   5   
0000                P_:       EQU   6   
0000                M_:       EQU   7   
0000                REG8_IDX:      ; 8-bit registers
0000                B_:       EQU   0   ; B
0000                C_:       EQU   1   ; C note: C register is C_
0000                D_:       EQU   2   ; D
0000                E_:       EQU   3   ; E
0000                H_:       EQU   4   ; H
0000                L_:       EQU   5   ; L
0000                MHL_:     EQU   6   ; (HL)
0000                A_:       EQU   7   ; A
0000                I_:       EQU   8   ; I
0000                R_:       EQU   9   ; R
0000                REG16_IDX:      ; 16-bit registers
0000                BC_:      EQU   0   
0000                DE_:      EQU   1   
0000                HL_:      EQU   2   
0000                SP_:      EQU   3   
0000                AFP_:     EQU   4   ; AF' (prime)
0000                AF_:      EQU   5   ; NOTE: AF has the same code as SP in some instructions
0000                IX_:      EQU   6   
0000                IY_:      EQU   7   
0000                DIRECTIVE_IDX:      
0000                ALIGN_:   EQU   0   
0000                DB_:      EQU   1   
0000                ORG_:     EQU   2   
0000                SET_:     EQU   3   
0000                             ; -----------------------------------------------------------------------------------------------
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                             ; *************************************************************************
0000                             ; 
0000                             ;       Serial routines 
0000                             ; 
0000                             ;       written by Craig Jones 
0000                             ; 
0000                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
0000                             ; 
0000                             ;       see the LICENSE file in this repo for more information 
0000                             ; 
0000                             ; *****************************************************************************
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8D 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 9B 31               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 9D 31               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 9F 31               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A A1 31               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A A3 31               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A A5 31               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A A9 31               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A AB 31               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   E5                     PUSH   HL   
0082   2A AD 31               LD   HL,(GETCVEC)   
0085   E3                     EX   (SP),HL   
0086   C9                     RET      
0087                             ; 
0087                PUTCHAR:      
0087   E5                     PUSH   HL   
0088   2A AF 31               LD   HL,(PUTCVEC)   
008B   E3                     EX   (SP),HL   
008C   C9                     RET      
008D                             ; 
008D                RESET:       
008D   31 80 31               LD   SP,stack   
0090   21 5F 00               LD   HL,IntRet   
0093   22 9B 31               LD   (RST08),HL   
0096   22 9D 31               LD   (RST10),HL   
0099   22 9F 31               LD   (RST18),HL   
009C   22 A1 31               LD   (RST20),HL   
009F   22 A3 31               LD   (RST28),HL   
00A2   22 A5 31               LD   (RST30),HL   
00A5   22 A9 31               LD   (INTVEC),HL   
00A8   22 AB 31               LD   (NMIVEC),HL   
00AB                             ; 
00AB   21 78 00               LD   HL,RXDATA   
00AE   22 AD 31               LD   (GETCVEC),HL   
00B1   21 6B 00               LD   HL,TXDATA   
00B4   22 AF 31               LD   (PUTCVEC),HL   
00B7                             ; 
00B7                          IF   TEC_1   
00B7                          IF   BITBANG = 0   
00B7                             ; 
00B7   3E 03                  LD   a,MRESET   
00B9   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00BB                             ; 
00BB                          ENDIF      
00BB                          ENDIF      
00BB                             ; 
00BB   CD 50 00               CALL   PWRUP   
00BE   ED 56                  IM   1   
00C0   FB                     EI      
00C1                             ; 
00C1                          IF   TEC_1   
00C1                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00C1                          ELSE      ;6850      
00C1                             ; 
00C1   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C3   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C5                             ; 
00C5                          ENDIF      
00C5                          ENDIF      
00C5                             ; 
00C5                             ; 
00C5   C3 00 40               JP   testsStart   
00C8                             ; *************************************************************************
00C8                             ; 
00C8                             ;       TecM8 1.0 Assembler for the Tec-1
00C8                             ; 
00C8                             ;       by John Hardy
00C8                             ; 
00C8                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3,29 June 2007
00C8                             ; 
00C8                             ;       see the LICENSE file in this repo for more information
00C8                             ; 
00C8                             ; *****************************************************************************
00C8                             ; **************************************************************************
00C8                             ; Page 0  Initialisation
00C8                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put TecM8 code from here	
0180                             ; *****************************************************************************
0180                             ; Routine: start
0180                             ; 
0180                             ; Purpose:
0180                             ;    Entry point of TecM8. Initializes the STACK pointer,calls the initialization
0180                             ;    routine,prints TecM8 version information,and jumps to the parsing routine.
0180                             ; 
0180                             ; Inputs:
0180                             ;    None
0180                             ; 
0180                             ; Outputs:
0180                             ;    None
0180                             ; 
0180                             ; Registers Destroyed:
0180                             ;    A,HL
0180                             ; *****************************************************************************
0180                START:       
0180   31 80 31               LD   sp,STACK   ; Initialize STACK pointer
0183   CD 98 01               CALL   init   ; Call initialization routine
0186   CD ED 05               CALL   print   ; Print TecM8 version information
0189   0B 54 65 63 4D 38 20 30 2E 30 0D 0A .PSTR   "TecM8 0.0\r\n"   
0195   C3 BD 01               JP   parse   ; Jump to the parsing routine
0198                             ; *****************************************************************************
0198                             ; Routine: init
0198                             ; 
0198                             ; Purpose:
0198                             ;    Initializes various pointers and variables used by TecM8.
0198                             ; 
0198                             ; Inputs:
0198                             ;    None
0198                             ; 
0198                             ; Outputs:
0198                             ;    None
0198                             ; 
0198                             ; Registers Destroyed:
0198                             ;    A,HL
0198                             ; *****************************************************************************
0198                INIT:        
0198   21 00 00               LD   hl,0   
019B   22 85 31               LD   (vTokenVal),hl   ; vTokenVal = 0
019E   22 8B 31               LD   (vSymPtr),hl   ; vSymPtr = 0
01A1   22 8D 31               LD   (vExprPtr),hl   ; vExprPtr = 0
01A4   AF                     XOR   a   
01A5   32 84 31               LD   (vToken),a   ; vToken = 0
01A8   32 87 31               LD   (vBufferPos),a   ; vBufferPos = 0
01AB   3E 0A                  LD   a,"\n"   ; put new line into first char of buffer
01AD   32 00 30               LD   (BUFFER),a   
01B0   21 B1 31               LD   hl,HEAP   ; vHeapPtr = HEAP
01B3   22 8F 31               LD   (vHeapPtr),hl   
01B6   21 B1 32               LD   hl,ASSEMBLY   ; vAsmPtr = ASSEMBLY
01B9   22 89 31               LD   (vAsmPtr),hl   
01BC   C9                     RET      
01BD                             ; *****************************************************************************
01BD                             ; Routine: parse
01BD                             ; 
01BD                             ; Purpose:
01BD                             ;    Parses the input program,calling the statementList routine,printing the
01BD                             ;    completion message,and halting the system.
01BD                             ; 
01BD                             ; Inputs:
01BD                             ;    None
01BD                             ; 
01BD                             ; Outputs:
01BD                             ;    None
01BD                             ; 
01BD                             ; Registers Destroyed:
01BD                             ;    None
01BD                             ; *****************************************************************************
01BD                PARSE:       
01BD   CD FC 01               CALL   statementList   ; Parse the input program
01C0   CD ED 05               CALL   print   ; Print completion message
01C3   1F 50 61 72 73 69 6E 67 20 63 6F 6D 70 6C 65 74 65 64 20 73 75 63 63 65 73 73 66 75 6C 6C 79 2E .PSTR   "Parsing completed successfully."   
01E3   76                     HALT      
01E4                PARSEERROR:      
01E4   CD ED 05               CALL   print   ; Print completion message
01E7   13 0D 0A 55 6E 65 78 70 65 63 74 65 64 20 74 6F 6B 65 6E 2E .PSTR   "\r\nUnexpected token."   
01FB   76                     HALT      
01FC                             ; *****************************************************************************
01FC                             ; Routine: statementList
01FC                             ; 
01FC                             ; Purpose:
01FC                             ;    Parses a list of statements,repeatedly calling the statement routine until
01FC                             ;    the end of file (EOF) token is encountered.
01FC                             ; 
01FC                             ; Inputs:
01FC                             ;    None
01FC                             ; 
01FC                             ; Outputs:
01FC                             ;    None
01FC                             ; 
01FC                             ; Registers Destroyed:
01FC                             ;    A
01FC                             ; *****************************************************************************
01FC                STATEMENTLIST:      
01FC   CD 86 03               CALL   nextToken   ; Get the next token
01FF   CD 0B 02               CALL   statement   ; Parse a statement
0202   FE 00                  CP   EOF_   ; Check if it's the end of file
0204   C8                     RET   z   ; If yes,return
0205   FE 0A                  CP   NEWLN_   
0207   20 DB                  JR   nz,parseError   
0209   18 F1                  JR   statementList   ; Repeat for the next statement
020B                             ; *****************************************************************************
020B                             ; Routine: statement
020B                             ; 
020B                             ; Purpose:
020B                             ;    Parses a single statement,checking its type (label,opcode,or directive)
020B                             ;    and performing corresponding actions.
020B                             ; 
020B                             ; Inputs:
020B                             ;    None
020B                             ; 
020B                             ; Outputs:
020B                             ;    None
020B                             ; 
020B                             ; Registers Destroyed:
020B                             ;    A
020B                             ; *****************************************************************************
020B                STATEMENT:      
020B   CD F7 04               CALL   isEndOfLine   
020E   C8                     RET   z   
020F   F5                     PUSH   af   ; save token type
0210   E5                     PUSH   hl   ; save token val
0211   21 FF FF               LD   hl,-1   ; operand H = value L = type
0214   22 93 31               LD   (vOp1),hl   
0217   22 95 31               LD   (vOp2),hl   
021A   AF                     XOR   a   
021B   32 92 31               LD   (vOpcode),a   
021E   32 91 31               LD   (vIsBranch),a   
0221   32 97 31               LD   (vOpExpr),a   
0224   32 99 31               LD   (vOpDisp),a   
0227   E1                     POP   hl   ; restore token val
0228   F1                     POP   af   ; restore token type
0229   FE 03                  CP   LABEL_   ; Check if it's a label
022B   20 0A                  JR   nz,statement1   ; If not,jump to statement10
022D   ED 5B 89 31            LD   de,(vAsmPtr)   ; HL = symbol name DE = symbol value (assembler pointer)
0231   CD 6D 03               CALL   addSymbol   ; Add label to symbol list
0234   CD 86 03               CALL   nextToken   ; Get the next token
0237                STATEMENT1:      
0237   FE 05                  CP   OPCODE_   ; Check if it's an opcode
0239   28 05                  JR   z,instr   ; Jump to instr routine
023B   FE 01                  CP   DIRECT_   ; Check if it's a directive
023D   28 76                  JR   z,directive   
023F   C9                     RET      
0240                             ; *****************************************************************************
0240                             ; Routine: instr
0240                             ; 
0240                             ; Purpose:
0240                             ;    Parses an instruction and its operands from the current token. This routine
0240                             ;    identifies the opcode and determines whether the instruction has one or
0240                             ;    two operands. It stores the parsed opcode and operands in the corresponding
0240                             ;    variables. Handles both single and double operand instructions and manages
0240                             ;    specific cases such as branch instructions and special operand types.
0240                             ; 
0240                             ; Inputs:
0240                             ;    HL - Points to the current token (opcode) to be parsed.
0240                             ; 
0240                             ; Outputs:
0240                             ;    vOpcode - Stores the parsed opcode.
0240                             ;    vOp1 - Stores the first operand or -1 if there is only one operand.
0240                             ;    vOp2 - Stores the second operand if present.
0240                             ; 
0240                             ; Registers Destroyed:
0240                             ;    A, B, H, L
0240                             ; 
0240                             ; Flow:
0240                             ;    - Load the opcode into register A and store it in `vOpcode`.
0240                             ;    - Compare the opcode with known instruction types (e.g., JP, JR, CALL, RET).
0240                             ;    - If the opcode indicates a branch instruction, set the `vIsBranch` flag.
0240                             ;    - Proceed to parse the first operand, handling special cases like flag registers.
0240                             ;    - Check if there is a comma indicating a second operand, and if so, parse it.
0240                             ;    - Manage cases with one operand by moving it to `vOp2` and setting `vOp1` to -1.
0240                             ;    - Handle errors if the instruction format is invalid or if operands are missing.
0240                             ; 
0240                             ; Notes:
0240                             ;    - The routine calls other subroutines such as `nextToken`, `isEndOfLine`, and `operand`.
0240                             ;    - Special handling is implemented for immediate values and memory references.
0240                             ;    - The routine also manages parentheses and operand expressions.
0240                             ; *****************************************************************************
0240                INSTR:       
0240   7D                     LD   a,l   ; Load the current token (opcode) into A
0241   32 92 31               LD   (vOpcode),a   ; Store the opcode in vOpcode
0244   FE 89                  CP   JP_   ; Compare opcode with JP (Jump)
0246   28 0C                  JR   z,instr1   
0248   FE 8A                  CP   JR_   ; Compare opcode with JR (Jump Relative)
024A   28 08                  JR   z,instr1   
024C   FE 81                  CP   CALL_   ; Compare opcode with CALL (Call Subroutine)
024E   28 04                  JR   z,instr1   
0250   FE 91                  CP   RET_   ; Compare opcode with RET (Return)
0252   20 05                  JR   nz,instr2   
0254                INSTR1:      
0254   AF                     XOR   a   ; set isBranch to true
0255   3D                     DEC   a   
0256   32 91 31               LD   (vIsBranch),a   
0259                INSTR2:      
0259   CD 86 03               CALL   nextToken   ; Get the next token
025C   CD F7 04               CALL   isEndOfLine   ; Check if the end of the line is reached
025F   C8                     RET   z   ; Return if it is the end of the line
0260   47                     LD   b,a   ; save token type, so we can deal with ambiguity of "C"
0261   3A 91 31               LD   a,(vIsBranch)   ; A = isBranch flag
0264   3C                     INC   a   
0265   20 11                  JR   nz,instr3   
0267   7D                     LD   a,l   ; Check if the operand type is a reg
0268   FE 02                  CP   reg_   
026A   20 0C                  JR   nz,instr3   
026C   7C                     LD   a,h   ; Check if the operand value is a C register
026D   FE 01                  CP   C_   
026F   20 07                  JR   nz,instr3   
0271   2E 01                  LD   l,flag_   ; Set operand type to flag
0273   26 03                  LD   h,CF_   ; Set operand value to carry flag
0275   78                     LD   a,b   ; restore token type
0276   18 04                  JR   instr4   
0278                INSTR3:      
0278   78                     LD   a,b   ; restore token type
0279   CD B6 02               CALL   operand   ; only call operand if we didnt correct to C register
027C                INSTR4:      
027C   22 93 31               LD   (vOp1),hl   ; Store the first operand in vOp1
027F   CD 86 03               CALL   nextToken   ; Get the next token
0282   FE 2C                  CP   COMMA_   ; Check if the token is a comma
0284   20 19                  JR   nz,instr5   ; If not, handle as a single operand instruction
0286   CD 86 03               CALL   nextToken   ; Get the next token
0289   CD F7 04               CALL   isEndOfLine   ; Check if the end of the line is reached
028C   CA E4 01               JP   z,parseError   ; Jump to parseError if it is the end of the line
028F   CD B6 02               CALL   operand   ; Parse the second operand
0292   22 95 31               LD   (vOp2),hl   ; Store the second operand in vOp2
0295   CD 86 03               CALL   nextToken   ; Get the next token
0298   CD F7 04               CALL   isEndOfLine   ; Check if the end of the line is reached
029B   C2 E4 01               JP   nz,parseError   ; Jump to parseError if it is the end of the line
029E   C9                     RET      ; Return from the subroutine
029F                INSTR5:      
029F   47                     LD   b,a   ; save token type
02A0   3A 93 31               LD   a,(vOp1Type)   ; if operand is a flag don's shift to operand2
02A3   FE 01                  CP   flag_   
02A5   28 0C                  JR   z,instr6   
02A7   2A 93 31               LD   hl,(vOp1)   ; Move Op1 to vOp2
02AA   22 95 31               LD   (vOp2),hl   ; 
02AD   21 FF FF               LD   hl,-1   ; Set vOp1 to default value -1 (no operand)
02B0   22 93 31               LD   (vOp1),hl   ; 
02B3                INSTR6:      
02B3   78                     LD   a,b   ; restore token type
02B4   C9                     RET      ; Return from the subroutine
02B5                DIRECTIVE:      
02B5   C9                     RET      
02B6                OPERAND:      
02B6   FE 06                  CP   OPELEM_   ; Check if the token is an op element i.e. reg,rp or flag
02B8   C8                     RET   z   
02B9   FE 28                  CP   LPAREN_   ; Check if the token is a left parenthesis
02BB   28 0B                  JR   z,operand1   ; If so,handle as a memory reference
02BD   CD 0E 03               CALL   expression   ; Otherwise,treat as an expression
02C0   22 97 31               LD   (vOpExpr),hl   ; Store the result of the operand expression
02C3   26 00                  LD   h,0   
02C5   2E 00                  LD   l,immed_   ; Set A to indicate an immediate value
02C7   C9                     RET      
02C8                OPERAND1:      
02C8   CD 86 03               CALL   nextToken   ; Memory reference. Get the next token
02CB   FE 06                  CP   OPELEM_   ; Check if the next token is an op element
02CD   20 05                  JR   nz,operand2   ; If not,handle as an expression inside parentheses
02CF   CD E9 02               CALL   regIndirect   
02D2   18 0A                  JR   operand7   
02D4                OPERAND2:      
02D4   CD 0E 03               CALL   expression   ; Treat as a new expression
02D7   22 97 31               LD   (vOpExpr),hl   ; Store the result of the expression
02DA   26 00                  LD   h,0   
02DC   2E 46                  LD   l,immed_ | ind_   ; Set A to indicate an immediate memory reference
02DE                OPERAND7:      
02DE   E5                     PUSH   HL   ; save HL
02DF   CD 86 03               CALL   nextToken   ; Get the next token
02E2   FE 29                  CP   RPAREN_   ; Check if the next token is a right parenthesis
02E4   C2 E4 01               JP   nz,parseError   ; If not,handle as a parse error
02E7   E1                     POP   HL   ; restore HL
02E8   C9                     RET      
02E9                             ; *****************************************************************************
02E9                             ; Routine: regIndirect
02E9                             ; 
02E9                             ; Purpose:
02E9                             ;    Parses the register indirect memory address sets the
02E9                             ;    appropriate flags based on the type of operand.
02E9                             ; 
02E9                             ; Inputs:
02E9                             ;    HL - Points to the current token.
02E9                             ; 
02E9                             ; Outputs:
02E9                             ;    A - Contains operand information.
02E9                             ; 
02E9                             ; Registers Destroyed:
02E9                             ;    AF
02E9                             ; *****************************************************************************
02E9                REGINDIRECT:      
02E9   7D                     LD   a,l   ; A = operand type
02EA   FE 02                  CP   reg_   ; is reg?
02EC   20 08                  JR   nz,regIndirect1   
02EE   7C                     LD   a,h   ; A = operand value, type = reg
02EF   FE 01                  CP   C_   ; (C)
02F1   28 16                  JR   z,regIndirect4   
02F3   C3 E4 01               JP   parseError   
02F6                REGINDIRECT1:      
02F6   FE 0B                  CP   rp_ | index_   ; is it IX, IY?
02F8   28 07                  JR   z,regIndirect3   
02FA   FE 03                  CP   rp_   ; is it BC, DE, HL?
02FC   28 0B                  JR   z,regIndirect4   
02FE   C3 E4 01               JP   parseError   
0301                REGINDIRECT3:      
0301   E5                     PUSH   hl   ; Save HL on the stack
0302   CD 0E 03               CALL   expression   ; Treat as an expression
0305   22 99 31               LD   (vOpDisp),hl   ; Store the result of the expression
0308   E1                     POP   hl   ; Restore HL from the stack
0309                REGINDIRECT4:      
0309   7D                     LD   a,l   
030A   F6 04                  OR   indirect_   ; indirect
030C   6F                     LD   l,a   
030D   C9                     RET      
030E                             ; *****************************************************************************
030E                             ; Routine: expression
030E                             ; 
030E                             ; Purpose:
030E                             ;    Parses an expression as an array of tokens and stores it in an array.
030E                             ;    Each token in the expression is appended to an array which is terminated by
030E                             ;    a NULL token type.
030E                             ;    The expression list pointer is updated to point to the start of the last token list.
030E                             ; 
030E                             ; Inputs:
030E                             ;    A - token type
030E                             ;    HL - token value
030E                             ; 
030E                             ; Outputs:
030E                             ;    Updates the heap with the parsed expression and updates the expression list pointer.
030E                             ; 
030E                             ; Registers Destroyed:
030E                             ;    AF,B,HL
030E                             ; *****************************************************************************
030E                EXPRESSION:      
030E   06 00                  LD   b,0   ; Initialize nesting level
0310   E5                     PUSH   hl   ; Save token value
0311   ED 5B 8F 31            LD   de,(vHeapPtr)   ; Load the current heap pointer into DE
0315   2A 8D 31               LD   hl,(vExprPtr)   ; Load the current expression list pointer into HL
0318   CD 00 06               CALL   hpush   ; Push the pointer to the last symbol onto the heap
031B   21 00 00               LD   hl,0   ; Append two words in header (for future use)
031E   CD 00 06               CALL   hpush   
0321   CD 00 06               CALL   hpush   
0324   ED 53 8D 31            LD   (vExprPtr),de   ; Update the expression list pointer with the new address
0328   E1                     POP   hl   ; HL = token value
0329                EXPRESSION1:      
0329   EB                     EX   de,hl   ; DE = token value
032A   6F                     LD   l,a   ; HL = token type
032B   26 00                  LD   h,0   
032D   CD 00 06               CALL   hpush   ; Push the token type
0330   EB                     EX   de,hl   ; HL = token value
0331   CD 00 06               CALL   hpush   ; Push the token value
0334   CD 86 03               CALL   nextToken   ; Get the next token
0337   FE 28                  CP   "("   ; increase nesting?
0339   20 06                  JR   nz,expression2   
033B   04                     INC   b   
033C   CD 86 03               CALL   nextToken   ; Get the next token
033F   18 E8                  JR   expression1   ; Repeat the main loop
0341                EXPRESSION2:      
0341   04                     INC   b   ; Check if nesting level is zero
0342   05                     DEC   b   
0343   28 0A                  JR   z,expression3   ; If yes,skip to expression3
0345   FE 29                  CP   ")"   ; if nesting > 0,decrease nesting?
0347   20 06                  JR   nz,expression3   
0349   05                     DEC   b   ; Decrease nesting level
034A   CD 86 03               CALL   nextToken   ; Get the next token
034D   18 DA                  JR   expression1   ; Repeat the main loop
034F                EXPRESSION3:      
034F   FE 29                  CP   RPAREN_   ; Check if the end of the expression
0351   28 0B                  JR   z,expression4   
0353   FE 2C                  CP   COMMA_   
0355   28 07                  JR   z,expression4   
0357   CD F7 04               CALL   isEndOfLine   
035A   28 02                  JR   z,expression4   
035C   18 CB                  JR   expression1   
035E                EXPRESSION4:      
035E   EB                     EX   de,hl   
035F   21 00 00               LD   hl,NULL   ; Mark the end of the expression with NULL
0362   CD 00 06               CALL   hpush   ; Push NULL onto the heap
0365   EB                     EX   de,hl   
0366   CD 47 04               CALL   pushBackToken   ; Rewind the token to the last valid one
0369   2A 8D 31               LD   hl,(vExprPtr)   
036C   C9                     RET      
036D                             ; *****************************************************************************
036D                             ; Routine: addSymbol
036D                             ; 
036D                             ; Purpose:
036D                             ;    Adds a new symbol to the symbol list. The symbol's name is in HL and the
036D                             ;    symbol's value is in DE. Updates the symbol list pointer and ensures
036D                             ;    the previous symbol's pointer is preserved.
036D                             ; 
036D                             ; Inputs:
036D                             ;    HL - Points to the name of the new symbol.
036D                             ;    DE - Contains the value of the new symbol.
036D                             ; 
036D                             ; Outputs:
036D                             ;    Updates the symbol list pointer in vSymPtr.
036D                             ; 
036D                             ; Registers Destroyed:
036D                             ;    DE,HL
036D                             ; *****************************************************************************
036D                ADDSYMBOL:      
036D   D5                     PUSH   de   
036E   E5                     PUSH   hl   ; Push symbol name onto the stack
036F   ED 5B 8F 31            LD   de,(vHeapPtr)   ; BC = symbol address from the heap pointer
0373   2A 8B 31               LD   hl,(vSymPtr)   ; Load the current symbol list pointer into HL
0376   CD 00 06               CALL   hpush   ; Push pointer to the last symbol onto the heap
0379   ED 53 8B 31            LD   (vSymPtr),de   ; Update the symbol list pointer with the new symbol address
037D   E1                     POP   hl   ; HL = symbol name
037E   CD 00 06               CALL   hpush   ; Push symbol name onto the heap
0381   E1                     POP   hl   ; HL = symbol value
0382   CD 00 06               CALL   hpush   ; Push symbol value onto the heap
0385   C9                     RET      ; Return from subroutine
0386                             ; *****************************************************************************
0386                             ; Routine: nextToken
0386                             ; 
0386                             ; Purpose:
0386                             ;    Parses the next token from the input stream,identifying various types of
0386                             ;    tokens such as identifiers,labels,opcodes,registers,flags,numbers,
0386                             ;    and special characters.
0386                             ; 
0386                             ; Inputs:
0386                             ;    None
0386                             ; 
0386                             ; Outputs:
0386                             ;    A - Token representing the type of the parsed element
0386                             ; 
0386                             ; Registers Destroyed:
0386                             ;    A,BC,DE,HL
0386                             ; *****************************************************************************
0386                NEXTTOKEN:      
0386   21 84 31               LD   hl,vToken   ; hl points to vToken
0389   7E                     LD   a,(hl)   ; load a with pushed back vToken
038A   CB 7F                  BIT   7,a   ; Check the high bit of token
038C   CA 96 03               JP   z,nextToken1   ; If high bit clear,nothing pushed back
038F   CB BF                  RES   7,a   ; Clear high bit
0391   77                     LD   (hl),a   ; Store the character back in the BUFFER
0392   2A 85 31               LD   hl,(vTokenVal)   ; put token value into HL
0395   C9                     RET      ; Return with the pushed back character in A
0396                NEXTTOKEN1:      
0396   CD 66 05               CALL   nextChar   ; Get the next character
0399   21 00 00               LD   hl,0   ; Initialize HL with 0
039C   FE 20                  CP   " "   ; is it space?
039E   28 F6                  JR   z,nextToken1   ; If yes,skip it and get the next character
03A0   FE FF                  CP   EOF   ; Is it null (end of input)?
03A2   20 03                  JR   nz,nextToken2   ; If not,continue to the next check
03A4   3E 00                  LD   a,EOF_   ; If yes,return with EOF token
03A6   C9                     RET      
03A7                NEXTTOKEN2:      
03A7   FE 5C                  CP   $5C   ; Is it a statement separator? "\"
03A9   28 08                  JR   z,nextToken2a   ; If not,continue to the next check
03AB   FE 3A                  CP   ":"   ; Is it a statement separator? ":"
03AD   28 04                  JR   z,nextToken2a   ; If not,continue to the next check
03AF   FE 0A                  CP   "\n"   ; Is it a new line
03B1   20 03                  JR   nz,nextToken3   ; If not,continue to the next check
03B3                NEXTTOKEN2A:      
03B3   3E 0A                  LD   a,NEWLN_   ; If yes,return with NEWLIN token
03B5   C9                     RET      ; Return with newline token
03B6                NEXTTOKEN3:      
03B6   FE 3B                  CP   ";"   ; Is it a comment?
03B8   20 0C                  JR   nz,nextToken5   ; If not,continue to the next check
03BA                NEXTTOKEN4:      
03BA   CD 66 05               CALL   nextChar   ; Get the next character in the comment
03BD   FE 21                  CP   " "+1   ; Loop until the next control character
03BF   30 F9                  JR   nc,nextToken4   
03C1   CD CE 05               CALL   rewindChar   ; Push back the character
03C4   18 D0                  JR   nextToken1   ; return with control char
03C6                NEXTTOKEN5:      
03C6   FE 5F                  CP   "_"   ; Is it an identifier?
03C8   28 05                  JR   z,nextToken6   ; If yes,continue to the next check
03CA   CD 01 05               CALL   isAlpha   ; If not,check if it's alphabetic
03CD   30 34                  JR   nc,nextToken11   ; If not,continue to the next check
03CF                NEXTTOKEN6:      
03CF   CD 50 04               CALL   ident   ; Parse the identifier
03D2   FE 3A                  CP   ":"   ; Is it a label?
03D4   20 03                  JR   nz,nextToken7   ; If not,continue to the next check
03D6   3E 03                  LD   a,LABEL_   ; If yes,return A = LABEL HL = string
03D8   C9                     RET      
03D9                NEXTTOKEN7:      
03D9   CD CE 05               CALL   rewindChar   ; Push back the character
03DC   22 8F 31               LD   (vHeapPtr),hl   ; Restore string heap pointer to previous location
03DF   CD 70 04               CALL   searchOpcode   
03E2   20 06                  JR   nz,nextToken8   
03E4   6F                     LD   l,a   ; hl = opcode value
03E5   26 00                  LD   h,0   
03E7   3E 05                  LD   a,OPCODE_   ; Return with OPCODE token
03E9   C9                     RET      
03EA                NEXTTOKEN8:      
03EA   CD 9D 04               CALL   searchOpElem   
03ED   20 03                  JR   nz,nextToken9   
03EF   3E 06                  LD   a,OPELEM_   ; Return with OPELEM token
03F1   C9                     RET      
03F2                NEXTTOKEN9:      
03F2   11 6D 07               LD   de,directives   ; List of directives to search
03F5   CD CD 04               CALL   searchStr   
03F8   20 06                  JR   nz,nextToken10   
03FA   6F                     LD   l,a   ; hl = directive value
03FB   26 00                  LD   h,0   
03FD   3E 01                  LD   a,DIRECT_   ; Return with DIRECT token
03FF   C9                     RET      
0400                NEXTTOKEN10:      
0400   3E 02                  LD   a,IDENT_   ; Return with IDENT token
0402   C9                     RET      
0403                NEXTTOKEN11:      
0403   21 00 00               LD   hl,0   
0406   FE 24                  CP   "$"   ; Is it a hexadecimal number?
0408   20 1A                  JR   nz,nextToken13   ; If not,continue to the next check
040A   CD 66 05               CALL   nextChar   ; Get the next character
040D   CD FD 04               CALL   isAlphaNum   ; Check if it's the ASSEMBLY pointer
0410   28 06                  JR   z,nextToken12   ; If not,continue to the next check
0412   CD CE 05               CALL   rewindChar   ; Push back the character (flags unaffected)
0415   3E 24                  LD   a,DOLLAR_   ; Return with DOLLAR token
0417   C9                     RET      ; Return with the DOLLAR token
0418                NEXTTOKEN12:      
0418   CD CE 05               CALL   rewindChar   ; Push back the character (flags unaffected)
041B   CD 39 05               CALL   hexadecimal   ; Process hexadecimal number
041E   CD CE 05               CALL   rewindChar   ; Push back the character (flags unaffected)
0421   3E 04                  LD   a,NUM_   ; Return with NUM token
0423   C9                     RET      
0424                NEXTTOKEN13:      
0424   CD 13 05               CALL   isDigit   ; Check if it's a digit
0427   30 0C                  JR   nc,nextToken14   ; Jump to the next check
0429   CD CE 05               CALL   rewindChar   ; Push back the character (flags unaffected)
042C   CD 1A 05               CALL   decimal   ; parse decimal
042F   CD CE 05               CALL   rewindChar   ; Push back the character (flags unaffected)
0432   3E 04                  LD   a,NUM_   ; Return with NUM token
0434   C9                     RET      
0435                NEXTTOKEN14:      
0435   FE 2B                  CP   "+"   ; If "+" then return PLUS token
0437   C8                     RET   z   
0438   FE 2D                  CP   "-"   ; If "-" then return MINUS token
043A   C8                     RET   z   
043B   FE 28                  CP   "("   ; If "(" then return LPAREN token
043D   C8                     RET   z   
043E   FE 29                  CP   ")"   ; If ")" then return LPAREN token
0440   C8                     RET   z   
0441   FE 2C                  CP   ","   ; If "," then return COMMA token
0443   C8                     RET   z   
0444   3E 64                  LD   a,UNKNOWN_   ; Return with UNKNOWN token
0446   C9                     RET      
0447                             ; *****************************************************************************
0447                             ; Routine: pushBackToken
0447                             ; 
0447                             ; Purpose:
0447                             ;    Pushes back a token into the pushback BUFFER to allow the token to be
0447                             ;    re-read by the nextToken routine.
0447                             ; 
0447                             ; Inputs:
0447                             ;    A  - token type
0447                             ;    HL - token value
0447                             ; 
0447                             ; Outputs:
0447                             ;    None
0447                             ; 
0447                             ; Registers Destroyed:
0447                             ;    A,DE
0447                             ; *****************************************************************************
0447                PUSHBACKTOKEN:      
0447   CB FF                  SET   7,a   ; Set the high bit of the token type (without affecting flags)
0449   32 84 31               LD   (vToken),a   ; push back the token
044C   22 85 31               LD   (vTokenVal),hl   ; push back the token value
044F   C9                     RET      
0450                             ; *****************************************************************************
0450                             ; Routine: ident
0450                             ; 
0450                             ; Purpose:
0450                             ;    Reads characters from the input stream until a charcter which is not an
0450                             ;    an underscore or an alphanumeric character is encountered. Writes the chars
0450                             ;    to a Pascal string and updates the top of the STRINGS heap pointer.
0450                             ;    It also calculates the length of the string and stores it at the beginning
0450                             ;    of the string.
0450                             ; 
0450                             ; Inputs:
0450                             ;    A - Current character read from the input stream
0450                             ;    vHeapPtr - Address of the top of heap pointer
0450                             ; 
0450                             ; Outputs:
0450                             ;    A - last character read from the input stream
0450                             ;    HL - identifier string
0450                             ; 
0450                             ; Registers Destroyed:
0450                             ;    DE,HL
0450                             ; *****************************************************************************
0450                IDENT:       
0450   2A 8F 31               LD   hl,(vHeapPtr)   ; Load the address of the top of STRINGS heap
0453   E5                     PUSH   hl   ; save start of string
0454   23                     INC   hl   ; Move to the next byte to skip the length byte
0455                IDENT1:      
0455   77                     LD   (hl),a   ; Write the current character to the string BUFFER
0456   23                     INC   hl   ; Move to the next position in the BUFFER
0457   E5                     PUSH   hl   
0458   CD 66 05               CALL   nextChar   ; Get the next character from the input stream
045B   E1                     POP   hl   
045C   FE 5F                  CP   "_"   ; Compare with underscore character
045E   28 F5                  JR   z,ident1   ; If underscore,jump to ident2
0460   CD FD 04               CALL   isAlphanum   ; Check if the character is alphanumeric
0463   38 F0                  JR   c,ident1   ; If not alphanumeric,jump to ident3
0465                IDENT3:      
0465   22 8F 31               LD   (vHeapPtr),hl   ; Update the top of STRINGS heap pointer
0468   D1                     POP   de   ; restore start of string into de
0469   B7                     OR   a   ; Clear carry
046A   ED 52                  SBC   hl,de   ; Calculate the length of the string (HL = length,DE = string)
046C   2D                     DEC   l   ; reduce by one (length byte)
046D   EB                     EX   de,hl   ; Swap DE and HL (E = length,HL = string)
046E   73                     LD   (hl),e   ; Store the length at the beginning of the string BUFFER
046F   C9                     RET      
0470                             ; *****************************************************************************
0470                             ; Routine: searchOpcode
0470                             ; 
0470                             ; Purpose:
0470                             ;    Searches for a matching opcode in various lists of opcodes.
0470                             ; 
0470                             ; Inputs:
0470                             ;    HL - Points to the string to search for.
0470                             ; 
0470                             ; Outputs:
0470                             ;    ZF - Set if a match is found,cleared otherwise.
0470                             ;    A  - Contains the index of the matching opcode if a match is found,
0470                             ;         or the last checked index if no match is found.
0470                             ; 
0470                             ; Registers Destroyed:
0470                             ;    A,DE,F
0470                             ; *****************************************************************************
0470                SEARCHOPCODE:      
0470   11 2D 06               LD   de,alu_opcodes   ; Point DE to the list of ALU opcodes
0473   CD CD 04               CALL   searchStr   ; Search for the string in ALU opcodes
0476   C8                     RET   z   ; If match found (ZF set),return
0477   11 0E 06               LD   de,rot_opcodes   ; Point DE to the list of ROT opcodes
047A   CD CD 04               CALL   searchStr   ; Search for the string in ROT opcodes
047D   CB EF                  SET   5,a   ; Set bit 5 in A to indicate ROT opcodes
047F   C8                     RET   z   ; If match found (ZF set),return
0480   11 4C 06               LD   de,bli_opcodes   ; Point DE to the list of BLI opcodes
0483   CD CD 04               CALL   searchStr   ; Search for the string in BLI opcodes
0486   CB F7                  SET   6,a   ; Set bit 6 in A to indicate BLI opcodes
0488   C8                     RET   z   ; If match found (ZF set),return
0489   11 97 06               LD   de,gen1_opcodes   ; Point DE to the list of general opcodes (set 1)
048C   CD CD 04               CALL   searchStr   ; Search for the string in general opcodes
048F   CB EF                  SET   5,a   ; Set bits 5 & 6 in A to indicate general opcodes (set 1)
0491   CB F7                  SET   6,a   
0493   C8                     RET   z   ; If match found (ZF set),return
0494   11 C0 06               LD   de,gen2_opcodes   ; Point DE to the list of general opcodes (set 2)
0497   CD CD 04               CALL   searchStr   ; Search for the string in general opcodes
049A   CB FF                  SET   7,a   ; Set bit 7 in A to indicate general opcodes (set 2)
049C   C9                     RET      ; Return ZF = match
049D                             ; *****************************************************************************
049D                             ; Routine: searchOpElem
049D                             ; 
049D                             ; Purpose:
049D                             ;    Searches for an op element in the lists of 8-bit registers,16-bit registers,
049D                             ;    and flags. Sets appropriate flags based on the type of operand found.
049D                             ; 
049D                             ; Inputs:
049D                             ;    HL - Points to the start of the string to search for.
049D                             ; 
049D                             ; Outputs:
049D                             ;    H  - the value of the op element
049D                             ;    L  - The type of the op element
049D                             ;    ZF - Set if a match is found,cleared otherwise.
049D                             ; 
049D                             ; Registers Destroyed:
049D                             ;    A,DE,HL
049D                             ; *****************************************************************************
049D                SEARCHOPELEM:      
049D   11 29 07               LD   de,reg8   ; Point DE to the list of 8-bit register operands
04A0   CD CD 04               CALL   searchStr   ; Search for the string in reg8 operands
04A3   20 04                  JR   nz,searchOpElem1   
04A5   67                     LD   h,a   
04A6   2E 02                  LD   l,reg_   
04A8   C9                     RET      ; If match found (ZF set),return
04A9                SEARCHOPELEM1:      
04A9   11 58 07               LD   de,flags   ; Point DE to the list of flag operands
04AC   CD CD 04               CALL   searchStr   ; Search for the string in reg16 operands
04AF   20 04                  JR   nz,searchOpElem2   
04B1   67                     LD   h,a   
04B2   2E 01                  LD   l,flag_   
04B4   C9                     RET      ; If match found (ZF set),return
04B5                SEARCHOPELEM2:      
04B5   11 3E 07               LD   de,reg16   ; Point DE to the list of 16-bit register operands
04B8   CD CD 04               CALL   searchStr   ; Search for the string in flag operands
04BB   C0                     RET   nz   ; not found if ZF is clear
04BC   67                     LD   h,a   
04BD   2E 03                  LD   l,rp_   
04BF   FE 06                  CP   IX_   ; check if a is IX or IY
04C1   28 04                  JR   z,searchOpElem3   
04C3   FE 07                  CP   IY_   
04C5   20 04                  JR   nz,searchOpElem4   ; Return ZF = match
04C7                SEARCHOPELEM3:      
04C7   3E 08                  LD   a,index_   
04C9   B5                     OR   l   
04CA   6F                     LD   l,a   
04CB                SEARCHOPELEM4:      
04CB   AF                     XOR   a   ; set ZF
04CC   C9                     RET      
04CD                             ; *****************************************************************************
04CD                             ; Routine: searchStr
04CD                             ; 
04CD                             ; Purpose:
04CD                             ;    Search through a list of Pascal STRINGS for a match.
04CD                             ; 
04CD                             ; Inputs:
04CD                             ;    HL - Points to the string to search for.
04CD                             ;    DE - Points to the start of the list of STRINGS.
04CD                             ; 
04CD                             ; Outputs:
04CD                             ;    ZF - True if match,false otherwise.
04CD                             ;    A - Index of the matching string if a match is found,or -1 if no match
04CD                             ;        is found.
04CD                             ;    HL - Points to the string to search for.
04CD                             ; 
04CD                             ; Destroyed:
04CD                             ;    A,B,C,D,E,A",F"
04CD                             ; *****************************************************************************
04CD                SEARCHSTR:      
04CD   06 00                  LD   b,0   ; init b with index 0
04CF                SEARCHSTR1:      
04CF   CD E5 04               CALL   compareStr   ; compare strings
04D2   20 02                  JR   nz,searchStr3   
04D4   78                     LD   a,b   ; Load index of match
04D5   C9                     RET      ; ZF = true
04D6                SEARCHSTR3:      
04D6   1A                     LD   a,(de)   ; Load length of current string
04D7   3C                     INC   a   ; A = length byte plus length of string
04D8   83                     ADD   a,e   ; DE += A, move DE to point to next string
04D9   5F                     LD   e,a   
04DA   3E 00                  LD   a,0   
04DC   8A                     ADC   a,d   
04DD   57                     LD   d,a   
04DE   04                     INC   b   ; increase index
04DF   1A                     LD   a,(de)   ; A = length of next string
04E0   B7                     OR   a   ; If A != 0,continue searching
04E1   20 EC                  JR   nz,searchStr1   
04E3   3D                     DEC   a   ; A = NO_MATCH (i.e.,-1),ZF = false
04E4   C9                     RET      
04E5                             ; *****************************************************************************
04E5                             ; Routine: compareStr
04E5                             ; 
04E5                             ; Purpose:
04E5                             ;    Compares two Pascal strings. The comparison includes
04E5                             ;    the length byte and continues until all characters are compared or a
04E5                             ;    mismatch is found.
04E5                             ; 
04E5                             ; Inputs:
04E5                             ;    DE - Points to the start of string1
04E5                             ;    HL - Points to the start of string2
04E5                             ; 
04E5                             ; Outputs:
04E5                             ;    ZF - Set if the strings are equal
04E5                             ; 
04E5                             ; Registers Destroyed:
04E5                             ;    A
04E5                             ; *****************************************************************************
04E5                COMPARESTR:      
04E5   C5                     PUSH   bc   ; save BC,DE,HL
04E6   D5                     PUSH   de   
04E7   E5                     PUSH   hl   
04E8   1A                     LD   a,(de)   ; Load length of search string
04E9   47                     LD   b,a   ; Copy length to B for looping
04EA   04                     INC   b   ; Increase to include length byte
04EB                COMPARESTR2:      
04EB   1A                     LD   a,(de)   ; Load next character from search string
04EC   BE                     CP   (hl)   ; Compare with next character in current string
04ED   20 04                  JR   nz,compareStr3   ; break if characters are not equal
04EF   13                     INC   de   ; Move to next character in search string
04F0   23                     INC   hl   ; Move to next character in current string
04F1   10 F8                  DJNZ   compareStr2   ; Loop until all characters compared or mismatch
04F3                COMPARESTR3:      
04F3   E1                     POP   hl   ; restore BC,DE,HL
04F4   D1                     POP   de   
04F5   C1                     POP   bc   
04F6   C9                     RET      ; Return with ZF set if strings are equal
04F7                             ; *****************************************************************************
04F7                             ; Routine: isEndOfLine
04F7                             ; 
04F7                             ; Purpose:
04F7                             ;    Checks if the token is the end-of-file (EOF) or a newline (NEWLN).
04F7                             ; 
04F7                             ; Inputs:
04F7                             ;    A - The token to check.
04F7                             ; 
04F7                             ; Outputs:
04F7                             ;    Z flag - Set if the token is EOF or NEWLN, cleared otherwise.
04F7                             ; 
04F7                             ; Registers Destroyed:
04F7                             ;    None
04F7                             ; *****************************************************************************
04F7                ISENDOFLINE:      
04F7   FE 00                  CP   EOF_   ; Compare the current character with EOF_
04F9   C8                     RET   z   ; Return if the current character is EOF (Z flag set)
04FA   FE 0A                  CP   NEWLN_   ; Compare the current character with NEWLN_
04FC   C9                     RET      ; Return (Z flag set if NEWLN_, cleared otherwise)
04FD                             ; *****************************************************************************
04FD                             ; Routine: isAlphaNum
04FD                             ; 
04FD                             ; Purpose:
04FD                             ;    Checks if the character in the A register is an alphanumeric character
04FD                             ;    (either uppercase or lowercase). If the character is alphabetic,it converts
04FD                             ;    it to uppercase and sets the carry flag. If the character is not alphabetic,
04FD                             ;    it clears the carry flag.
04FD                             ; 
04FD                             ; Input:
04FD                             ;    A - Contains the character to be checked.
04FD                             ; 
04FD                             ; Output:
04FD                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
04FD                             ;    CF - Set if the input character was alphabetic,cleared otherwise.
04FD                             ; 
04FD                             ; Destroyed:
04FD                             ;    C
04FD                             ; *****************************************************************************
04FD                ISALPHANUM:      
04FD   CD 13 05               CALL   isDigit   ; Check if it's a digit
0500   C8                     RET   z   ; If it's not a digit,continue to isAlpha
0501                             ; Falls through to isAlpha
0501                             ; *****************************************************************************
0501                             ; Routine: isAlpha
0501                             ; 
0501                             ; Purpose:
0501                             ;    Checks if the character in the A register is an alphabetic character
0501                             ;    (either uppercase or lowercase). If the character is alphabetic,it converts
0501                             ;    it to uppercase and sets the carry flag.
0501                             ; 
0501                             ; Input:
0501                             ;    A - Contains the character to be checked.
0501                             ; 
0501                             ; Output:
0501                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
0501                             ;    CF - Set if the input character was alphabetic,cleared otherwise.
0501                             ; 
0501                             ; Destroyed:
0501                             ;    None
0501                             ; *****************************************************************************
0501                ISALPHA:      
0501   FE 7B                  CP   "z"+1   ; Compare with "Z" + 1
0503   D0                     RET   nc   ; Return if it's not alphabetic,no carry
0504   FE 61                  CP   "a"   ; Compare with lowercase "a"
0506   38 04                  JR   c,isAlpha1   ; Jump if it"s lower than "a'
0508   D6 20                  SUB   $20   ; It's lowercase alpha so convert lowercase to uppercase
050A   37                     SCF      ; no carry so set carry flag
050B   C9                     RET      
050C                ISALPHA1:      
050C   FE 5B                  CP   "Z"+1   ; Compare with "Z" + 1
050E   D0                     RET   nc   ; Return if it's not alphabetic,no carry
050F   FE 41                  CP   "A"   ; Compare with "A"
0511   3F                     CCF      ; Invert CF to set it if it's alphabetic
0512   C9                     RET      
0513                             ; *****************************************************************************
0513                             ; Routine: isDigit
0513                             ; 
0513                             ; Purpose:
0513                             ;    Checks if the character in the A register is a decimal digit (0-9). If
0513                             ;    the character is a decimal digit,it sets the carry flag.
0513                             ; 
0513                             ; Input:
0513                             ;    A - Contains the character to be checked.
0513                             ; 
0513                             ; Output:
0513                             ;    CF - Set if the input character was a digit,cleared otherwise.
0513                             ; 
0513                             ; Destroyed:
0513                             ;    None
0513                             ; *****************************************************************************
0513                ISDIGIT:      
0513   FE 3A                  CP   "9"+1   ; Compare with "9" + 1
0515   D0                     RET   nc   ; Return if it's not a digit
0516   FE 30                  CP   "0"   ; Compare with "0"
0518   3F                     CCF      ; Invert CF to set it if it's a digit
0519   C9                     RET      
051A                             ; *****************************************************************************
051A                             ; Routine: decimal
051A                             ; 
051A                             ; Purpose:
051A                             ;    Parse a decimal number.
051A                             ; 
051A                             ; Input:
051A                             ;    None
051A                             ; 
051A                             ; Output:
051A                             ;    HL - Parsed number.
051A                             ; 
051A                             ; Destroyed:
051A                             ;    A,DE
051A                             ; *****************************************************************************
051A                DECIMAL:      
051A   21 00 00               LD   hl,0   ; Initialize HL to 0
051D                DECIMAL1:      
051D   D5                     PUSH   de   
051E   E5                     PUSH   hl   
051F   CD 66 05               CALL   nextChar   ; Get the next character
0522   E1                     POP   hl   
0523   D1                     POP   de   
0524   D6 30                  SUB   "0"   ; Convert ASCII to binary
0526   D8                     RET   c   ; Return if less than "0"
0527   FE 0A                  CP   10   ; Compare with 10
0529   D0                     RET   nc   ; Return if greater than 10
052A   03                     INC   bc   ; Increment BC to point to next digit
052B   54 5D                  LD   de,hl   ; Copy HL to DE
052D   29                     ADD   hl,hl   ; Multiply HL by 2
052E   29                     ADD   hl,hl   ; Multiply HL by 4
052F   19                     ADD   hl,de   ; Add DE to HL to multiply by 5
0530   29                     ADD   hl,hl   ; Multiply HL by 10
0531   85                     ADD   a,l   ; Add A to HL
0532   6F                     LD   l,a   ; Store result back in L
0533   3E 00                  LD   a,0   ; Clear A
0535   8C                     ADC   a,h   ; Add carry to H
0536   67                     LD   h,a   ; Store result back in H
0537   18 E4                  JR   decimal1   ; Jump back to start of loop
0539                             ; *****************************************************************************
0539                             ; Routine: hexadecimal
0539                             ; 
0539                             ; Purpose:
0539                             ;    Parse a hexadecimal number.
0539                             ; 
0539                             ; Input:
0539                             ;    None
0539                             ; 
0539                             ; Output:
0539                             ;    HL - Parsed number.
0539                             ; 
0539                             ; Destroyed:
0539                             ;    A
0539                             ; *****************************************************************************
0539                HEXADECIMAL:      
0539   21 00 00               LD   hl,0   ; Initialize HL to 0
053C                HEXADECIMAL1:      
053C   E5                     PUSH   hl   
053D   CD 66 05               CALL   nextChar   ; Get the next character
0540   E1                     POP   hl   
0541   FE 30                  CP   "0"   ; Compare with ASCII "0"
0543   D8                     RET   c   ; Return if less than "0"
0544   FE 3A                  CP   "9"+1   ; Compare with ASCII "9" + 1
0546   38 0F                  JR   c,hexadecimal4   ; If less or equal,jump to valid
0548   FE 61                  CP   "a"   ; Compare with ASCII "a"
054A   38 02                  JR   c,hexadecimal2   ; If less,jump to hexadecimal2
054C   D6 20                  SUB   $20   ; Convert lowercase to uppercase
054E                HEXADECIMAL2:      
054E   FE 41                  CP   "A"   ; Compare with ASCII "A"
0550   D8                     RET   c   ; Return if less than "A"
0551   FE 47                  CP   "F"+1   ; Compare with ASCII "F" + 1
0553   38 00                  JR   c,hexadecimal3   ; If less or equal,jump to hexadecimal3
0555                HEXADECIMAL3:      
0555   D6 37                  SUB   $37   ; Convert ASCII to hexadecimal
0557                HEXADECIMAL4:      
0557   D6 30                  SUB   "0"   ; Convert ASCII to numeric value
0559   D8                     RET   c   ; Return if less than 0 (not a valid digit)
055A   FE 10                  CP   $10   ; Compare with 16
055C   D0                     RET   nc   ; Return if greater than 16 (not a valid digit)
055D   29                     ADD   hl,hl   ; Multiply by 16
055E   29                     ADD   hl,hl   ; Multiply by 16
055F   29                     ADD   hl,hl   ; Multiply by 16
0560   29                     ADD   hl,hl   ; Multiply by 16
0561   85                     ADD   a,l   ; Add new digit to HL
0562   6F                     LD   l,a   ; Store result back in L
0563   C3 3C 05               JP   hexadecimal1   ; Jump back to hexadecimal1 to process next character
0566                             ; *****************************************************************************
0566                             ; Routine: nextChar
0566                             ; 
0566                             ; Purpose:
0566                             ;    Fetches the next character from the BUFFER. If the BUFFER is empty or
0566                             ;    contains a null character (0),it refills the BUFFER by calling nextLine.
0566                             ; 
0566                             ; Inputs:
0566                             ;    None
0566                             ; 
0566                             ; Outputs:
0566                             ;    A - The next character from the BUFFER
0566                             ; 
0566                             ; Registers Destroyed:
0566                             ;    A,D,E,HL
0566                             ; *****************************************************************************
0566                NEXTCHAR:      
0566   21 87 31               LD   hl,vBufferPos   ; Load the offset of BUFFER position variable
0569   7E                     LD   a,(hl)   ; Load the current position offset in the BUFFER into A
056A   FE 80                  CP   BUFFER_SIZE   ; Compare with BUFFER size
056C   CA 7D 05               JP   z,nextLine   ; Jump to nextLine if end of BUFFER
056F   11 00 30               LD   de,BUFFER   ; Load the MSB of the BUFFER's address into D
0572   83                     ADD   a,e   ; de += a
0573   5F                     LD   e,a   
0574   3E 00                  LD   a,0   
0576   8A                     ADC   a,d   
0577   57                     LD   d,a   
0578   1A                     LD   a,(de)   ; Load the character at the current BUFFER position into A
0579   34                     INC   (hl)   ; Increment the BUFFER position offset
057A   FE 0A                  CP   "\n"   ; if a != null return else load a new line into buffer
057C   C0                     RET   nz   
057D                NEXTLINE:      
057D   21 00 30               LD   hl,BUFFER   ; Start of the BUFFER
0580   06 80                  LD   b,BUFFER_SIZE   ; Number of bytes to fill
0582                NEXTLINE1:      
0582   CD 81 00               CALL   getchar   ; Get a character from getchar
0585   FE FF                  CP   EOF   ; is it EOF
0587   28 32                  JR   z,nextLine6   
0589   B7                     OR   a   ; is it NULL?
058A   28 04                  JR   z,nextLine2   
058C   FE 03                  CP   CTRL_C   ; is it ctrl-C ?
058E   20 04                  JR   nz,nextLine3   
0590                NEXTLINE2:      
0590   3E FF                  LD   a,EOF   
0592   18 27                  JR   nextLine6   
0594                NEXTLINE3:      
0594   FE 08                  CP   "\b"   ; Check if character is backspace
0596   20 10                  JR   nz,nextLine4   ; If not,proceed to store the character
0598   3E 80                  LD   a,BUFFER_SIZE   
059A   90                     SUB   b   ; Check if at the start of the buffer
059B   28 E5                  JR   z,nextLine1   ; If at the start,ignore backspace
059D   2B                     DEC   hl   ; Move back in the buffer
059E   04                     INC   b   ; Adjust buffer size counter
059F   CD ED 05               CALL   print   ; Erase the character at the current cursor position
05A2   03 1B 5B 50            .PSTR   ESC,"[P"   ; Escape sequence for erasing character
05A6   18 DA                  JR   nextLine1   
05A8                NEXTLINE4:      
05A8   CD 87 00               CALL   putchar   ; Echo character to terminal
05AB   FE 09                  CP   "\t"   
05AD   20 04                  JR   nz,nextLine5   ; if a == CR or NL replace with null
05AF   3E 20                  LD   a," "   
05B1   18 08                  JR   nextLine6   
05B3                NEXTLINE5:      
05B3   FE 0D                  CP   "\r"   ; Check if character is carriage return
05B5   20 04                  JR   nz,nextLine6   
05B7   3E 0A                  LD   a,"\n"   
05B9   18 00                  JR   nextLine6   
05BB                NEXTLINE6:      
05BB   77                     LD   (hl),a   ; Store the character in the BUFFER
05BC   23                     INC   hl   ; Move to the next position in the BUFFER
05BD   FE FF                  CP   EOF   ; Break loop if character is end of line
05BF   28 06                  JR   z,nextLine7   
05C1   FE 0A                  CP   "\n"   ; Break loop if character is end of line
05C3   28 02                  JR   z,nextLine7   
05C5   10 BB                  DJNZ   nextLine1   ; Repeat until BUFFER is full
05C7                NEXTLINE7:      
05C7   21 87 31               LD   hl,vBufferPos   
05CA   36 00                  LD   (hl),0   
05CC   18 98                  JR   nextChar   
05CE                             ; *****************************************************************************
05CE                             ; Routine: rewindChar
05CE                             ; 
05CE                             ; Purpose:
05CE                             ;    Rewinds the BUFFER position by one character,effectively pushing back the
05CE                             ;    BUFFER position by one character in the input stream.
05CE                             ; 
05CE                             ; Inputs:
05CE                             ;    None
05CE                             ; 
05CE                             ; Outputs:
05CE                             ;    None
05CE                             ; 
05CE                             ; Registers Destroyed:
05CE                             ;    A
05CE                             ; *****************************************************************************
05CE                REWINDCHAR:      
05CE   3A 87 31               LD   a,(vBufferPos)   ; Load the current position in the BUFFER into A
05D1   B7                     OR   a   ; Check if the BUFFER position is zero
05D2   C8                     RET   z   ; If zero,nothing to push back,return
05D3   3D                     DEC   a   ; Decrement the BUFFER position
05D4   32 87 31               LD   (vBufferPos),a   
05D7   C9                     RET      
05D8                             ; *****************************************************************************
05D8                             ; Routine: prompt
05D8                             ; 
05D8                             ; Purpose:
05D8                             ;    Prints a prompt symbol ("> ") to indicate readiness for user input.
05D8                             ; 
05D8                             ; Inputs:
05D8                             ;    None
05D8                             ; 
05D8                             ; Outputs:
05D8                             ;    None
05D8                             ; 
05D8                             ; Registers Destroyed:
05D8                             ;    A,HL
05D8                             ; *****************************************************************************
05D8                PROMPT:      
05D8   CD ED 05               CALL   print   ; Print the null-terminated string (prompt message)
05DB   04 0D 0A 3E 20         .PSTR   "\r\n> "   ; Define the prompt message
05E0   C9                     RET      ; Return to the caller
05E1                             ; *****************************************************************************
05E1                             ; Routine: crlf
05E1                             ; 
05E1                             ; Purpose:
05E1                             ;    Prints a carriage return and line feed (new line) to the output.
05E1                             ; 
05E1                             ; Inputs:
05E1                             ;    None
05E1                             ; 
05E1                             ; Outputs:
05E1                             ;    None
05E1                             ; 
05E1                             ; Registers Destroyed:
05E1                             ;    A,HL
05E1                             ; *****************************************************************************
05E1                CRLF:        
05E1   CD ED 05               CALL   print   ; Print the null-terminated string (carriage return and line feed)
05E4   02 0D 0A               .PSTR   "\r\n"   ; Define the carriage return and line feed message
05E7   C9                     RET      ; Return to the caller
05E8                             ; *****************************************************************************
05E8                             ; Routine: error
05E8                             ; 
05E8                             ; Purpose:
05E8                             ;    Prints an error message and halts execution.
05E8                             ; 
05E8                             ; Inputs:
05E8                             ;    (Stack) - The address of the error message to be printed
05E8                             ; 
05E8                             ; Outputs:
05E8                             ;    None
05E8                             ; 
05E8                             ; Registers Destroyed:
05E8                             ;    A,HL
05E8                             ; *****************************************************************************
05E8                ERROR:       
05E8   E1                     POP   hl   ; Retrieve the "return" address which is the address of the error message
05E9   CD F3 05               CALL   printStr   ; Call the routine to print the null-terminated string
05EC   76                     HALT      ; Halt the CPU
05ED                             ; *****************************************************************************
05ED                             ; Routine: print
05ED                             ; 
05ED                             ; Purpose:
05ED                             ;    Prints a pascal string starting from the address in HL.
05ED                             ; 
05ED                             ; Inputs:
05ED                             ;    HL - Points to the start of the string to be printed
05ED                             ; 
05ED                             ; Outputs:
05ED                             ;    None
05ED                             ; 
05ED                             ; Registers Destroyed:
05ED                             ;    A, B
05ED                             ; *****************************************************************************
05ED                PRINT:       
05ED   E3                     EX   (sp),hl   ; Swap HL with the value on the stack to preserve HL
05EE   CD F3 05               CALL   printStr   
05F1   E3                     EX   (sp),hl   
05F2   C9                     RET      
05F3                             ; *****************************************************************************
05F3                             ; Routine: printStr
05F3                             ; 
05F3                             ; Purpose:
05F3                             ;    Prints a Pascal string stored in memory.
05F3                             ; 
05F3                             ; Inputs:
05F3                             ;    HL - Points to the start of the string (first byte is the length)
05F3                             ; 
05F3                             ; Outputs:
05F3                             ;    None
05F3                             ; 
05F3                             ; Registers Destroyed:
05F3                             ;    A,B,HL
05F3                             ; *****************************************************************************
05F3                PRINTSTR:      
05F3   7E                     LD   a,(hl)   ; Load the length of the string
05F4   B7                     OR   a   ; Check if the length is zero
05F5   C8                     RET   z   ; If zero,return immediately
05F6   23                     INC   hl   ; Move HL to the start of the string data
05F7   47                     LD   b,a   ; Copy the length to B for looping
05F8                PRINTSTR1:      
05F8   7E                     LD   a,(hl)   ; Load the next character
05F9   CD 87 00               CALL   putchar   ; Call a routine that prints a single character
05FC   23                     INC   hl   ; Move to the next character
05FD   10 F9                  DJNZ   printStr1   ; Decrement B and jump if not zero
05FF   C9                     RET      ; Return from the routine
0600                             ; *****************************************************************************
0600                             ; Routine: hpush
0600                             ; 
0600                             ; Purpose:
0600                             ;    Pushes a 16-bit value onto the heap. The value to be pushed is in DE,
0600                             ;    and the heap pointer is updated accordingly.
0600                             ; 
0600                             ; Inputs:
0600                             ;    DE - The 16-bit value to be pushed onto the heap.
0600                             ; 
0600                             ; Outputs:
0600                             ;    Updates the heap pointer in vHeapPtr.
0600                             ; 
0600                             ; Registers Destroyed:
0600                             ;    DE,HL
0600                             ; *****************************************************************************
0600                HPUSH:       
0600   D5                     PUSH   de   ; Save DE
0601   EB                     EX   de,hl   ; Exchange DE and HL to move value to DE
0602   2A 8F 31               LD   hl,(vHeapPtr)   ; Load the current top of the heap into HL
0605   72                     LD   (hl),d   ; Store the high byte of DE (now in HL) on the heap
0606   23                     INC   hl   ; Increment HL to point to the next heap position
0607   73                     LD   (hl),e   ; Store the low byte of DE (now in HL) on the heap
0608   23                     INC   hl   ; Increment HL to point to the new top of the heap
0609   22 8F 31               LD   (vHeapPtr),hl   ; Update the heap pointer with the new top of the heap
060C   D1                     POP   de   ; Restore DE
060D   C9                     RET      ; Return from the subroutine
060E                             ; ; *****************************************************************************
060E                             ; ; Routine: hpop
060E                             ; ;
060E                             ; ; Purpose:
060E                             ; ;    Pops a 16-bit value from the heap into HL. The heap pointer is updated
060E                             ; ;    accordingly.
060E                             ; ;
060E                             ; ; Inputs:
060E                             ; ;    None
060E                             ; ;
060E                             ; ; Outputs:
060E                             ; ;    HL - Contains the 16-bit value popped from the heap.
060E                             ; ;    Updates the heap pointer in vHeapPtr.
060E                             ; ;
060E                             ; ; Registers Destroyed:
060E                             ; ;    DE,HL
060E                             ; ; *****************************************************************************
060E                             ; hpop:
060E                             ;     push de                   ; Save DE
060E                             ;     ld hl,(vHeapPtr)          ; Load the current top of the heap into HL
060E                             ;     dec hl                    ; Decrement HL to point to the high byte of the value
060E                             ;     ld l,(hl)                 ; Load the low byte of the value into L
060E                             ;     dec hl                    ; Decrement HL to point to the low byte of the value
060E                             ;     ld h,(hl)                 ; Load the high byte of the value into H
060E                             ;     ld (vHeapPtr),hl          ; Update the heap pointer with the new top of the heap
060E                             ;     ex de,hl                  ; Exchange DE and HL to move the value to HL
060E                             ;     pop de                    ; Restore DE
060E                             ;     ret                       ; Return from the subroutine
060E                             ; *******************************************************************************
060E                             ; *********  END OF MAIN   ******************************************************
060E                             ; *******************************************************************************
060E                ROT_OPCODES:      
060E   03 52 4C 43            .PSTR   "RLC"   
0612   03 52 52 43            .PSTR   "RRC"   
0616   02 52 4C               .PSTR   "RL"   
0619   02 52 52               .PSTR   "RR"   
061C   03 53 4C 41            .PSTR   "SLA"   
0620   03 53 52 41            .PSTR   "SRA"   
0624   03 53 4C 4C            .PSTR   "SLL"   
0628   03 53 52 4C            .PSTR   "SRL"   
062C   00                     .PSTR   ""   ; terminate list with a string of zero length
062D                ALU_OPCODES:      
062D   03 41 44 44            .PSTR   "ADD"   
0631   03 41 44 43            .PSTR   "ADC"   
0635   03 53 55 42            .PSTR   "SUB"   
0639   03 53 42 43            .PSTR   "SBC"   
063D   03 41 4E 44            .PSTR   "AND"   
0641   03 58 4F 52            .PSTR   "XOR"   
0645   02 4F 52               .PSTR   "OR"   
0648   02 43 50               .PSTR   "CP"   
064B   00                     .PSTR   ""   ; terminate list with a string of zero length
064C                BLI_OPCODES:      
064C   03 4C 44 49            .PSTR   "LDI"   
0650   03 43 50 49            .PSTR   "CPI"   
0654   03 49 4E 49            .PSTR   "INI"   
0658   04 4F 55 54 49         .PSTR   "OUTI"   
065D   03 4C 44 44            .PSTR   "LDD"   
0661   03 43 50 44            .PSTR   "CPD"   
0665   03 49 4E 44            .PSTR   "IND"   
0669   04 4F 55 54 44         .PSTR   "OUTD"   
066E   04 4C 44 49 52         .PSTR   "LDIR"   
0673   04 43 50 49 52         .PSTR   "CPIR"   
0678   04 49 4E 49 52         .PSTR   "INIR"   
067D   04 4F 54 49 52         .PSTR   "OTIR"   
0682   04 4C 44 44 52         .PSTR   "LDDR"   
0687   04 43 50 44 52         .PSTR   "CPDR"   
068C   04 49 4E 44 52         .PSTR   "INDR"   
0691   04 4F 54 44 52         .PSTR   "OTDR"   
0696   00                     .PSTR   ""   ; terminate list with a string of zero length
0697                GEN1_OPCODES:      
0697   03 43 43 46            .PSTR   "CCF"   
069B   03 43 50 4C            .PSTR   "CPL"   
069F   03 44 41 41            .PSTR   "DAA"   
06A3   02 44 49               .PSTR   "DI"   
06A6   02 45 49               .PSTR   "EI"   
06A9   04 48 41 4C 54         .PSTR   "HALT"   
06AE   03 4E 4F 50            .PSTR   "NOP"   
06B2   04 52 4C 43 41         .PSTR   "RLCA"   
06B7   03 52 53 54            .PSTR   "RST"   
06BB   03 53 43 46            .PSTR   "SCF"   
06BF   00                     .PSTR   ""   ; terminate list with a string of zero length
06C0                GEN2_OPCODES:      
06C0   03 42 49 54            .PSTR   "BIT"   
06C4   04 43 41 4C 4C         .PSTR   "CALL"   
06C9   03 44 45 43            .PSTR   "DEC"   
06CD   04 44 4A 4E 5A         .PSTR   "DJNZ"   
06D2   02 45 58               .PSTR   "EX"   
06D5   03 45 58 58            .PSTR   "EXX"   
06D9   02 49 4D               .PSTR   "IM"   
06DC   02 49 4E               .PSTR   "IN"   
06DF   03 49 4E 43            .PSTR   "INC"   
06E3   02 4A 50               .PSTR   "JP"   
06E6   02 4A 52               .PSTR   "JR"   
06E9   02 4C 44               .PSTR   "LD"   
06EC   03 4E 45 47            .PSTR   "NEG"   
06F0   03 4F 55 54            .PSTR   "OUT"   
06F4   03 50 4F 50            .PSTR   "POP"   
06F8   04 50 55 53 48         .PSTR   "PUSH"   
06FD   03 52 45 53            .PSTR   "RES"   
0701   03 52 45 54            .PSTR   "RET"   
0705   04 52 45 54 49         .PSTR   "RETI"   
070A   04 52 45 54 4E         .PSTR   "RETN"   
070F   03 52 4C 41            .PSTR   "RLA"   
0713   03 52 4C 44            .PSTR   "RLD"   
0717   03 52 52 41            .PSTR   "RRA"   
071B   04 52 52 43 41         .PSTR   "RRCA"   
0720   03 52 52 44            .PSTR   "RRD"   
0724   03 53 45 54            .PSTR   "SET"   
0728   00                     .PSTR   ""   ; terminate list with a string of zero length
0729                REG8:        
0729   01 42                  .PSTR   "B"   
072B   01 43                  .PSTR   "C"   
072D   01 44                  .PSTR   "D"   
072F   01 45                  .PSTR   "E"   
0731   01 48                  .PSTR   "H"   
0733   01 4C                  .PSTR   "L"   
0735   01 20                  .PSTR   " "   ; don't match, stand-in for (HL)
0737   01 41                  .PSTR   "A"   
0739   01 49                  .PSTR   "I"   
073B   01 52                  .PSTR   "R"   
073D   00                     .PSTR   ""   ; terminate list with a string of zero length
073E                REG16:       
073E   02 42 43               .PSTR   "BC"   
0741   02 44 45               .PSTR   "DE"   
0744   02 48 4C               .PSTR   "HL"   
0747   02 53 50               .PSTR   "SP"   
074A   03 41 46 27            .PSTR   "AF'"   
074E   02 41 46               .PSTR   "AF"   ; NOTE: AF has the same code as SP in some instructions
0751   02 49 58               .PSTR   "IX"   
0754   02 49 59               .PSTR   "IY"   
0757   00                     .PSTR   ""   ; terminate list with a string of zero length
0758                FLAGS:       
0758   02 4E 5A               .PSTR   "NZ"   
075B   01 5A                  .PSTR   "Z"   
075D   02 4E 43               .PSTR   "NC"   
0760   01 43                  .PSTR   "C"   
0762   02 50 4F               .PSTR   "PO"   
0765   02 50 45               .PSTR   "PE"   
0768   01 50                  .PSTR   "P"   
076A   01 4D                  .PSTR   "M"   
076C   00                     .PSTR   ""   ; terminate list with a string of zero length
076D                DIRECTIVES:      
076D   06 2E 41 4C 49 47 4E   .PSTR   ".ALIGN"   
0774   03 2E 44 42            .PSTR   ".DB"   
0778   04 2E 4F 52 47         .PSTR   ".ORG"   
077D   04 2E 53 45 54         .PSTR   ".SET"   
0782   00                     .PSTR   ""   ; terminate list with a string of zero length
0783                             ; *******************************************************************************
0783                             ; *********  END OF DATA   ******************************************************
0783                             ; *******************************************************************************
3000                          .ORG   RAMSTART   
3000                          ALIGN   $100   
3000                BUFFER:   DS   BUFFER_SIZE   ; line BUFFER,page aligned
3080                          DS   $100   
3180                STACK:       ; grows down
3180                VTEMP1:   DS   2   ; temp var 1
3182                VTEMP2:   DS   2   ; temp var 2
3184                VTOKEN:   DS   1   ; BUFFER for pushed back token
3185                VTOKENVAL:   DS   2   ; BUFFER for pushed back token value
3187                VBUFFERPOS:   DS   2   ; pointer to char position into input BUFFER
3189                VASMPTR:   DS   2   ; pointer to ASSEMBLY point
318B                VSYMPTR:   DS   2   ; pointer to last symbol
318D                VEXPRPTR:   DS   2   ; pointer to last expression
318F                VHEAPPTR:   DS   2   ; pointer to Heap
3191                VISBRANCH:   DS   1   
3192                VOPCODE:   DS   1   ; must be contiguous for expect
3193                VOP1:        ; operand1 lsb = type, msb = val
3193                VOP1TYPE:   DS   1   
3194                VOP1VAL:   DS   1   
3195                VOP2:        ; operand2 lsb = type, msb = val
3195                VOP2TYPE:   DS   1   
3196                VOP2VAL:   DS   1   
3197                VOPEXPR:   DS   2   
3199                VOPDISP:   DS   2   
319B                RST08:    DS   2   
319D                RST10:    DS   2   
319F                RST18:    DS   2   
31A1                RST20:    DS   2   
31A3                RST28:    DS   2   
31A5                RST30:    DS   2   
31A7                BAUD:     DS   2   
31A9                INTVEC:   DS   2   
31AB                NMIVEC:   DS   2   
31AD                GETCVEC:   DS   2   
31AF                PUTCVEC:   DS   2   
31B1                HEAP:     DS   HEAP_SIZE   ; expression heap - grows up
32B1                ASSEMBLY:      
4000                          .ORG   $4000   
4000                TESTSSTART:      
4000   31 80 31               LD   sp,STACK   
4003                             ; ; ------------------------------------------------------------
4003                             ; call test
4003                             ; .db "ld a,1"
4003                             ; .db 0
4003                             ; call expectOps
4003                             ; .db OUT_, reg_ | indirect_ , C_, reg_ , A_
4003                             ; ------------------------------------------------------------
4003   CD C1 40               CALL   test   
4006   6F 75 74 20 28 63 29 2C 61 DB   "out (c),a"   
400F   00                     DB   0   
4010   CD F5 40               CALL   expectOps   
4013   8D 06 01 02 07         DB   OUT_,reg_ | indirect_,C_,reg_,A_   
4018                             ; ------------------------------------------------------------
4018   CD C1 40               CALL   test   
401B   69 6E 20 61 2C 28 63 29 DB   "in a,(c)"   
4023   00                     DB   0   
4024   CD F5 40               CALL   expectOps   
4027   87 02 07 06 01         DB   IN_,reg_,A_,reg_ | indirect_,C_   
402C                             ; ------------------------------------------------------------
402C   CD C1 40               CALL   test   
402F   6C 64 20 61 2C 28 69 78 20 2B 20 30 29 DB   "ld a,(ix + 0)"   
403C   00                     DB   0   
403D   CD F5 40               CALL   expectOps   
4040   8B 02 07 0F 06         DB   LD_,reg_,A_,rp_ | indirect_ |index_,IX_   
4045                             ; ------------------------------------------------------------
4045   CD C1 40               CALL   test   
4048   6C 64 20 61 2C 28 68 6C 29 DB   "ld a,(hl)"   
4051   00                     DB   0   
4052   CD F5 40               CALL   expectOps   
4055   8B 02 07 07 02         DB   LD_,reg_,A_,rp_ | indirect_,HL_   
405A                             ; ------------------------------------------------------------
405A   CD C1 40               CALL   test   
405D   72 65 74 20 63         DB   "ret c"   
4062   00                     DB   0   
4063   CD F5 40               CALL   expectOps   
4066   91 01 03 FF FF         DB   RET_,flag_,CF_,-1,-1   
406B                             ; ------------------------------------------------------------
406B   CD C1 40               CALL   test   
406E   6A 70 20 6E 7A 2C 30   DB   "jp nz,0"   
4075   00                     DB   0   
4076   CD F5 40               CALL   expectOps   
4079   89 01 00 00 FF         DB   JP_,flag_,NZ_,immed_,-1   
407E                             ; ------------------------------------------------------------
407E   CD C1 40               CALL   test   
4081   6A 70 20 30            DB   "jp 0"   
4085   00                     DB   0   
4086   CD F5 40               CALL   expectOps   
4089   89 FF FF 00 FF         DB   JP_,-1,-1,immed_,-1   
408E                             ; ------------------------------------------------------------
408E   CD C1 40               CALL   test   
4091   68 61 6C 74            DB   "halt"   
4095   00                     DB   0   
4096   CD F5 40               CALL   expectOps   
4099   65 FF FF FF FF         DB   HALT_,-1,-1,-1,-1   
409E                             ; ------------------------------------------------------------
409E   CD C1 40               CALL   test   
40A1   00                     DB   0   
40A2   CD D9 40               CALL   expect   
40A5   00                     DB   0   
40A6                             ; ------------------------------------------------------------
40A6                             ; .cstr "It should assemble one instruction"
40A6                             ; call expect
40A6                             ; .db 01,$76
40A6   CD ED 05               CALL   print   
40A9   07 0D 0A 44 6F 6E 65 21 .PSTR   "\r\nDone!"   
40B1   76                     HALT      
40B2                             ; *****************************************************************************
40B2                             ; Test variables
40B2                             ; *****************************************************************************
40B2                EMPTYSTR:      
40B2   00                     .PSTR   ""   
40B3                TBDESC:      
40B3   B2 40                  DW   emptyStr   ; Address of the description
40B5                TBTEXT:      
40B5   00 00                  DW   0   ; Address of the test text
40B7                TBPTR:       
40B7   00 00                  DW   0   ; Pointer to the current position in the test text
40B9                             ; *****************************************************************************
40B9                             ; Routine: describe
40B9                             ; 
40B9                             ; Purpose:
40B9                             ;    Stores the address of a description string in tbDesc and then skips the string.
40B9                             ; 
40B9                             ; Inputs:
40B9                             ;    HL - Address of the description string
40B9                             ; 
40B9                             ; Outputs:
40B9                             ;    None
40B9                             ; 
40B9                             ; Registers Destroyed:
40B9                             ;    HL
40B9                             ; *****************************************************************************
40B9                DESCRIBE:      
40B9   E1                     POP   hl   ; Retrieve the return address (address of the description string)
40BA   22 B3 40               LD   (tbDesc),hl   ; Store the address in tbDesc
40BD   CD 0F 42               CALL   skipStr   ; Skip the description string
40C0   E9                     JP   (hl)   ; Jump to the address specified by the next byte
40C1                             ; *****************************************************************************
40C1                             ; Routine: test
40C1                             ; 
40C1                             ; Purpose:
40C1                             ;    Stores the address of a test text in tbText and tbPtr,and then skips the string.
40C1                             ; 
40C1                             ; Inputs:
40C1                             ;    HL - Address of the test text
40C1                             ; 
40C1                             ; Outputs:
40C1                             ;    None
40C1                             ; 
40C1                             ; Registers Destroyed:
40C1                             ;    HL
40C1                             ; *****************************************************************************
40C1                TEST:        
40C1   E1                     POP   hl   ; Retrieve the return address (address of the test text)
40C2   22 B5 40               LD   (tbText),hl   ; Store the address in tbText
40C5   22 B7 40               LD   (tbPtr),hl   ; Initialize tbPtr with the address of the test text
40C8   CD 07 42               CALL   skipZStr   ; Skip the test text string
40CB   23                     INC   hl   ; Move to the next byte after the null terminator
40CC   E5                     PUSH   hl   ; push new return address
40CD   CD 98 01               CALL   init   ; Initialize the environment
40D0   21 CB 41               LD   hl,testGetCharImpl   ; Load the address of testGetCharImpl
40D3   22 AD 31               LD   (GETCVEC),hl   ; Set the GETCVEC to point to testGetCharImpl
40D6   C3 FC 01               JP   statementList   
40D9                             ; *****************************************************************************
40D9                             ; Routine: expect
40D9                             ; 
40D9                             ; Purpose:
40D9                             ;    Initializes the environment,sets up the testGetCharImpl,executes the statementList,
40D9                             ;    and compares the result with the expected output.
40D9                             ; 
40D9                             ; Inputs:
40D9                             ;    None
40D9                             ; 
40D9                             ; Outputs:
40D9                             ;    None
40D9                             ; 
40D9                             ; Registers Destroyed:
40D9                             ;    HL,DE
40D9                             ; *****************************************************************************
40D9                EXPECT:      
40D9   E1                     POP   hl   ; Retrieve the return address
40DA   11 B1 32               LD   de,ASSEMBLY   ; Load the expected output address into DE
40DD   CD E5 04               CALL   compareStr   ; Compare the result with the expected output
40E0   20 01                  JR   nz,expect1   ; If comparison fails,jump to expect1
40E2   E9                     JP   (hl)   ; If comparison succeeds,jump to the return address
40E3                EXPECT1:      
40E3   CD ED 05               CALL   print   ; Print the failure message
40E6   07 46 61 69 6C 65 64 21 .PSTR   "Failed!"   
40EE   2A B5 40               LD   hl,(tbText)   ; Load the address of the test text
40F1   CD FC 41               CALL   printZStr   ; Print the test text
40F4   76                     HALT      ; Halt the program
40F5                             ; *****************************************************************************
40F5                             ; Routine: expectOps
40F5                             ; 
40F5                             ; Purpose:
40F5                             ;    Validate the sequence of opcode and operands against expected values.
40F5                             ;    Print error messages if any mismatch occurs and jump to the next handler.
40F5                             ; 
40F5                             ; Inputs:
40F5                             ;    DE - Points to the expected op data
40F5                             ;    HL - Points to the actual op data
40F5                             ; 
40F5                             ; Outputs:
40F5                             ;    Updates DE and HL as it processes each byte in the sequences.
40F5                             ; 
40F5                             ; Registers Destroyed:
40F5                             ;    A,DE,HL
40F5                             ; *****************************************************************************
40F5                EXPECTOPS:      
40F5   CD E1 05               CALL   crlf   
40F8   D1                     POP   de   ; Load DE with the return address pointing to the actual opcode/operand sequence
40F9   21 92 31               LD   hl,vOpcode   ; Load HL with the address of the expected opcode/operand sequence
40FC   CD 76 41               CALL   expectOpItem   ; Compare actual and expected opcode
40FF   57 72 6F 6E 67 20 6F 70 63 6F 64 65 00 .CSTR   "Wrong opcode"   ; Error message if the opcode does not match
410C   CD 76 41               CALL   expectOpItem   ; Compare actual and expected first operand
410F   57 72 6F 6E 67 20 6F 70 65 72 61 6E 64 20 74 79 70 65 20 31 00 .CSTR   "Wrong operand type 1"   ; Error message if the first operand does not match
4124   CD 76 41               CALL   expectOpItem   ; Compare actual and expected first operand
4127   57 72 6F 6E 67 20 6F 70 65 72 61 6E 64 20 76 61 6C 75 65 20 31 00 .CSTR   "Wrong operand value 1"   ; Error message if the first operand does not match
413D   CD 76 41               CALL   expectOpItem   ; Compare actual and expected second operand
4140   57 72 6F 6E 67 20 6F 70 65 72 61 6E 64 20 74 79 70 65 20 32 00 .CSTR   "Wrong operand type 2"   ; Error message if the second operand does not match
4155   CD 76 41               CALL   expectOpItem   ; Compare actual and expected first operand
4158   57 72 6F 6E 67 20 6F 70 65 72 61 6E 64 20 76 61 6C 75 65 20 32 00 .CSTR   "Wrong operand value 2"   ; Error message if the first operand does not match
416E   21 B2 40               LD   hl,emptyStr   ; set description to ""
4171   22 B3 40               LD   (tbDesc),hl   
4174   EB                     EX   de,hl   
4175   E9                     JP   (hl)   ; Jump to the address after expected op data
4176                             ; *****************************************************************************
4176                             ; Routine: expectOpItem
4176                             ; 
4176                             ; Purpose:
4176                             ;    Compare the actual and expected opcode/operand byte and handle mismatches.
4176                             ; 
4176                             ; Inputs:
4176                             ;    DE - Points to the expected byte.
4176                             ;    HL - Points to the actual byte.
4176                             ; 
4176                             ; Outputs:
4176                             ;    Increments DE and HL to the next byte in the sequences.
4176                             ;    Prints error messages if any mismatch occurs.
4176                             ; 
4176                             ; Registers Destroyed:
4176                             ;    A,DE,HL
4176                             ; *****************************************************************************
4176                EXPECTOPITEM:      
4176   1A                     LD   a,(de)   ; Load the expected byte into A from DE
4177   FE FF                  CP   -1   ; skip?
4179   28 03                  JR   z,expectOpItem1   
417B   BE                     CP   (hl)   ; Compare expected with actual
417C   20 09                  JR   nz,expectOpItem2   ; If bytes match Return if the bytes match
417E                EXPECTOPITEM1:      
417E   13                     INC   de   ; Move DE to point to next expected byte
417F   23                     INC   hl   ; Move HL to point to next actual byte
4180   E3                     EX   (sp),hl   ; HL = expected string to skip (sp) = actual*
4181   CD 07 42               CALL   skipZStr   ; Skip the message string
4184   23                     INC   hl   ; Move to the next byte after the null terminator
4185   E3                     EX   (sp),hl   ; HL = actual* (SP) = expected string to skip
4186   C9                     RET      ; return after message string
4187                EXPECTOPITEM2:      
4187   E3                     EX   (sp),hl   ; save hl, hl = expected message
4188   D5                     PUSH   de   ; save de
4189   E5                     PUSH   hl   ; save message
418A   CD E1 05               CALL   crlf   
418D   2A B3 40               LD   hl,(tbDesc)   ; Load the address of the test text
4190   CD F3 05               CALL   printStr   ; Print the test description
4193   CD E1 05               CALL   crlf   
4196   E1                     POP   hl   ; HL = expected message
4197   CD FC 41               CALL   printZStr   ; Print the test description
419A   CD E1 05               CALL   crlf   
419D   CD E1 05               CALL   crlf   
41A0   CD ED 05               CALL   print   ; Print error messages if the bytes do not match
41A3   0A 45 78 70 65 63 74 65 64 3A 20 .PSTR   "Expected: "   ; Print "Expected"
41AE   E1                     POP   hl   
41AF   7E                     LD   a,(hl)   ; Load the expected byte into A for printing
41B0   CD E1 41               CALL   printHex2   ; Print the expected byte in hexadecimal
41B3   CD E1 05               CALL   crlf   
41B6   CD ED 05               CALL   print   ; Print "Received"
41B9   08 41 63 74 75 61 6C 3A 20 .PSTR   "Actual: "   
41C2   E1                     POP   hl   
41C3   7E                     LD   a,(hl)   ; Load the actual byte into A for printing
41C4   CD E1 41               CALL   printHex2   ; Print the actual byte in hexadecimal
41C7   CD E1 05               CALL   crlf   
41CA   76                     HALT      ; Halt the program
41CB                             ; *****************************************************************************
41CB                             ; Routine: testGetCharImpl
41CB                             ; 
41CB                             ; Purpose:
41CB                             ;    Retrieves the next character from the test text.
41CB                             ; 
41CB                             ; Inputs:
41CB                             ;    tbPtr - Pointer to the current position in the test text
41CB                             ; 
41CB                             ; Outputs:
41CB                             ;    A - The next character from the test text
41CB                             ; 
41CB                             ; Registers Destroyed:
41CB                             ;    A,HL
41CB                             ; *****************************************************************************
41CB                TESTGETCHARIMPL:      
41CB   E5                     PUSH   hl   ; Save HL register
41CC   2A B7 40               LD   hl,(tbPtr)   ; Load the current pointer from tbPtr
41CF   7E                     LD   a,(hl)   ; Load the next character from the test text
41D0   23                     INC   hl   ; Move to the next character
41D1   22 B7 40               LD   (tbPtr),hl   ; Update tbPtr with the new pointer
41D4   E1                     POP   hl   ; Restore HL register
41D5   C9                     RET      ; Return with the character in A
41D6                             ; *****************************************************************************
41D6                             ; Routine: printHex
41D6                             ; 
41D6                             ; Purpose:
41D6                             ;    Displays the 16-bit value in the HL register as a hexadecimal number.
41D6                             ; 
41D6                             ; Inputs:
41D6                             ;    HL - The 16-bit value to be displayed.
41D6                             ; 
41D6                             ; Outputs:
41D6                             ;    None
41D6                             ; 
41D6                             ; Registers Destroyed:
41D6                             ;    A,C
41D6                             ; *****************************************************************************
41D6                PRINTHEX:      
41D6   C5                     PUSH   bc   ; Preserve the BC register pair
41D7   7C                     LD   a,h   ; Load the high byte of HL into A
41D8   CD E1 41               CALL   printHex2   ; Print the high byte as hex
41DB   7D                     LD   a,l   ; Load the low byte of HL into A
41DC   CD E1 41               CALL   printHex2   ; Print the low byte as hex
41DF   C1                     POP   bc   ; Restore the BC register pair
41E0   C9                     RET      ; Return from the routine
41E1                             ; *****************************************************************************
41E1                             ; Routine: printHex2
41E1                             ; 
41E1                             ; Purpose:
41E1                             ;    Prints a single byte in hexadecimal format by printing its high and low nibbles.
41E1                             ; 
41E1                             ; Inputs:
41E1                             ;    A - The byte to be printed.
41E1                             ; 
41E1                             ; Outputs:
41E1                             ;    None.
41E1                             ; 
41E1                             ; Registers Destroyed:
41E1                             ;    A,C
41E1                             ; *****************************************************************************
41E1                PRINTHEX2:      
41E1   4F                     LD   c,a   ; Copy the value in A to C
41E2   1F                     RRA      ; Shift the high nibble to the low nibble
41E3   1F                     RRA      
41E4   1F                     RRA      
41E5   1F                     RRA      
41E6   CD EA 41               CALL   printHex3   ; Print the high nibble as hex
41E9   79                     LD   a,c   ; Restore the original value to A
41EA                PRINTHEX3:      
41EA   E6 0F                  AND   0x0F   ; Mask out the upper nibble
41EC   C6 90                  ADD   a,0x90   ; Add 0x90 to adjust for the ASCII range
41EE   27                     DAA      ; Decimal adjust A to get the correct ASCII value
41EF   CE 40                  ADC   a,0x40   ; Add 0x40 to get the ASCII character for 0-9/A-F
41F1   27                     DAA      ; Decimal adjust A to get the correct ASCII value
41F2   C3 87 00               JP   putchar   ; Jump to the putchar routine to display the character
41F5                             ; 
41F5                             ; *****************************************************************************
41F5                             ; Routine: print
41F5                             ; 
41F5                             ; Purpose:
41F5                             ;    Prints a null-terminated string starting from the address in HL.
41F5                             ; 
41F5                             ; Inputs:
41F5                             ;    HL - Points to the start of the string to be printed
41F5                             ; 
41F5                             ; Outputs:
41F5                             ;    None
41F5                             ; 
41F5                             ; Registers Destroyed:
41F5                             ;    A, B
41F5                             ; *****************************************************************************
41F5                ZPRINT:      
41F5   E3                     EX   (sp),hl   ; Swap HL with the value on the stack to preserve HL
41F6   CD FC 41               CALL   printZStr   ; Call the routine to print the null-terminated string
41F9   23                     INC   hl   ; Increment HL to skip the null terminator
41FA   E3                     EX   (sp),hl   ; Restore the original value of HL from the stack
41FB   C9                     RET      ; Return to the caller
41FC                             ; *****************************************************************************
41FC                             ; Routine: printZStr
41FC                             ; 
41FC                             ; Purpose:
41FC                             ;    Prints a null-terminated string stored in memory.
41FC                             ; 
41FC                             ; Inputs:
41FC                             ;    HL - Points to the start of the string to be printed
41FC                             ; 
41FC                             ; Outputs:
41FC                             ;    None
41FC                             ; 
41FC                             ; Registers Destroyed:
41FC                             ;    A,HL
41FC                             ; *****************************************************************************
41FC                PRINTZSTR:      
41FC   18 04                  JR   printZStr2   ; Jump to the loop condition
41FE                PRINTZSTR1:      
41FE   CD 87 00               CALL   putchar   ; Print the current character
4201   23                     INC   hl   ; Move to the next character
4202                PRINTZSTR2:      
4202   7E                     LD   a,(hl)   ; Load the current character
4203   B7                     OR   a   ; Check if the character is null
4204   20 F8                  JR   nz,printZStr1   ; If not null,continue printing
4206   C9                     RET      ; Return when null character is encountered
4207                             ; *****************************************************************************
4207                             ; Routine: skipZStr
4207                             ; 
4207                             ; Purpose:
4207                             ;    Skips over a null-terminated string in memory,advancing the HL register
4207                             ;    to the character following the null terminator.
4207                             ; 
4207                             ; Inputs:
4207                             ;    HL - Points to the start of the string to skip.
4207                             ; 
4207                             ; Outputs:
4207                             ;    HL - Points to the character immediately after the null terminator.
4207                             ; 
4207                             ; Registers Destroyed:
4207                             ;    A
4207                             ; *****************************************************************************
4207                SKIPZSTR:      
4207   18 01                  JR   skipZStr2   ; Jump to the character loading step
4209                SKIPZSTR1:      
4209   23                     INC   hl   ; Move to the next character
420A                SKIPZSTR2:      
420A   7E                     LD   a,(hl)   ; Load the current character
420B   B7                     OR   a   ; Check if the character is null
420C   20 FB                  JR   nz,skipZStr1   ; If not null,continue to the next character
420E   C9                     RET      ; Return when a null character is found
420F                             ; *****************************************************************************
420F                             ; Routine: skipStr
420F                             ; 
420F                             ; Purpose:
420F                             ;    Skips over a pascal string in memory,advancing the HL register
420F                             ;    to the character following the null terminator.
420F                             ; 
420F                             ; Inputs:
420F                             ;    HL - Points to the start of the string to skip.
420F                             ; 
420F                             ; Outputs:
420F                             ;    HL - Points to the character immediately after the string.
420F                             ; 
420F                             ; Registers Destroyed:
420F                             ;    A
420F                             ; *****************************************************************************
420F                SKIPSTR:      
420F   7E                     LD   a,(hl)   ; a = length
4210   23                     INC   hl   ; Move to the next character
4211   85                     ADD   a,l   ; hl += a
4212   6F                     LD   l,a   
4213   3E 00                  LD   a,0   
4215   8C                     ADC   a,h   
4216   67                     LD   h,a   
4217   C9                     RET      
4218                             ; call test
4218                             ; ; .db "label1: LD A,42;comment\r\n"
4218                             ; ; .db "halt"
4218                             ; .db 0


ROMSTART:           0000 DEFINED AT LINE 1 IN constants.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 116 IN IOSerial.asm
                    > USED AT LINE 122 IN IOSerial.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 134 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 146 IN IOSerial.asm
                    > USED AT LINE 152 IN IOSerial.asm
                    > USED AT LINE 158 IN IOSerial.asm
                    > USED AT LINE 200 IN IOSerial.asm
                    > USED AT LINE 17 IN MAIN.asm
RAMSTART:           3000 DEFINED AT LINE 2 IN constants.asm
                    > USED AT LINE 1 IN ram.asm
ROMSIZE:            3000 DEFINED AT LINE 3 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 4 IN constants.asm
EOF:                00-1 DEFINED AT LINE 6 IN constants.asm
                    > USED AT LINE 510 IN MAIN.asm
                    > USED AT LINE 1114 IN MAIN.asm
                    > USED AT LINE 1122 IN MAIN.asm
                    > USED AT LINE 1155 IN MAIN.asm
NULL:               0000 DEFINED AT LINE 7 IN constants.asm
                    > USED AT LINE 439 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 8 IN constants.asm
                    > USED AT LINE 1118 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 9 IN constants.asm
ESC:                001B DEFINED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 1135 IN MAIN.asm
NO_MATCH:           00-1 DEFINED AT LINE 11 IN constants.asm
BUFFER_SIZE:        0080 DEFINED AT LINE 13 IN constants.asm
                    > USED AT LINE 1095 IN MAIN.asm
                    > USED AT LINE 1110 IN MAIN.asm
                    > USED AT LINE 1128 IN MAIN.asm
                    > USED AT LINE 5 IN ram.asm
HEAP_SIZE:          0100 DEFINED AT LINE 14 IN constants.asm
                    > USED AT LINE 45 IN ram.asm
TOKENS:             0000 DEFINED AT LINE 16 IN constants.asm
COLON_:             000: DEFINED AT LINE 18 IN constants.asm
COMMA_:             000, DEFINED AT LINE 19 IN constants.asm
                    > USED AT LINE 259 IN MAIN.asm
                    > USED AT LINE 429 IN MAIN.asm
DOLLAR_:            000$ DEFINED AT LINE 20 IN constants.asm
                    > USED AT LINE 588 IN MAIN.asm
LPAREN_:            000( DEFINED AT LINE 21 IN constants.asm
                    > USED AT LINE 293 IN MAIN.asm
MINUS_:             000- DEFINED AT LINE 22 IN constants.asm
NEWLN_:             000
 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 125 IN MAIN.asm
                    > USED AT LINE 523 IN MAIN.asm
                    > USED AT LINE 899 IN MAIN.asm
PLUS_:              000+ DEFINED AT LINE 24 IN constants.asm
RPAREN_:            000) DEFINED AT LINE 25 IN constants.asm
                    > USED AT LINE 318 IN MAIN.asm
                    > USED AT LINE 426 IN MAIN.asm
EOF_:               0000 DEFINED AT LINE 26 IN constants.asm
                    > USED AT LINE 123 IN MAIN.asm
                    > USED AT LINE 512 IN MAIN.asm
                    > USED AT LINE 897 IN MAIN.asm
DIRECT_:            0001 DEFINED AT LINE 27 IN constants.asm
                    > USED AT LINE 173 IN MAIN.asm
                    > USED AT LINE 572 IN MAIN.asm
IDENT_:             0002 DEFINED AT LINE 28 IN constants.asm
                    > USED AT LINE 576 IN MAIN.asm
LABEL_:             0003 DEFINED AT LINE 29 IN constants.asm
                    > USED AT LINE 162 IN MAIN.asm
                    > USED AT LINE 547 IN MAIN.asm
NUM_:               0004 DEFINED AT LINE 30 IN constants.asm
                    > USED AT LINE 595 IN MAIN.asm
                    > USED AT LINE 605 IN MAIN.asm
OPCODE_:            0005 DEFINED AT LINE 31 IN constants.asm
                    > USED AT LINE 170 IN MAIN.asm
                    > USED AT LINE 557 IN MAIN.asm
OPELEM_:            0006 DEFINED AT LINE 32 IN constants.asm
                    > USED AT LINE 290 IN MAIN.asm
                    > USED AT LINE 304 IN MAIN.asm
                    > USED AT LINE 563 IN MAIN.asm
UNKNOWN_:           0064 DEFINED AT LINE 33 IN constants.asm
                    > USED AT LINE 619 IN MAIN.asm
ALU_:               0000 DEFINED AT LINE 35 IN constants.asm
                    > USED AT LINE 43 IN constants.asm
                    > USED AT LINE 44 IN constants.asm
                    > USED AT LINE 45 IN constants.asm
                    > USED AT LINE 46 IN constants.asm
                    > USED AT LINE 47 IN constants.asm
                    > USED AT LINE 48 IN constants.asm
                    > USED AT LINE 49 IN constants.asm
                    > USED AT LINE 50 IN constants.asm
ROT_:               0020 DEFINED AT LINE 36 IN constants.asm
                    > USED AT LINE 54 IN constants.asm
                    > USED AT LINE 55 IN constants.asm
                    > USED AT LINE 56 IN constants.asm
                    > USED AT LINE 57 IN constants.asm
                    > USED AT LINE 58 IN constants.asm
                    > USED AT LINE 59 IN constants.asm
                    > USED AT LINE 60 IN constants.asm
                    > USED AT LINE 61 IN constants.asm
BLI_:               0040 DEFINED AT LINE 37 IN constants.asm
                    > USED AT LINE 65 IN constants.asm
                    > USED AT LINE 66 IN constants.asm
                    > USED AT LINE 67 IN constants.asm
                    > USED AT LINE 68 IN constants.asm
                    > USED AT LINE 69 IN constants.asm
                    > USED AT LINE 70 IN constants.asm
                    > USED AT LINE 71 IN constants.asm
                    > USED AT LINE 72 IN constants.asm
                    > USED AT LINE 73 IN constants.asm
                    > USED AT LINE 74 IN constants.asm
                    > USED AT LINE 75 IN constants.asm
                    > USED AT LINE 76 IN constants.asm
                    > USED AT LINE 77 IN constants.asm
                    > USED AT LINE 78 IN constants.asm
                    > USED AT LINE 79 IN constants.asm
                    > USED AT LINE 80 IN constants.asm
GEN1_:              0060 DEFINED AT LINE 38 IN constants.asm
                    > USED AT LINE 84 IN constants.asm
                    > USED AT LINE 85 IN constants.asm
                    > USED AT LINE 86 IN constants.asm
                    > USED AT LINE 87 IN constants.asm
                    > USED AT LINE 88 IN constants.asm
                    > USED AT LINE 89 IN constants.asm
                    > USED AT LINE 90 IN constants.asm
                    > USED AT LINE 91 IN constants.asm
                    > USED AT LINE 93 IN constants.asm
GEN2_:              0080 DEFINED AT LINE 39 IN constants.asm
                    > USED AT LINE 92 IN constants.asm
                    > USED AT LINE 97 IN constants.asm
                    > USED AT LINE 98 IN constants.asm
                    > USED AT LINE 99 IN constants.asm
                    > USED AT LINE 100 IN constants.asm
                    > USED AT LINE 101 IN constants.asm
                    > USED AT LINE 102 IN constants.asm
                    > USED AT LINE 103 IN constants.asm
                    > USED AT LINE 104 IN constants.asm
                    > USED AT LINE 105 IN constants.asm
                    > USED AT LINE 106 IN constants.asm
                    > USED AT LINE 107 IN constants.asm
                    > USED AT LINE 108 IN constants.asm
                    > USED AT LINE 109 IN constants.asm
                    > USED AT LINE 110 IN constants.asm
                    > USED AT LINE 111 IN constants.asm
                    > USED AT LINE 112 IN constants.asm
                    > USED AT LINE 113 IN constants.asm
                    > USED AT LINE 114 IN constants.asm
                    > USED AT LINE 115 IN constants.asm
                    > USED AT LINE 116 IN constants.asm
                    > USED AT LINE 117 IN constants.asm
                    > USED AT LINE 118 IN constants.asm
                    > USED AT LINE 119 IN constants.asm
                    > USED AT LINE 120 IN constants.asm
                    > USED AT LINE 121 IN constants.asm
                    > USED AT LINE 122 IN constants.asm
ALU_IDX:            0000 DEFINED AT LINE 41 IN constants.asm
ADD_:               0000 DEFINED AT LINE 43 IN constants.asm
ADC_:               0001 DEFINED AT LINE 44 IN constants.asm
SUB_:               0002 DEFINED AT LINE 45 IN constants.asm
SBC_:               0003 DEFINED AT LINE 46 IN constants.asm
AND_:               0004 DEFINED AT LINE 47 IN constants.asm
XOR_:               0005 DEFINED AT LINE 48 IN constants.asm
OR_:                0006 DEFINED AT LINE 49 IN constants.asm
CP_:                0007 DEFINED AT LINE 50 IN constants.asm
ROT_IDX:            0000 DEFINED AT LINE 52 IN constants.asm
RLC_:               0020 DEFINED AT LINE 54 IN constants.asm
RRC_:               0021 DEFINED AT LINE 55 IN constants.asm
RL_:                0022 DEFINED AT LINE 56 IN constants.asm
RR_:                0023 DEFINED AT LINE 57 IN constants.asm
SLA_:               0024 DEFINED AT LINE 58 IN constants.asm
SRA_:               0025 DEFINED AT LINE 59 IN constants.asm
SLL_:               0026 DEFINED AT LINE 60 IN constants.asm
SRL_:               0027 DEFINED AT LINE 61 IN constants.asm
BLI_IDX:            0000 DEFINED AT LINE 63 IN constants.asm
LDI_:               0040 DEFINED AT LINE 65 IN constants.asm
CPI_:               0041 DEFINED AT LINE 66 IN constants.asm
INI_:               0042 DEFINED AT LINE 67 IN constants.asm
OUTI_:              0043 DEFINED AT LINE 68 IN constants.asm
LDD_:               0044 DEFINED AT LINE 69 IN constants.asm
CPD_:               0045 DEFINED AT LINE 70 IN constants.asm
IND_:               0046 DEFINED AT LINE 71 IN constants.asm
                    > USED AT LINE 313 IN MAIN.asm
OUTD_:              0047 DEFINED AT LINE 72 IN constants.asm
LDIR_:              0048 DEFINED AT LINE 73 IN constants.asm
CPIR_:              0049 DEFINED AT LINE 74 IN constants.asm
INIR_:              004A DEFINED AT LINE 75 IN constants.asm
OTIR_:              004B DEFINED AT LINE 76 IN constants.asm
LDDR_:              004C DEFINED AT LINE 77 IN constants.asm
CPDR_:              004D DEFINED AT LINE 78 IN constants.asm
INDR_:              004E DEFINED AT LINE 79 IN constants.asm
OTDR_:              004F DEFINED AT LINE 80 IN constants.asm
GEN1_IDX:           0000 DEFINED AT LINE 82 IN constants.asm
CCF_:               0060 DEFINED AT LINE 84 IN constants.asm
CPL_:               0061 DEFINED AT LINE 85 IN constants.asm
DAA_:               0062 DEFINED AT LINE 86 IN constants.asm
DI_:                0063 DEFINED AT LINE 87 IN constants.asm
EI_:                0064 DEFINED AT LINE 88 IN constants.asm
HALT_:              0065 DEFINED AT LINE 89 IN constants.asm
                    > USED AT LINE 96
NOP_:               0066 DEFINED AT LINE 90 IN constants.asm
RLCA_:              0067 DEFINED AT LINE 91 IN constants.asm
RST_:               0088 DEFINED AT LINE 92 IN constants.asm
SCF_:               0069 DEFINED AT LINE 93 IN constants.asm
GEN2_IDX:           0000 DEFINED AT LINE 95 IN constants.asm
BIT_:               0080 DEFINED AT LINE 97 IN constants.asm
CALL_:              0081 DEFINED AT LINE 98 IN constants.asm
                    > USED AT LINE 221 IN MAIN.asm
DEC_:               0082 DEFINED AT LINE 99 IN constants.asm
DJNZ_:              0083 DEFINED AT LINE 100 IN constants.asm
EX_:                0084 DEFINED AT LINE 101 IN constants.asm
EXX_:               0085 DEFINED AT LINE 102 IN constants.asm
IM_:                0086 DEFINED AT LINE 103 IN constants.asm
IN_:                0087 DEFINED AT LINE 104 IN constants.asm
                    > USED AT LINE 42
INC_:               0088 DEFINED AT LINE 105 IN constants.asm
JP_:                0089 DEFINED AT LINE 106 IN constants.asm
                    > USED AT LINE 217 IN MAIN.asm
                    > USED AT LINE 78
                    > USED AT LINE 87
JR_:                008A DEFINED AT LINE 107 IN constants.asm
                    > USED AT LINE 219 IN MAIN.asm
LD_:                008B DEFINED AT LINE 108 IN constants.asm
                    > USED AT LINE 51
                    > USED AT LINE 60
NEG_:               008C DEFINED AT LINE 109 IN constants.asm
OUT_:               008D DEFINED AT LINE 110 IN constants.asm
                    > USED AT LINE 33
POP_:               008E DEFINED AT LINE 111 IN constants.asm
PUSH_:              008F DEFINED AT LINE 112 IN constants.asm
RES_:               0090 DEFINED AT LINE 113 IN constants.asm
RET_:               0091 DEFINED AT LINE 114 IN constants.asm
                    > USED AT LINE 223 IN MAIN.asm
                    > USED AT LINE 69
RETI_:              0092 DEFINED AT LINE 115 IN constants.asm
RETN_:              0093 DEFINED AT LINE 116 IN constants.asm
RLA_:               0094 DEFINED AT LINE 117 IN constants.asm
RLD_:               0095 DEFINED AT LINE 118 IN constants.asm
RRA_:               0096 DEFINED AT LINE 119 IN constants.asm
RRCA_:              0097 DEFINED AT LINE 120 IN constants.asm
RRD_:               0098 DEFINED AT LINE 121 IN constants.asm
SET_:               0003 DEFINED AT LINE 174 IN constants.asm
IMMED_:             0000 DEFINED AT LINE 126 IN constants.asm
                    > USED AT LINE 299 IN MAIN.asm
                    > USED AT LINE 313 IN MAIN.asm
FLAG_:              0001 DEFINED AT LINE 127 IN constants.asm
                    > USED AT LINE 247 IN MAIN.asm
                    > USED AT LINE 276 IN MAIN.asm
                    > USED AT LINE 769 IN MAIN.asm
                    > USED AT LINE 69
                    > USED AT LINE 78
REG_:               0002 DEFINED AT LINE 128 IN constants.asm
                    > USED AT LINE 242 IN MAIN.asm
                    > USED AT LINE 341 IN MAIN.asm
                    > USED AT LINE 761 IN MAIN.asm
                    > USED AT LINE 33
                    > USED AT LINE 42
                    > USED AT LINE 51
                    > USED AT LINE 60
RP_:                0003 DEFINED AT LINE 129 IN constants.asm
                    > USED AT LINE 349 IN MAIN.asm
                    > USED AT LINE 351 IN MAIN.asm
                    > USED AT LINE 778 IN MAIN.asm
INDIRECT_:          0004 DEFINED AT LINE 131 IN constants.asm
                    > USED AT LINE 363 IN MAIN.asm
                    > USED AT LINE 33
INDEX_:             0008 DEFINED AT LINE 132 IN constants.asm
                    > USED AT LINE 349 IN MAIN.asm
                    > USED AT LINE 785 IN MAIN.asm
FLAG_IDX:           0000 DEFINED AT LINE 134 IN constants.asm
NZ_:                0000 DEFINED AT LINE 136 IN constants.asm
Z_:                 0001 DEFINED AT LINE 137 IN constants.asm
NC_:                0002 DEFINED AT LINE 138 IN constants.asm
CF_:                0003 DEFINED AT LINE 139 IN constants.asm
                    > USED AT LINE 248 IN MAIN.asm
PO_:                0004 DEFINED AT LINE 140 IN constants.asm
PE_:                0005 DEFINED AT LINE 141 IN constants.asm
P_:                 0006 DEFINED AT LINE 142 IN constants.asm
M_:                 0007 DEFINED AT LINE 143 IN constants.asm
REG8_IDX:           0000 DEFINED AT LINE 145 IN constants.asm
B_:                 0000 DEFINED AT LINE 147 IN constants.asm
C_:                 0001 DEFINED AT LINE 148 IN constants.asm
                    > USED AT LINE 245 IN MAIN.asm
                    > USED AT LINE 344 IN MAIN.asm
D_:                 0002 DEFINED AT LINE 149 IN constants.asm
E_:                 0003 DEFINED AT LINE 150 IN constants.asm
H_:                 0004 DEFINED AT LINE 151 IN constants.asm
L_:                 0005 DEFINED AT LINE 152 IN constants.asm
MHL_:               0006 DEFINED AT LINE 153 IN constants.asm
A_:                 0007 DEFINED AT LINE 154 IN constants.asm
I_:                 0008 DEFINED AT LINE 155 IN constants.asm
R_:                 0009 DEFINED AT LINE 156 IN constants.asm
REG16_IDX:          0000 DEFINED AT LINE 158 IN constants.asm
BC_:                0000 DEFINED AT LINE 160 IN constants.asm
DE_:                0001 DEFINED AT LINE 161 IN constants.asm
HL_:                0002 DEFINED AT LINE 162 IN constants.asm
SP_:                0003 DEFINED AT LINE 163 IN constants.asm
AFP_:               0004 DEFINED AT LINE 164 IN constants.asm
AF_:                0005 DEFINED AT LINE 165 IN constants.asm
IX_:                0006 DEFINED AT LINE 166 IN constants.asm
                    > USED AT LINE 779 IN MAIN.asm
IY_:                0007 DEFINED AT LINE 167 IN constants.asm
                    > USED AT LINE 781 IN MAIN.asm
DIRECTIVE_IDX:      0000 DEFINED AT LINE 169 IN constants.asm
ALIGN_:             0000 DEFINED AT LINE 171 IN constants.asm
DB_:                0001 DEFINED AT LINE 172 IN constants.asm
ORG_:               0002 DEFINED AT LINE 173 IN constants.asm
TEC_1:              0001 DEFINED AT LINE 178 IN constants.asm
RC2014:             0000 DEFINED AT LINE 179 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 181 IN constants.asm
LOADER:             0000 DEFINED AT LINE 183 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 184 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 33 IN IOSerial.asm
                    > USED AT LINE 478 IN IOSerial.asm
                    > USED AT LINE 500 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 34 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 322 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 36 IN IOSerial.asm
                    > USED AT LINE 326 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 477 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 46 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 50 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 51 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 52 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 53 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 54 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 55 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 56 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 57 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 61 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 62 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 63 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 64 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 68 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 72 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 73 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 74 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 75 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 76 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 77 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 78 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 79 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 87 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 88 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 89 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 90 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 91 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 92 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 93 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 94 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 108 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 109 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 113 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 163 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 483 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 187 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 193 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 196 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 471 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 305 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 308 IN IOSerial.asm
                    > USED AT LINE 312 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 320 IN IOSerial.asm
                    > USED AT LINE 469 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 321 IN IOSerial.asm
                    > USED AT LINE 325 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 445 IN IOSerial.asm
                    > USED AT LINE 1113 IN MAIN.asm
PUTCHAR:            0087 DEFINED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 1139 IN MAIN.asm
                    > USED AT LINE 1300 IN MAIN.asm
                    > USED AT LINE 281 IN test.lib.asm
                    > USED AT LINE 326 IN test.lib.asm
RESET:              008D DEFINED AT LINE 457 IN IOSerial.asm
                    > USED AT LINE 114 IN IOSerial.asm
START:              0180 DEFINED AT LINE 36 IN MAIN.asm
INIT:               0198 DEFINED AT LINE 59 IN MAIN.asm
                    > USED AT LINE 38 IN MAIN.asm
                    > USED AT LINE 60 IN test.lib.asm
PARSE:              01BD DEFINED AT LINE 92 IN MAIN.asm
                    > USED AT LINE 41 IN MAIN.asm
PARSEERROR:         01E4 DEFINED AT LINE 98 IN MAIN.asm
                    > USED AT LINE 126 IN MAIN.asm
                    > USED AT LINE 264 IN MAIN.asm
                    > USED AT LINE 270 IN MAIN.asm
                    > USED AT LINE 319 IN MAIN.asm
                    > USED AT LINE 346 IN MAIN.asm
                    > USED AT LINE 353 IN MAIN.asm
STATEMENTLIST:      01FC DEFINED AT LINE 120 IN MAIN.asm
                    > USED AT LINE 93 IN MAIN.asm
                    > USED AT LINE 127 IN MAIN.asm
                    > USED AT LINE 63 IN test.lib.asm
STATEMENT:          020B DEFINED AT LINE 146 IN MAIN.asm
                    > USED AT LINE 122 IN MAIN.asm
STATEMENT1:         0237 DEFINED AT LINE 169 IN MAIN.asm
                    > USED AT LINE 163 IN MAIN.asm
INSTR:              0240 DEFINED AT LINE 214 IN MAIN.asm
                    > USED AT LINE 171 IN MAIN.asm
INSTR1:             0254 DEFINED AT LINE 226 IN MAIN.asm
                    > USED AT LINE 218 IN MAIN.asm
                    > USED AT LINE 220 IN MAIN.asm
                    > USED AT LINE 222 IN MAIN.asm
INSTR2:             0259 DEFINED AT LINE 231 IN MAIN.asm
                    > USED AT LINE 224 IN MAIN.asm
INSTR3:             0278 DEFINED AT LINE 252 IN MAIN.asm
                    > USED AT LINE 240 IN MAIN.asm
                    > USED AT LINE 243 IN MAIN.asm
                    > USED AT LINE 246 IN MAIN.asm
INSTR4:             027C DEFINED AT LINE 256 IN MAIN.asm
                    > USED AT LINE 250 IN MAIN.asm
INSTR5:             029F DEFINED AT LINE 273 IN MAIN.asm
                    > USED AT LINE 260 IN MAIN.asm
INSTR6:             02B3 DEFINED AT LINE 282 IN MAIN.asm
                    > USED AT LINE 277 IN MAIN.asm
DIRECTIVE:          02B5 DEFINED AT LINE 286 IN MAIN.asm
                    > USED AT LINE 174 IN MAIN.asm
OPERAND:            02B6 DEFINED AT LINE 289 IN MAIN.asm
                    > USED AT LINE 254 IN MAIN.asm
                    > USED AT LINE 266 IN MAIN.asm
OPERAND1:           02C8 DEFINED AT LINE 302 IN MAIN.asm
                    > USED AT LINE 294 IN MAIN.asm
OPERAND2:           02D4 DEFINED AT LINE 309 IN MAIN.asm
                    > USED AT LINE 305 IN MAIN.asm
OPERAND7:           02DE DEFINED AT LINE 315 IN MAIN.asm
                    > USED AT LINE 307 IN MAIN.asm
REGINDIRECT:        02E9 DEFINED AT LINE 339 IN MAIN.asm
                    > USED AT LINE 306 IN MAIN.asm
REGINDIRECT1:       02F6 DEFINED AT LINE 348 IN MAIN.asm
                    > USED AT LINE 342 IN MAIN.asm
REGINDIRECT3:       0301 DEFINED AT LINE 355 IN MAIN.asm
                    > USED AT LINE 350 IN MAIN.asm
REGINDIRECT4:       0309 DEFINED AT LINE 361 IN MAIN.asm
                    > USED AT LINE 345 IN MAIN.asm
                    > USED AT LINE 352 IN MAIN.asm
EXPRESSION:         030E DEFINED AT LINE 387 IN MAIN.asm
                    > USED AT LINE 296 IN MAIN.asm
                    > USED AT LINE 310 IN MAIN.asm
                    > USED AT LINE 357 IN MAIN.asm
EXPRESSION1:        0329 DEFINED AT LINE 399 IN MAIN.asm
                    > USED AT LINE 411 IN MAIN.asm
                    > USED AT LINE 423 IN MAIN.asm
                    > USED AT LINE 435 IN MAIN.asm
EXPRESSION2:        0341 DEFINED AT LINE 413 IN MAIN.asm
                    > USED AT LINE 408 IN MAIN.asm
EXPRESSION3:        034F DEFINED AT LINE 425 IN MAIN.asm
                    > USED AT LINE 416 IN MAIN.asm
                    > USED AT LINE 419 IN MAIN.asm
EXPRESSION4:        035E DEFINED AT LINE 437 IN MAIN.asm
                    > USED AT LINE 427 IN MAIN.asm
                    > USED AT LINE 430 IN MAIN.asm
                    > USED AT LINE 433 IN MAIN.asm
ADDSYMBOL:          036D DEFINED AT LINE 464 IN MAIN.asm
                    > USED AT LINE 166 IN MAIN.asm
NEXTTOKEN:          0386 DEFINED AT LINE 495 IN MAIN.asm
                    > USED AT LINE 121 IN MAIN.asm
                    > USED AT LINE 167 IN MAIN.asm
                    > USED AT LINE 233 IN MAIN.asm
                    > USED AT LINE 258 IN MAIN.asm
                    > USED AT LINE 262 IN MAIN.asm
                    > USED AT LINE 268 IN MAIN.asm
                    > USED AT LINE 303 IN MAIN.asm
                    > USED AT LINE 317 IN MAIN.asm
                    > USED AT LINE 406 IN MAIN.asm
                    > USED AT LINE 410 IN MAIN.asm
                    > USED AT LINE 422 IN MAIN.asm
NEXTTOKEN1:         0396 DEFINED AT LINE 505 IN MAIN.asm
                    > USED AT LINE 499 IN MAIN.asm
                    > USED AT LINE 509 IN MAIN.asm
                    > USED AT LINE 535 IN MAIN.asm
NEXTTOKEN2:         03A7 DEFINED AT LINE 515 IN MAIN.asm
                    > USED AT LINE 511 IN MAIN.asm
NEXTTOKEN2A:        03B3 DEFINED AT LINE 522 IN MAIN.asm
                    > USED AT LINE 517 IN MAIN.asm
                    > USED AT LINE 519 IN MAIN.asm
NEXTTOKEN3:         03B6 DEFINED AT LINE 526 IN MAIN.asm
                    > USED AT LINE 521 IN MAIN.asm
NEXTTOKEN4:         03BA DEFINED AT LINE 530 IN MAIN.asm
                    > USED AT LINE 533 IN MAIN.asm
NEXTTOKEN5:         03C6 DEFINED AT LINE 537 IN MAIN.asm
                    > USED AT LINE 528 IN MAIN.asm
NEXTTOKEN6:         03CF DEFINED AT LINE 543 IN MAIN.asm
                    > USED AT LINE 539 IN MAIN.asm
NEXTTOKEN7:         03D9 DEFINED AT LINE 550 IN MAIN.asm
                    > USED AT LINE 546 IN MAIN.asm
NEXTTOKEN8:         03EA DEFINED AT LINE 560 IN MAIN.asm
                    > USED AT LINE 554 IN MAIN.asm
NEXTTOKEN9:         03F2 DEFINED AT LINE 566 IN MAIN.asm
                    > USED AT LINE 562 IN MAIN.asm
NEXTTOKEN10:        0400 DEFINED AT LINE 575 IN MAIN.asm
                    > USED AT LINE 569 IN MAIN.asm
NEXTTOKEN11:        0403 DEFINED AT LINE 579 IN MAIN.asm
                    > USED AT LINE 541 IN MAIN.asm
NEXTTOKEN12:        0418 DEFINED AT LINE 591 IN MAIN.asm
                    > USED AT LINE 585 IN MAIN.asm
NEXTTOKEN13:        0424 DEFINED AT LINE 598 IN MAIN.asm
                    > USED AT LINE 582 IN MAIN.asm
NEXTTOKEN14:        0435 DEFINED AT LINE 608 IN MAIN.asm
                    > USED AT LINE 600 IN MAIN.asm
PUSHBACKTOKEN:      0447 DEFINED AT LINE 640 IN MAIN.asm
                    > USED AT LINE 442 IN MAIN.asm
IDENT:              0450 DEFINED AT LINE 668 IN MAIN.asm
                    > USED AT LINE 544 IN MAIN.asm
IDENT1:             0455 DEFINED AT LINE 672 IN MAIN.asm
                    > USED AT LINE 679 IN MAIN.asm
                    > USED AT LINE 681 IN MAIN.asm
IDENT3:             0465 DEFINED AT LINE 682 IN MAIN.asm
SEARCHOPCODE:       0470 DEFINED AT LINE 710 IN MAIN.asm
                    > USED AT LINE 553 IN MAIN.asm
SEARCHOPELEM:       049D DEFINED AT LINE 756 IN MAIN.asm
                    > USED AT LINE 561 IN MAIN.asm
SEARCHOPELEM1:      04A9 DEFINED AT LINE 764 IN MAIN.asm
                    > USED AT LINE 759 IN MAIN.asm
SEARCHOPELEM2:      04B5 DEFINED AT LINE 772 IN MAIN.asm
                    > USED AT LINE 767 IN MAIN.asm
SEARCHOPELEM3:      04C7 DEFINED AT LINE 784 IN MAIN.asm
                    > USED AT LINE 780 IN MAIN.asm
SEARCHOPELEM4:      04CB DEFINED AT LINE 789 IN MAIN.asm
                    > USED AT LINE 782 IN MAIN.asm
SEARCHSTR:          04CD DEFINED AT LINE 813 IN MAIN.asm
                    > USED AT LINE 568 IN MAIN.asm
                    > USED AT LINE 712 IN MAIN.asm
                    > USED AT LINE 716 IN MAIN.asm
                    > USED AT LINE 721 IN MAIN.asm
                    > USED AT LINE 726 IN MAIN.asm
                    > USED AT LINE 732 IN MAIN.asm
                    > USED AT LINE 758 IN MAIN.asm
                    > USED AT LINE 766 IN MAIN.asm
                    > USED AT LINE 774 IN MAIN.asm
SEARCHSTR1:         04CF DEFINED AT LINE 816 IN MAIN.asm
                    > USED AT LINE 835 IN MAIN.asm
SEARCHSTR3:         04D6 DEFINED AT LINE 822 IN MAIN.asm
                    > USED AT LINE 818 IN MAIN.asm
COMPARESTR:         04E5 DEFINED AT LINE 858 IN MAIN.asm
                    > USED AT LINE 817 IN MAIN.asm
                    > USED AT LINE 85 IN test.lib.asm
COMPARESTR2:        04EB DEFINED AT LINE 866 IN MAIN.asm
                    > USED AT LINE 872 IN MAIN.asm
COMPARESTR3:        04F3 DEFINED AT LINE 874 IN MAIN.asm
                    > USED AT LINE 869 IN MAIN.asm
ISENDOFLINE:        04F7 DEFINED AT LINE 896 IN MAIN.asm
                    > USED AT LINE 147 IN MAIN.asm
                    > USED AT LINE 234 IN MAIN.asm
                    > USED AT LINE 263 IN MAIN.asm
                    > USED AT LINE 269 IN MAIN.asm
                    > USED AT LINE 432 IN MAIN.asm
ISALPHANUM:         04FD DEFINED AT LINE 922 IN MAIN.asm
                    > USED AT LINE 584 IN MAIN.asm
                    > USED AT LINE 680 IN MAIN.asm
ISALPHA:            0501 DEFINED AT LINE 946 IN MAIN.asm
                    > USED AT LINE 540 IN MAIN.asm
ISALPHA1:           050C DEFINED AT LINE 954 IN MAIN.asm
                    > USED AT LINE 950 IN MAIN.asm
ISDIGIT:            0513 DEFINED AT LINE 978 IN MAIN.asm
                    > USED AT LINE 599 IN MAIN.asm
                    > USED AT LINE 923 IN MAIN.asm
DECIMAL:            051A DEFINED AT LINE 1001 IN MAIN.asm
                    > USED AT LINE 603 IN MAIN.asm
DECIMAL1:           051D DEFINED AT LINE 1003 IN MAIN.asm
                    > USED AT LINE 1024 IN MAIN.asm
HEXADECIMAL:        0539 DEFINED AT LINE 1042 IN MAIN.asm
                    > USED AT LINE 593 IN MAIN.asm
HEXADECIMAL1:       053C DEFINED AT LINE 1044 IN MAIN.asm
                    > USED AT LINE 1073 IN MAIN.asm
HEXADECIMAL2:       054E DEFINED AT LINE 1055 IN MAIN.asm
                    > USED AT LINE 1053 IN MAIN.asm
HEXADECIMAL3:       0555 DEFINED AT LINE 1060 IN MAIN.asm
                    > USED AT LINE 1059 IN MAIN.asm
HEXADECIMAL4:       0557 DEFINED AT LINE 1062 IN MAIN.asm
                    > USED AT LINE 1051 IN MAIN.asm
NEXTCHAR:           0566 DEFINED AT LINE 1092 IN MAIN.asm
                    > USED AT LINE 506 IN MAIN.asm
                    > USED AT LINE 531 IN MAIN.asm
                    > USED AT LINE 583 IN MAIN.asm
                    > USED AT LINE 676 IN MAIN.asm
                    > USED AT LINE 1006 IN MAIN.asm
                    > USED AT LINE 1046 IN MAIN.asm
                    > USED AT LINE 1164 IN MAIN.asm
NEXTLINE:           057D DEFINED AT LINE 1108 IN MAIN.asm
                    > USED AT LINE 1096 IN MAIN.asm
NEXTLINE1:          0582 DEFINED AT LINE 1112 IN MAIN.asm
                    > USED AT LINE 1130 IN MAIN.asm
                    > USED AT LINE 1136 IN MAIN.asm
                    > USED AT LINE 1159 IN MAIN.asm
NEXTLINE2:          0590 DEFINED AT LINE 1121 IN MAIN.asm
                    > USED AT LINE 1117 IN MAIN.asm
NEXTLINE3:          0594 DEFINED AT LINE 1125 IN MAIN.asm
                    > USED AT LINE 1119 IN MAIN.asm
NEXTLINE4:          05A8 DEFINED AT LINE 1138 IN MAIN.asm
                    > USED AT LINE 1127 IN MAIN.asm
NEXTLINE5:          05B3 DEFINED AT LINE 1146 IN MAIN.asm
                    > USED AT LINE 1142 IN MAIN.asm
NEXTLINE6:          05BB DEFINED AT LINE 1152 IN MAIN.asm
                    > USED AT LINE 1115 IN MAIN.asm
                    > USED AT LINE 1123 IN MAIN.asm
                    > USED AT LINE 1144 IN MAIN.asm
                    > USED AT LINE 1148 IN MAIN.asm
                    > USED AT LINE 1150 IN MAIN.asm
NEXTLINE7:          05C7 DEFINED AT LINE 1161 IN MAIN.asm
                    > USED AT LINE 1156 IN MAIN.asm
                    > USED AT LINE 1158 IN MAIN.asm
REWINDCHAR:         05CE DEFINED AT LINE 1183 IN MAIN.asm
                    > USED AT LINE 534 IN MAIN.asm
                    > USED AT LINE 551 IN MAIN.asm
                    > USED AT LINE 587 IN MAIN.asm
                    > USED AT LINE 592 IN MAIN.asm
                    > USED AT LINE 594 IN MAIN.asm
                    > USED AT LINE 602 IN MAIN.asm
                    > USED AT LINE 604 IN MAIN.asm
PROMPT:             05D8 DEFINED AT LINE 1207 IN MAIN.asm
CRLF:               05E1 DEFINED AT LINE 1228 IN MAIN.asm
                    > USED AT LINE 115 IN test.lib.asm
                    > USED AT LINE 178 IN test.lib.asm
                    > USED AT LINE 181 IN test.lib.asm
                    > USED AT LINE 184 IN test.lib.asm
                    > USED AT LINE 185 IN test.lib.asm
                    > USED AT LINE 191 IN test.lib.asm
                    > USED AT LINE 197 IN test.lib.asm
ERROR:              05E8 DEFINED AT LINE 1249 IN MAIN.asm
PRINT:              05ED DEFINED AT LINE 1270 IN MAIN.asm
                    > USED AT LINE 39 IN MAIN.asm
                    > USED AT LINE 94 IN MAIN.asm
                    > USED AT LINE 99 IN MAIN.asm
                    > USED AT LINE 1134 IN MAIN.asm
                    > USED AT LINE 1208 IN MAIN.asm
                    > USED AT LINE 1229 IN MAIN.asm
                    > USED AT LINE 112
                    > USED AT LINE 90 IN test.lib.asm
                    > USED AT LINE 186 IN test.lib.asm
                    > USED AT LINE 192 IN test.lib.asm
PRINTSTR:           05F3 DEFINED AT LINE 1292 IN MAIN.asm
                    > USED AT LINE 1251 IN MAIN.asm
                    > USED AT LINE 1272 IN MAIN.asm
                    > USED AT LINE 180 IN test.lib.asm
PRINTSTR1:          05F8 DEFINED AT LINE 1298 IN MAIN.asm
                    > USED AT LINE 1302 IN MAIN.asm
HPUSH:              0600 DEFINED AT LINE 1321 IN MAIN.asm
                    > USED AT LINE 392 IN MAIN.asm
                    > USED AT LINE 394 IN MAIN.asm
                    > USED AT LINE 395 IN MAIN.asm
                    > USED AT LINE 403 IN MAIN.asm
                    > USED AT LINE 405 IN MAIN.asm
                    > USED AT LINE 440 IN MAIN.asm
                    > USED AT LINE 469 IN MAIN.asm
                    > USED AT LINE 472 IN MAIN.asm
                    > USED AT LINE 474 IN MAIN.asm
ROT_OPCODES:        060E DEFINED AT LINE 1 IN data.asm
                    > USED AT LINE 715 IN MAIN.asm
ALU_OPCODES:        062D DEFINED AT LINE 13 IN data.asm
                    > USED AT LINE 711 IN MAIN.asm
BLI_OPCODES:        064C DEFINED AT LINE 25 IN data.asm
                    > USED AT LINE 720 IN MAIN.asm
GEN1_OPCODES:       0697 DEFINED AT LINE 45 IN data.asm
                    > USED AT LINE 725 IN MAIN.asm
GEN2_OPCODES:       06C0 DEFINED AT LINE 59 IN data.asm
                    > USED AT LINE 731 IN MAIN.asm
REG8:               0729 DEFINED AT LINE 89 IN data.asm
                    > USED AT LINE 757 IN MAIN.asm
REG16:              073E DEFINED AT LINE 103 IN data.asm
                    > USED AT LINE 773 IN MAIN.asm
FLAGS:              0758 DEFINED AT LINE 115 IN data.asm
                    > USED AT LINE 765 IN MAIN.asm
DIRECTIVES:         076D DEFINED AT LINE 127 IN data.asm
                    > USED AT LINE 567 IN MAIN.asm
BUFFER:             3000 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 68 IN MAIN.asm
                    > USED AT LINE 1097 IN MAIN.asm
                    > USED AT LINE 1109 IN MAIN.asm
STACK:              3180 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 458 IN IOSerial.asm
                    > USED AT LINE 37 IN MAIN.asm
                    > USED AT LINE 15
VTEMP1:             3180 DEFINED AT LINE 9 IN ram.asm
VTEMP2:             3182 DEFINED AT LINE 10 IN ram.asm
VTOKEN:             3184 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 65 IN MAIN.asm
                    > USED AT LINE 496 IN MAIN.asm
                    > USED AT LINE 642 IN MAIN.asm
VTOKENVAL:          3185 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 61 IN MAIN.asm
                    > USED AT LINE 502 IN MAIN.asm
                    > USED AT LINE 643 IN MAIN.asm
VBUFFERPOS:         3187 DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 66 IN MAIN.asm
                    > USED AT LINE 1093 IN MAIN.asm
                    > USED AT LINE 1162 IN MAIN.asm
                    > USED AT LINE 1184 IN MAIN.asm
                    > USED AT LINE 1188 IN MAIN.asm
VASMPTR:            3189 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 72 IN MAIN.asm
                    > USED AT LINE 165 IN MAIN.asm
VSYMPTR:            318B DEFINED AT LINE 16 IN ram.asm
                    > USED AT LINE 62 IN MAIN.asm
                    > USED AT LINE 468 IN MAIN.asm
                    > USED AT LINE 470 IN MAIN.asm
VEXPRPTR:           318D DEFINED AT LINE 17 IN ram.asm
                    > USED AT LINE 63 IN MAIN.asm
                    > USED AT LINE 391 IN MAIN.asm
                    > USED AT LINE 396 IN MAIN.asm
                    > USED AT LINE 443 IN MAIN.asm
VHEAPPTR:           318F DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 70 IN MAIN.asm
                    > USED AT LINE 390 IN MAIN.asm
                    > USED AT LINE 467 IN MAIN.asm
                    > USED AT LINE 552 IN MAIN.asm
                    > USED AT LINE 669 IN MAIN.asm
                    > USED AT LINE 683 IN MAIN.asm
                    > USED AT LINE 1324 IN MAIN.asm
                    > USED AT LINE 1329 IN MAIN.asm
VISBRANCH:          3191 DEFINED AT LINE 19 IN ram.asm
                    > USED AT LINE 157 IN MAIN.asm
                    > USED AT LINE 229 IN MAIN.asm
                    > USED AT LINE 238 IN MAIN.asm
VOPCODE:            3192 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 156 IN MAIN.asm
                    > USED AT LINE 216 IN MAIN.asm
                    > USED AT LINE 117 IN test.lib.asm
VOP1:               3193 DEFINED AT LINE 22 IN ram.asm
                    > USED AT LINE 153 IN MAIN.asm
                    > USED AT LINE 257 IN MAIN.asm
                    > USED AT LINE 278 IN MAIN.asm
                    > USED AT LINE 281 IN MAIN.asm
VOP1TYPE:           3193 DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 275 IN MAIN.asm
VOP1VAL:            3194 DEFINED AT LINE 24 IN ram.asm
VOP2:               3195 DEFINED AT LINE 25 IN ram.asm
                    > USED AT LINE 154 IN MAIN.asm
                    > USED AT LINE 267 IN MAIN.asm
                    > USED AT LINE 279 IN MAIN.asm
VOP2TYPE:           3195 DEFINED AT LINE 26 IN ram.asm
VOP2VAL:            3196 DEFINED AT LINE 27 IN ram.asm
VOPEXPR:            3197 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 158 IN MAIN.asm
                    > USED AT LINE 297 IN MAIN.asm
                    > USED AT LINE 311 IN MAIN.asm
VOPDISP:            3199 DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 159 IN MAIN.asm
                    > USED AT LINE 358 IN MAIN.asm
RST08:              319B DEFINED AT LINE 33 IN ram.asm
                    > USED AT LINE 118 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
RST10:              319D DEFINED AT LINE 34 IN ram.asm
                    > USED AT LINE 124 IN IOSerial.asm
                    > USED AT LINE 461 IN IOSerial.asm
RST18:              319F DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 130 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RST20:              31A1 DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 136 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
RST28:              31A3 DEFINED AT LINE 37 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
RST30:              31A5 DEFINED AT LINE 38 IN ram.asm
                    > USED AT LINE 148 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
BAUD:               31A7 DEFINED AT LINE 39 IN ram.asm
INTVEC:             31A9 DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 154 IN IOSerial.asm
                    > USED AT LINE 466 IN IOSerial.asm
NMIVEC:             31AB DEFINED AT LINE 41 IN ram.asm
                    > USED AT LINE 202 IN IOSerial.asm
                    > USED AT LINE 467 IN IOSerial.asm
GETCVEC:            31AD DEFINED AT LINE 42 IN ram.asm
                    > USED AT LINE 447 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
                    > USED AT LINE 62 IN test.lib.asm
PUTCVEC:            31AF DEFINED AT LINE 43 IN ram.asm
                    > USED AT LINE 453 IN IOSerial.asm
                    > USED AT LINE 472 IN IOSerial.asm
HEAP:               31B1 DEFINED AT LINE 45 IN ram.asm
                    > USED AT LINE 69 IN MAIN.asm
ASSEMBLY:           32B1 DEFINED AT LINE 46 IN ram.asm
                    > USED AT LINE 71 IN MAIN.asm
                    > USED AT LINE 84 IN test.lib.asm
TESTSSTART:         4000 DEFINED AT LINE 14
                    > USED AT LINE 6
EMPTYSTR:           40B2 DEFINED AT LINE 5 IN test.lib.asm
                    > USED AT LINE 9 IN test.lib.asm
                    > USED AT LINE 134 IN test.lib.asm
TBDESC:             40B3 DEFINED AT LINE 8 IN test.lib.asm
                    > USED AT LINE 33 IN test.lib.asm
                    > USED AT LINE 135 IN test.lib.asm
                    > USED AT LINE 179 IN test.lib.asm
TBTEXT:             40B5 DEFINED AT LINE 10 IN test.lib.asm
                    > USED AT LINE 55 IN test.lib.asm
                    > USED AT LINE 92 IN test.lib.asm
TBPTR:              40B7 DEFINED AT LINE 12 IN test.lib.asm
                    > USED AT LINE 56 IN test.lib.asm
                    > USED AT LINE 218 IN test.lib.asm
                    > USED AT LINE 221 IN test.lib.asm
DESCRIBE:           40B9 DEFINED AT LINE 31 IN test.lib.asm
TEST:               40C1 DEFINED AT LINE 53 IN test.lib.asm
                    > USED AT LINE 28
                    > USED AT LINE 37
                    > USED AT LINE 46
                    > USED AT LINE 55
                    > USED AT LINE 64
                    > USED AT LINE 73
                    > USED AT LINE 82
                    > USED AT LINE 91
                    > USED AT LINE 100
EXPECT:             40D9 DEFINED AT LINE 82 IN test.lib.asm
                    > USED AT LINE 103
EXPECT1:            40E3 DEFINED AT LINE 89 IN test.lib.asm
                    > USED AT LINE 86 IN test.lib.asm
EXPECTOPS:          40F5 DEFINED AT LINE 114 IN test.lib.asm
                    > USED AT LINE 32
                    > USED AT LINE 41
                    > USED AT LINE 50
                    > USED AT LINE 59
                    > USED AT LINE 68
                    > USED AT LINE 77
                    > USED AT LINE 86
                    > USED AT LINE 95
EXPECTOPITEM:       4176 DEFINED AT LINE 158 IN test.lib.asm
                    > USED AT LINE 119 IN test.lib.asm
                    > USED AT LINE 122 IN test.lib.asm
                    > USED AT LINE 125 IN test.lib.asm
                    > USED AT LINE 128 IN test.lib.asm
                    > USED AT LINE 131 IN test.lib.asm
EXPECTOPITEM1:      417E DEFINED AT LINE 165 IN test.lib.asm
                    > USED AT LINE 161 IN test.lib.asm
EXPECTOPITEM2:      4187 DEFINED AT LINE 174 IN test.lib.asm
                    > USED AT LINE 163 IN test.lib.asm
TESTGETCHARIMPL:    41CB DEFINED AT LINE 216 IN test.lib.asm
                    > USED AT LINE 61 IN test.lib.asm
PRINTHEX:           41D6 DEFINED AT LINE 241 IN test.lib.asm
PRINTHEX2:          41E1 DEFINED AT LINE 266 IN test.lib.asm
                    > USED AT LINE 190 IN test.lib.asm
                    > USED AT LINE 196 IN test.lib.asm
                    > USED AT LINE 244 IN test.lib.asm
                    > USED AT LINE 246 IN test.lib.asm
PRINTHEX3:          41EA DEFINED AT LINE 275 IN test.lib.asm
                    > USED AT LINE 272 IN test.lib.asm
ZPRINT:             41F5 DEFINED AT LINE 299 IN test.lib.asm
PRINTZSTR:          41FC DEFINED AT LINE 322 IN test.lib.asm
                    > USED AT LINE 93 IN test.lib.asm
                    > USED AT LINE 183 IN test.lib.asm
                    > USED AT LINE 301 IN test.lib.asm
PRINTZSTR1:         41FE DEFINED AT LINE 325 IN test.lib.asm
                    > USED AT LINE 332 IN test.lib.asm
PRINTZSTR2:         4202 DEFINED AT LINE 329 IN test.lib.asm
                    > USED AT LINE 323 IN test.lib.asm
SKIPZSTR:           4207 DEFINED AT LINE 352 IN test.lib.asm
                    > USED AT LINE 57 IN test.lib.asm
                    > USED AT LINE 169 IN test.lib.asm
SKIPZSTR1:          4209 DEFINED AT LINE 355 IN test.lib.asm
                    > USED AT LINE 361 IN test.lib.asm
SKIPZSTR2:          420A DEFINED AT LINE 358 IN test.lib.asm
                    > USED AT LINE 353 IN test.lib.asm
SKIPSTR:            420F DEFINED AT LINE 381 IN test.lib.asm
                    > USED AT LINE 34 IN test.lib.asm
