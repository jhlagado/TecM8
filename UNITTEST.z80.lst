0000                             ; .engine mycomputer
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $3000   
0000                ROMSIZE:   EQU   $3000   
0000                RAMSIZE:   EQU   $0800   
0000                EOF:      EQU   -1   
0000                NULL:     EQU   0   
0000                CTRL_C:   EQU   3   
0000                CTRL_H:   EQU   8   
0000                ESC:      EQU   27   
0000                NO_MATCH:   EQU   -1   
0000                BUFFER_SIZE:   EQU   $80   
0000                STRS_SIZE:   EQU   $100   
0000                HEAP_SIZE:   EQU   $100   
0000                TOKENS:      
0000                COLON_:   EQU   ":"   
0000                COMMA_:   EQU   ","   
0000                DIRECT_:   EQU   "D"   
0000                DOLLAR_:   EQU   "$"   
0000                EOF_:     EQU   "E"   
0000                IDENT_:   EQU   "I"   
0000                LABEL_:   EQU   "L"   
0000                LPAREN_:   EQU   "("   
0000                NEWLN_:   EQU   "\n"   
0000                NUM_:     EQU   "9"   
0000                OPCODE_:   EQU   "C"   
0000                OPELEM_:   EQU   "M"   ; op element: reg, rp, flag
0000                RPAREN_:   EQU   ")"   
0000                UNKNOWN_:   EQU   "U"   
0000                ALU_:     EQU   0x00   
0000                ROT_:     EQU   0x20   
0000                BLI_:     EQU   0x40   
0000                GEN1_:    EQU   0x60   
0000                GEN2_:    EQU   0x80   
0000                ALU_IDX:      
0000                ADD_:     EQU   0 | alu_   
0000                ADC_:     EQU   1 | alu_   
0000                SUB_:     EQU   2 | alu_   
0000                SBC_:     EQU   3 | alu_   
0000                AND_:     EQU   4 | alu_   
0000                XOR_:     EQU   5 | alu_   
0000                OR_:      EQU   6 | alu_   
0000                CP_:      EQU   7 | alu_   
0000                ROT_IDX:      
0000                RLC_:     EQU   0 | rot_   
0000                RRC_:     EQU   1 | rot_   
0000                RL_:      EQU   2 | rot_   
0000                RR_:      EQU   3 | rot_   
0000                SLA_:     EQU   4 | rot_   
0000                SRA_:     EQU   5 | rot_   
0000                SLL_:     EQU   6 | rot_   
0000                SRL_:     EQU   7 | rot_   
0000                BLI_IDX:      
0000                LDI_:     EQU   00 | bli_   
0000                CPI_:     EQU   01 | bli_   
0000                INI_:     EQU   02 | bli_   
0000                OUTI_:    EQU   03 | bli_   
0000                LDD_:     EQU   04 | bli_   
0000                CPD_:     EQU   05 | bli_   
0000                IND_:     EQU   06 | bli_   
0000                OUTD_:    EQU   07 | bli_   
0000                LDIR_:    EQU   08 | bli_   
0000                CPIR_:    EQU   09 | bli_   
0000                INIR_:    EQU   10 | bli_   
0000                OTIR_:    EQU   11 | bli_   
0000                LDDR_:    EQU   12 | bli_   
0000                CPDR_:    EQU   13 | bli_   
0000                INDR_:    EQU   14 | bli_   
0000                OTDR_:    EQU   15 | bli_   
0000                GEN1_IDX:      
0000                CCF_:     EQU   00 | gen1_   
0000                CPL_:     EQU   01 | gen1_   
0000                DAA_:     EQU   02 | gen1_   
0000                DI_:      EQU   03 | gen1_   
0000                EI_:      EQU   04 | gen1_   
0000                HALT_:    EQU   05 | gen1_   
0000                NOP_:     EQU   06 | gen1_   
0000                RLCA_:    EQU   07 | gen1_   
0000                RST_:     EQU   08 | gen2_   
0000                SCF_:     EQU   09 | gen1_   
0000                GEN2_IDX:      
0000                BIT_:     EQU   00 | gen2_   
0000                CALL_:    EQU   01 | gen2_   
0000                DEC_:     EQU   02 | gen2_   
0000                DJNZ_:    EQU   03 | gen2_   
0000                EX_:      EQU   04 | gen2_   
0000                EXX_:     EQU   05 | gen2_   
0000                IM_:      EQU   06 | gen2_   
0000                IN_:      EQU   07 | gen2_   
0000                INC_:     EQU   08 | gen2_   
0000                JP_:      EQU   09 | gen2_   
0000                JR_:      EQU   10 | gen2_   
0000                LD_:      EQU   11 | gen2_   
0000                NEG_:     EQU   12 | gen2_   
0000                OUT_:     EQU   13 | gen2_   
0000                POP_:     EQU   14 | gen2_   
0000                PUSH_:    EQU   15 | gen2_   
0000                RES_:     EQU   16 | gen2_   
0000                RET_:     EQU   17 | gen2_   
0000                RETI_:    EQU   18 | gen2_   
0000                RETN_:    EQU   19 | gen2_   
0000                RLA_:     EQU   20 | gen2_   
0000                RLD_:     EQU   21 | gen2_   
0000                RRA_:     EQU   22 | gen2_   
0000                RRCA_:    EQU   23 | gen2_   
0000                RRD_:     EQU   24 | gen2_   
0000                SET_:     EQU   25 | gen2_   
0000                REG_:     EQU   0x00   ; A, B etc
0000                RP_:      EQU   0x08   ; bit 3: register pair e.g. HL, DE
0000                FLAG_:    EQU   0x10   ; bit 4: flag NZ etc
0000                IMMED_:   EQU   0x20   ; bit 5: immediate 0xff or 0xffff
0000                MEM_:     EQU   0x40   ; bit 6: memory ref (HL) or (0xffff)
0000                IDX_:     EQU   0x80   ; bit 7: indexed (IX+dd)
0000                REG8_IDX:      ; 8-bit registers
0000                B_:       EQU   0   ; B
0000                C_:       EQU   1   ; C
0000                D_:       EQU   2   ; D
0000                E_:       EQU   3   ; E
0000                H_:       EQU   4   ; H
0000                L_:       EQU   5   ; L
0000                MHL_:     EQU   6   ; (HL)
0000                A_:       EQU   7   ; A
0000                I_:       EQU   8   ; I
0000                R_:       EQU   9   ; R
0000                REG16_IDX:      ; 16-bit registers
0000                BC_:      EQU   0 | rp_   
0000                DE_:      EQU   1 | rp_   
0000                HL_:      EQU   2 | rp_   
0000                SP_:      EQU   3 | rp_   
0000                IX_:      EQU   5 | rp_   
0000                IY_:      EQU   6 | rp_   
0000                AFP_:     EQU   4 | rp_   ; AF' (prime)
0000                AF_:      EQU   7 | rp_   ; NOTE: AF has the same code as SP in some instructions
0000                FLAG_IDX:      
0000                NZ_:      EQU   0 | flag_   
0000                Z_:       EQU   1 | flag_   
0000                NC_:      EQU   2 | flag_   
0000                C_:       EQU   3 | flag_   
0000                PO_:      EQU   4 | flag_   
0000                PE_:      EQU   5 | flag_   
0000                P_:       EQU   6 | flag_   
0000                M_:       EQU   7 | flag_   
0000                DIRECTIVE_IDX:      
0000                ALIGN_:   EQU   0   
0000                DB_:      EQU   1   
0000                ORG_:     EQU   2   
0000                SET_:     EQU   3   
0000                             ; -----------------------------------------------------------------------------------------------
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                             ; *************************************************************************
0000                             ; 
0000                             ;       Serial routines 
0000                             ; 
0000                             ;       written by Craig Jones 
0000                             ; 
0000                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
0000                             ; 
0000                             ;       see the LICENSE file in this repo for more information 
0000                             ; 
0000                             ; *****************************************************************************
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8D 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 9A 31               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 9C 31               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 9E 31               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A A0 31               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A A2 31               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A A4 31               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A A8 31               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A AA 31               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   E5                     PUSH   HL   
0082   2A AC 31               LD   HL,(GETCVEC)   
0085   E3                     EX   (SP),HL   
0086   C9                     RET      
0087                             ; 
0087                PUTCHAR:      
0087   E5                     PUSH   HL   
0088   2A AE 31               LD   HL,(PUTCVEC)   
008B   E3                     EX   (SP),HL   
008C   C9                     RET      
008D                             ; 
008D                RESET:       
008D   31 80 31               LD   SP,stack   
0090   21 5F 00               LD   HL,IntRet   
0093   22 9A 31               LD   (RST08),HL   
0096   22 9C 31               LD   (RST10),HL   
0099   22 9E 31               LD   (RST18),HL   
009C   22 A0 31               LD   (RST20),HL   
009F   22 A2 31               LD   (RST28),HL   
00A2   22 A4 31               LD   (RST30),HL   
00A5   22 A8 31               LD   (INTVEC),HL   
00A8   22 AA 31               LD   (NMIVEC),HL   
00AB                             ; 
00AB   21 78 00               LD   HL,RXDATA   
00AE   22 AC 31               LD   (GETCVEC),HL   
00B1   21 6B 00               LD   HL,TXDATA   
00B4   22 AE 31               LD   (PUTCVEC),HL   
00B7                             ; 
00B7                          IF   TEC_1   
00B7                          IF   BITBANG = 0   
00B7                             ; 
00B7   3E 03                  LD   a,MRESET   
00B9   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00BB                             ; 
00BB                          ENDIF      
00BB                          ENDIF      
00BB                             ; 
00BB   CD 50 00               CALL   PWRUP   
00BE   ED 56                  IM   1   
00C0   FB                     EI      
00C1                             ; 
00C1                          IF   TEC_1   
00C1                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00C1                          ELSE      ;6850      
00C1                             ; 
00C1   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C3   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C5                             ; 
00C5                          ENDIF      
00C5                          ENDIF      
00C5                             ; 
00C5                             ; 
00C5   C3 00 40               JP   testsStart   
00C8                             ; *************************************************************************
00C8                             ; 
00C8                             ;       TecM8 1.0 Assembler for the Tec-1
00C8                             ; 
00C8                             ;       by John Hardy
00C8                             ; 
00C8                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
00C8                             ; 
00C8                             ;       see the LICENSE file in this repo for more information
00C8                             ; 
00C8                             ; *****************************************************************************
00C8                             ; **************************************************************************
00C8                             ; Page 0  Initialisation
00C8                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put TecM8 code from here	
0180                             ; *****************************************************************************
0180                             ; Routine: start
0180                             ; 
0180                             ; Purpose:
0180                             ;    Entry point of TecM8. Initializes the STACK pointer, calls the initialization
0180                             ;    routine, prints TecM8 version information, and jumps to the parsing routine.
0180                             ; 
0180                             ; Inputs:
0180                             ;    None
0180                             ; 
0180                             ; Outputs:
0180                             ;    None
0180                             ; 
0180                             ; Registers Destroyed:
0180                             ;    A, HL
0180                             ; *****************************************************************************
0180                START:       
0180   31 80 31               LD   sp,STACK   ; Initialize STACK pointer
0183   CD 98 01               CALL   init   ; Call initialization routine
0186   CD 86 05               CALL   print   ; Print TecM8 version information
0189   54 65 63 4D 38 20 30 2E 30 0D 0A 00 .CSTR   "TecM8 0.0\r\n"   
0195   C3 C3 01               JP   parse   ; Jump to the parsing routine
0198                             ; *****************************************************************************
0198                             ; Routine: init
0198                             ; 
0198                             ; Purpose:
0198                             ;    Initializes various pointers and variables used by TecM8.
0198                             ; 
0198                             ; Inputs:
0198                             ;    None
0198                             ; 
0198                             ; Outputs:
0198                             ;    None
0198                             ; 
0198                             ; Registers Destroyed:
0198                             ;    A, HL
0198                             ; *****************************************************************************
0198                INIT:        
0198   21 00 00               LD   hl,0   ; 
019B   22 85 31               LD   (vTokenVal),hl   ; vTokenVal = 0
019E   22 8D 31               LD   (vSymPtr),hl   ; vSymPtr = 0
01A1   22 8F 31               LD   (vExprPtr),hl   ; vExprPtr = 0
01A4   AF                     XOR   a   ; 
01A5   32 84 31               LD   (vToken),a   ; vToken = 0
01A8   32 87 31               LD   (vBufferPos),a   ; vBufferPos = 0
01AB   3E 0A                  LD   a,"\n"   ; put new line into first char of buffer
01AD   32 00 30               LD   (BUFFER),a   ; 
01B0   21 B0 32               LD   hl,HEAP   ; vHeapPtr = HEAP
01B3   22 91 31               LD   (vHeapPtr),hl   ; 
01B6   21 B0 33               LD   hl,ASSEMBLY   ; vAsmPtr = ASSEMBLY
01B9   22 89 31               LD   (vAsmPtr),hl   ; 
01BC   21 B0 31               LD   hl,STRINGS   ; vStrPtr = STRINGS
01BF   22 8B 31               LD   (vStrPtr),hl   ; 
01C2   C9                     RET      
01C3                             ; *****************************************************************************
01C3                             ; Routine: parse
01C3                             ; 
01C3                             ; Purpose:
01C3                             ;    Parses the input program, calling the statementList routine, printing the
01C3                             ;    completion message, and halting the system.
01C3                             ; 
01C3                             ; Inputs:
01C3                             ;    None
01C3                             ; 
01C3                             ; Outputs:
01C3                             ;    None
01C3                             ; 
01C3                             ; Registers Destroyed:
01C3                             ;    None
01C3                             ; *****************************************************************************
01C3                PARSE:       
01C3   CD FD 01               CALL   statementList   ; Parse the input program
01C6   CD 86 05               CALL   print   ; Print completion message
01C9   50 61 72 73 69 6E 67 20 63 6F 6D 70 6C 65 74 65 64 20 73 75 63 63 65 73 73 66 75 6C 6C 79 2E 00 .CSTR   "Parsing completed successfully."   
01E9   76                     HALT      
01EA                PARSEERROR:      
01EA   55 6E 65 78 70 65 63 74 65 64 20 74 6F 6B 65 6E 2E 00 .CSTR   "Unexpected token."   
01FC   76                     HALT      
01FD                             ; *****************************************************************************
01FD                             ; Routine: statementList
01FD                             ; 
01FD                             ; Purpose:
01FD                             ;    Parses a list of statements, repeatedly calling the statement routine until
01FD                             ;    the end of file (EOF) token is encountered.
01FD                             ; 
01FD                             ; Inputs:
01FD                             ;    None
01FD                             ; 
01FD                             ; Outputs:
01FD                             ;    None
01FD                             ; 
01FD                             ; Registers Destroyed:
01FD                             ;    A
01FD                             ; *****************************************************************************
01FD                STATEMENTLIST:      
01FD   CD 08 03               CALL   nextToken   ; Get the next token
0200   CD 0F 02               CALL   statement   ; Parse a statement
0203   FE 0A                  CP   "\n"   
0205   20 E3                  JR   nz,parseError   
0207   CD 08 03               CALL   nextToken   ; Get the next token
020A   FE 45                  CP   EOF_   ; Check if it's the end of file
020C   C8                     RET   z   ; If yes, return
020D   18 EE                  JR   statementList   ; Repeat for the next statement
020F                             ; *****************************************************************************
020F                             ; Routine: statement
020F                             ; 
020F                             ; Purpose:
020F                             ;    Parses a single statement, checking its type (label, opcode, or directive)
020F                             ;    and performing corresponding actions.
020F                             ; 
020F                             ; Inputs:
020F                             ;    None
020F                             ; 
020F                             ; Outputs:
020F                             ;    None
020F                             ; 
020F                             ; Registers Destroyed:
020F                             ;    A
020F                             ; *****************************************************************************
020F                STATEMENT:      
020F   F5                     PUSH   af   ; save token
0210   3E FF                  LD   a,-1   
0212   32 93 31               LD   (vOpcode),a   
0215   32 94 31               LD   (vOperand1),a   
0218   32 95 31               LD   (vOperand2),a   
021B   AF                     XOR   a   
021C   32 96 31               LD   (vOpExpr),a   
021F   32 98 31               LD   (vOpDisp),a   
0222   F1                     POP   af   ; restore token
0223   FE 0A                  CP   "\n"   
0225   C8                     RET   z   
0226   FE 4C                  CP   LABEL_   ; Check if it's a label
0228   20 0A                  JR   nz,statement1   ; If not, jump to statement10
022A   ED 5B 89 31            LD   de,(vAsmPtr)   ; HL = symbol name DE = symbol value (assembler pointer)
022E   CD EF 02               CALL   addSymbol   ; Add label to symbol list
0231   CD 08 03               CALL   nextToken   ; Get the next token
0234                STATEMENT1:      
0234   FE 43                  CP   OPCODE_   ; Check if it's an opcode
0236   28 05                  JR   z,instruction   ; Jump to parseInstruction routine
0238   FE 44                  CP   DIRECT_   ; Check if it's a directive
023A   28 1E                  JR   z,directive   
023C   C9                     RET      
023D                INSTRUCTION:      
023D   7D                     LD   a,l   
023E   32 93 31               LD   (vOpcode),a   
0241   CD 08 03               CALL   nextToken   
0244   CD 5B 02               CALL   operand   
0247   32 94 31               LD   (vOperand1),a   
024A   CD 08 03               CALL   nextToken   
024D   FE 2C                  CP   COMMA_   
024F   C0                     RET   nz   
0250   CD 08 03               CALL   nextToken   
0253   CD 5B 02               CALL   operand   
0256   32 95 31               LD   (vOperand2),a   
0259   C9                     RET      
025A                DIRECTIVE:      
025A   C9                     RET      
025B                             ; *****************************************************************************
025B                             ; Routine: operand
025B                             ; 
025B                             ; Purpose:
025B                             ;    Parses and identifies different types of operands (registers, memory,
025B                             ;    immediate values, etc.) used in assembly instructions. Sets the appropriate
025B                             ;    flags based on the operand type.
025B                             ; 
025B                             ; Inputs:
025B                             ;    None (uses the current token from a token stream)
025B                             ; 
025B                             ; Outputs:
025B                             ;    A - Contains the code indicating the type of operand identified.
025B                             ; 
025B                             ; Registers Destroyed:
025B                             ;    A, DE, HL
025B                             ; Define operand codes for readability and use in the operand routine.
025B                             ; 
025B                             ; reg_    .equ    0x00        ; A, B etc
025B                             ; rp_     .equ    0x08        ; bit 3: register pair e.g. HL, DE
025B                             ; flag_   .equ    0x10        ; bit 4: flag NZ etc
025B                             ; immed_  .equ    0x20        ; bit 5: immediate 0xff or 0xffff
025B                             ; mem_    .equ    0x40        ; bit 6: memory ref (HL) or (0xffff)
025B                             ; idx_    .equ    0x80        ; bit 7: indexed (IX+dd)
025B                             ; *****************************************************************************
025B                OPERAND:      
025B   FE 4D                  CP   OPELEM_   ; Check if the token is an op element i.e. reg, rp or flag
025D   C8                     RET   z   ; Return if it is
025E   FE 28                  CP   LPAREN_   ; Check if the token is a left parenthesis
0260   28 09                  JR   z,operand1   ; If so, handle as a memory reference
0262   CD 99 02               CALL   expression   ; Otherwise, treat as an expression
0265   22 96 31               LD   (vOpExpr),hl   ; Store the result of the operand expression
0268   3E 20                  LD   a,immed_   ; Set A to indicate an immediate value
026A   C9                     RET      
026B                OPERAND1:      
026B   CD 08 03               CALL   nextToken   ; Memory reference. Get the next token
026E   FE 4D                  CP   OPELEM_   ; Check if the next token is an op element
0270   20 14                  JR   nz,operand2   ; If not, handle as an expression inside parentheses
0272   7D                     LD   a,l   ; Otherwise, Load A with the lower byte of HL (operand)
0273   CD 62 04               CALL   isIndexReg   
0276   20 18                  JR   nz,operand4   
0278   F5                     PUSH   af   ; Save HL on the stack
0279   CD 99 02               CALL   expression   ; Treat as an expression
027C   22 98 31               LD   (vOpDisp),hl   ; Store the result of the expression
027F   F1                     POP   af   ; Restore HL from the stack
0280   CB FF                  SET   7,a   ; Set A to indicate an indexed memory reference
0282                OPERAND3:      
0282   CB F7                  SET   6,a   ; Otherwise, set A to indicate a memory reference
0284   18 0A                  JR   operand4   
0286                OPERAND2:      
0286   CD 99 02               CALL   expression   ; Treat as a new expression
0289   22 96 31               LD   (vOpExpr),hl   ; Store the result of the expression
028C   3E 60                  LD   a,immed_ | mem_   ; Set A to indicate an immediate memory reference
028E   18 00                  JR   operand4   
0290                OPERAND4:      
0290   CD 08 03               CALL   nextToken   ; Get the next token
0293   FE 29                  CP   RPAREN_   ; Check if the next token is a right parenthesis
0295   C2 EA 01               JP   nz,parseError   ; If not, handle as a parse error
0298   C9                     RET      
0299                             ; *****************************************************************************
0299                             ; Routine: expression
0299                             ; 
0299                             ; Purpose:
0299                             ;    Parses an expression as an array of tokens and stores it in an array.
0299                             ;    Each token in the expression is appended to an array which is terminated by
0299                             ;    a NULL token type.
0299                             ;    The expression list pointer is updated to point to the start of the last token list.
0299                             ; 
0299                             ; Inputs:
0299                             ;    A - token type
0299                             ;    HL - token value
0299                             ; 
0299                             ; Outputs:
0299                             ;    Updates the heap with the parsed expression and updates the expression list pointer.
0299                             ; 
0299                             ; Registers Destroyed:
0299                             ;    AF, B, HL
0299                             ; *****************************************************************************
0299                EXPRESSION:      
0299   06 00                  LD   b,0   ; Initialize nesting level
029B   E5                     PUSH   hl   ; Save token value
029C   ED 5B 91 31            LD   de,(vHeapPtr)   ; Load the current heap pointer into DE
02A0   2A 8F 31               LD   hl,(vExprPtr)   ; Load the current expression list pointer into HL
02A3   CD A5 05               CALL   hpush   ; Push the pointer to the last symbol onto the heap
02A6   21 00 00               LD   hl,0   ; Append two words in header (for future use)
02A9   CD A5 05               CALL   hpush   
02AC   CD A5 05               CALL   hpush   
02AF   ED 53 8F 31            LD   (vExprPtr),de   ; Update the expression list pointer with the new address
02B3   E1                     POP   hl   ; HL = token value
02B4                EXPRESSION1:      
02B4   EB                     EX   de,hl   ; DE = token value
02B5   6F                     LD   l,a   ; HL = token type
02B6   26 00                  LD   h,0   
02B8   CD A5 05               CALL   hpush   ; Push the token type
02BB   EB                     EX   de,hl   ; HL = token value
02BC   CD A5 05               CALL   hpush   ; Push the token value
02BF   CD 08 03               CALL   nextToken   ; Get the next token
02C2   FE 28                  CP   "("   ; increase nesting?
02C4   20 06                  JR   nz,expression2   
02C6   04                     INC   b   
02C7   CD 08 03               CALL   nextToken   ; Get the next token
02CA   18 E8                  JR   expression1   ; Repeat the main loop
02CC                EXPRESSION2:      
02CC   04                     INC   b   ; Check if nesting level is zero
02CD   05                     DEC   b   
02CE   28 0A                  JR   z,expression3   ; If yes, skip to expression3
02D0   FE 29                  CP   ")"   ; if nesting > 0, decrease nesting?
02D2   20 06                  JR   nz,expression3   
02D4   05                     DEC   b   ; Decrease nesting level
02D5   CD 08 03               CALL   nextToken   ; Get the next token
02D8   18 DA                  JR   expression1   ; Repeat the main loop
02DA                EXPRESSION3:      
02DA   FE 29                  CP   ")"   ; Check if the end of the expression
02DC   28 08                  JR   z,expression4   
02DE   FE 2C                  CP   ","   
02E0   28 04                  JR   z,expression4   
02E2   FE 0A                  CP   "\n"   
02E4   20 CE                  JR   nz,expression1   
02E6                EXPRESSION4:      
02E6   21 00 00               LD   hl,NULL   ; Mark the end of the expression with NULL
02E9   CD A5 05               CALL   hpush   ; Push NULL onto the heap
02EC   C3 C0 03               JP   pushBackToken   ; Rewind the token to the last valid one
02EF                             ; *****************************************************************************
02EF                             ; Routine: addSymbol
02EF                             ; 
02EF                             ; Purpose:
02EF                             ;    Adds a new symbol to the symbol list. The symbol's name is in HL and the
02EF                             ;    symbol's value is in DE. Updates the symbol list pointer and ensures
02EF                             ;    the previous symbol's pointer is preserved.
02EF                             ; 
02EF                             ; Inputs:
02EF                             ;    HL - Points to the name of the new symbol.
02EF                             ;    DE - Contains the value of the new symbol.
02EF                             ; 
02EF                             ; Outputs:
02EF                             ;    Updates the symbol list pointer in vSymPtr.
02EF                             ; 
02EF                             ; Registers Destroyed:
02EF                             ;    DE, HL
02EF                             ; *****************************************************************************
02EF                ADDSYMBOL:      
02EF   D5                     PUSH   de   
02F0   E5                     PUSH   hl   ; Push symbol name onto the stack
02F1   ED 5B 91 31            LD   de,(vHeapPtr)   ; BC = symbol address from the heap pointer
02F5   2A 8D 31               LD   hl,(vSymPtr)   ; Load the current symbol list pointer into HL
02F8   CD A5 05               CALL   hpush   ; Push pointer to the last symbol onto the heap
02FB   ED 53 8D 31            LD   (vSymPtr),de   ; Update the symbol list pointer with the new symbol address
02FF   E1                     POP   hl   ; HL = symbol name
0300   CD A5 05               CALL   hpush   ; Push symbol name onto the heap
0303   E1                     POP   hl   ; HL = symbol value
0304   CD A5 05               CALL   hpush   ; Push symbol value onto the heap
0307   C9                     RET      ; Return from subroutine
0308                             ; nextToken is a lexer function that reads characters from the input and classifies
0308                             ; them into different token types. It handles whitespace, end of input, newlines,
0308                             ; comments, identifiers, labels, directives, hexadecimal numbers, and other SYMBOLS.
0308                             ; Input: None
0308                             ; Output:
0308                             ; a: contains the type of the next token.
0308                             ; hl: contains the value associated with the next token.
0308                             ; Destroyed: None
0308                             ; *****************************************************************************
0308                             ; Routine: nextToken
0308                             ; 
0308                             ; Purpose:
0308                             ;    Parses the next token from the input stream, identifying various types of
0308                             ;    tokens such as identifiers, labels, opcodes, registers, flags, numbers,
0308                             ;    and special characters.
0308                             ; 
0308                             ; Inputs:
0308                             ;    None
0308                             ; 
0308                             ; Outputs:
0308                             ;    A - Token representing the type of the parsed element
0308                             ; 
0308                             ; Registers Destroyed:
0308                             ;    A, BC, DE, HL
0308                             ; *****************************************************************************
0308                NEXTTOKEN:      
0308   CB 77                  BIT   7,(vToken)   ; Check the high bit of the pushback BUFFER
030A   CA 19 03               JP   z,nextToken0   ; If high bit clear, nothing pushed back
030D   3A 84 31               LD   a,(vToken)   ; If high bit set, load the pushed back token type into A
0310   2A 85 31               LD   hl,(vTokenVal)   ; and token value into HL
0313   CB BF                  RES   7,a   ; Clear the high bit
0315   32 84 31               LD   (vToken),a   ; Store the character back in the BUFFER
0318   C9                     RET      ; Return with the pushed back character in A
0319                NEXTTOKEN0:      
0319   21 00 00               LD   hl,0   ; Initialize HL with 0
031C                NEXTTOKEN1:      
031C   CD FE 04               CALL   nextChar   ; Get the next character
031F   FE 20                  CP   " "   ; is it space?
0321   28 F9                  JR   z,nextToken1   ; If yes, skip it and get the next character
0323   FE FF                  CP   EOF   ; Is it null (end of input)?
0325   20 03                  JR   nz,nextToken2   ; If not, continue to the next check
0327                NEXTTOKEN1A:      
0327   3E 45                  LD   a,EOF_   ; If yes, return with EOF token
0329   C9                     RET      
032A                NEXTTOKEN2:      
032A   FE 5C                  CP   $5C   ; Is it a statement separator? "\"
032C   20 0B                  JR   nz,nextToken3   ; If not, continue to the next check
032E   FE 3A                  CP   ":"   ; Is it a statement separator? ":"
0330   20 07                  JR   nz,nextToken3   ; If not, continue to the next check
0332   FE 0A                  CP   "\n"   ; Is it a new line
0334   30 03                  JR   nc,nextToken3   ; If not, continue to the next check
0336   3E 0A                  LD   a,NEWLN_   ; If yes, return with NEWLIN token
0338   C9                     RET      ; Return with newline token
0339                NEXTTOKEN3:      
0339   FE 3B                  CP   ";"   ; Is it a comment?
033B   C4 4A 03               CALL   nz,nextToken5   ; If not, continue to the next check
033E                NEXTTOKEN4:      
033E   CD FE 04               CALL   nextChar   ; Get the next character in the comment
0341   FE 21                  CP   " "+1   ; Loop until the next control character
0343   30 F9                  JR   nc,nextToken4   
0345   CD 69 05               CALL   rewindChar   ; Push back the character
0348   18 CF                  JR   nextToken0   ; return with control char
034A                NEXTTOKEN5:      
034A   FE 5F                  CP   "_"   ; Is it an identifier?
034C   28 05                  JR   z,nextToken6   ; If yes, continue to the next check
034E   CD 6C 04               CALL   isAlpha   ; If not, check if it's alphabetic
0351   30 37                  JR   nc,nextToken11   ; If not, continue to the next check
0353                NEXTTOKEN6:      
0353   CD C9 03               CALL   ident   ; Parse the identifier
0356   FE 3A                  CP   ":"   ; Is it a label?
0358   20 03                  JR   nz,nextToken7   ; If not, continue to the next check
035A   3E 4C                  LD   a,LABEL_   ; If yes, return A = LABEL HL = string
035C   C9                     RET      
035D                NEXTTOKEN7:      
035D   CD 69 05               CALL   rewindChar   ; Push back the character
0360   22 8B 31               LD   (vStrPtr),hl   ; Restore string heap pointer to previous location
0363   CD 0C 04               CALL   searchOpcode   
0366   30 06                  JR   nc,nextToken8   
0368   6F                     LD   l,a   ; hl = opcode value
0369   26 00                  LD   h,0   
036B   3E 43                  LD   a,OPCODE_   ; Return with OPCODE token
036D   C9                     RET      
036E                NEXTTOKEN8:      
036E   CD 39 04               CALL   searchOpElem   
0371   30 06                  JR   nc,nextToken9   
0373   6F                     LD   l,a   ; hl = op element value
0374   26 00                  LD   h,0   
0376   3E 4D                  LD   a,OPELEM_   ; Return with OPELEM token
0378   C9                     RET      
0379                NEXTTOKEN9:      
0379   11 12 07               LD   de,directives   ; List of directives to search
037C   CD E9 03               CALL   searchStr   
037F   30 06                  JR   nc,nextToken10   
0381   6F                     LD   l,a   ; hl = directive value
0382   26 00                  LD   h,0   
0384   3E 44                  LD   a,DIRECT_   ; Return with DIRECT token
0386   C9                     RET      
0387                NEXTTOKEN10:      
0387   3E 49                  LD   a,IDENT_   ; Return with IDENT token
0389   C9                     RET      
038A                NEXTTOKEN11:      
038A   21 00 00               LD   hl,0   
038D   FE 24                  CP   "$"   ; Is it a hexadecimal number?
038F   20 14                  JR   nz,nextToken12   ; If not, continue to the next check
0391   CD FE 04               CALL   nextChar   ; Get the next character
0394   CD 68 04               CALL   isAlphaNum   ; Check if it's the ASSEMBLY pointer
0397   20 06                  JR   nz,nextToken11a   ; If not, continue to the next check
0399   CD AC 04               CALL   number_hex   ; Process hexadecimal number
039C   3E 39                  LD   a,NUM_   ; Return with NUM token
039E   C9                     RET      
039F                NEXTTOKEN11A:      
039F   CD 69 05               CALL   rewindChar   ; Push back the character (flags unaffected)
03A2   3E 24                  LD   a,DOLLAR_   ; Return with DOLLAR token
03A4   C9                     RET      ; Return with the DOLLAR token
03A5                NEXTTOKEN12:      
03A5   FE 2D                  CP   "-"   ; Is it a negative number?
03A7   28 05                  JR   z,nextToken13   ; If yes, continue to the next check
03A9   CD 79 04               CALL   isDigit   ; Check if it's a digit
03AC   30 06                  JR   nc,nextToken15   ; Jump to the next check
03AE                NEXTTOKEN13:      
03AE   CD 80 04               CALL   number   ; Parse the number
03B1                NEXTTOKEN14:      
03B1   3E 39                  LD   a,NUM_   ; Return with NUM token
03B3   C9                     RET      
03B4                NEXTTOKEN15:      
03B4   FE 28                  CP   "("   
03B6   C8                     RET   z   ; Return with the LPAREN token
03B7   FE 29                  CP   ")"   
03B9   C8                     RET   z   ; Return with the RPAREN token
03BA   FE 2C                  CP   ","   
03BC   C8                     RET   z   ; Return with the COMMA token
03BD   3E 55                  LD   a,UNKNOWN_   ; Return with UNKNOWN token
03BF   C9                     RET      
03C0                             ; *****************************************************************************
03C0                             ; Routine: pushBackToken
03C0                             ; 
03C0                             ; Purpose:
03C0                             ;    Pushes back a token into the pushback BUFFER to allow the token to be
03C0                             ;    re-read by the nextToken routine.
03C0                             ; 
03C0                             ; Inputs:
03C0                             ;    A  - token type
03C0                             ;    HL - token value
03C0                             ; 
03C0                             ; Outputs:
03C0                             ;    None
03C0                             ; 
03C0                             ; Registers Destroyed:
03C0                             ;    A, DE
03C0                             ; *****************************************************************************
03C0                PUSHBACKTOKEN:      
03C0   CB FF                  SET   7,a   ; Set the high bit of the token type (without affecting flags)
03C2   32 84 31               LD   (vToken),a   ; push back the token
03C5   22 85 31               LD   (vTokenVal),hl   ; push back the token value
03C8   C9                     RET      
03C9                             ; *****************************************************************************
03C9                             ; Routine: ident
03C9                             ; 
03C9                             ; Purpose:
03C9                             ;    Reads characters from the input stream until a charcter which is not an
03C9                             ;    an underscore or an alphanumeric character is encountered. Writes the chars
03C9                             ;    to a Pascal string and updates the top of the STRINGS heap pointer.
03C9                             ;    It also calculates the length of the string and stores it at the beginning
03C9                             ;    of the string.
03C9                             ; 
03C9                             ; Inputs:
03C9                             ;    A - Current character read from the input stream
03C9                             ;    vStrPtr - Address of the top of STRINGS heap pointer
03C9                             ; 
03C9                             ; Outputs:
03C9                             ;    A - last character read from the input stream
03C9                             ;    HL - identifier string
03C9                             ; 
03C9                             ; Registers Destroyed:
03C9                             ;    DE, HL
03C9                             ; *****************************************************************************
03C9                IDENT:       
03C9   2A 8B 31               LD   hl,(vStrPtr)   ; Load the address of the top of STRINGS heap
03CC   E5                     PUSH   hl   ; save start of string
03CD   23                     INC   hl   ; Move to the next byte to skip the length byte
03CE                IDENT1:      
03CE   77                     LD   (hl),a   ; Write the current character to the string BUFFER
03CF   23                     INC   hl   ; Move to the next position in the BUFFER
03D0   E5                     PUSH   hl   
03D1   CD FE 04               CALL   nextChar   ; Get the next character from the input stream
03D4   E1                     POP   hl   
03D5   FE 5F                  CP   "_"   ; Compare with underscore character
03D7   28 F5                  JR   z,ident1   ; If underscore, jump to ident2
03D9   CD 68 04               CALL   isAlphanum   ; Check if the character is alphanumeric
03DC   38 F0                  JR   c,ident1   ; If not alphanumeric, jump to ident3
03DE                IDENT3:      
03DE   22 8B 31               LD   (vStrPtr),hl   ; Update the top of STRINGS heap pointer
03E1   D1                     POP   de   ; restore start of string into de
03E2   B7                     OR   a   ; Clear carry
03E3   ED 52                  SBC   hl,de   ; Calculate the length of the string (HL = length, DE = string)
03E5   2D                     DEC   l   ; reduce by one (length byte)
03E6   EB                     EX   de,hl   ; Swap DE and HL (E = length, HL = string)
03E7   73                     LD   (hl),e   ; Store the length at the beginning of the string BUFFER
03E8   C9                     RET      
03E9                             ; ; *****************************************************************************
03E9                             ; ; Routine: expr
03E9                             ; ;
03E9                             ; ; Purpose:
03E9                             ; ;    Collects a string until it reaches a right parenthesis, comma, semicolon,
03E9                             ; ;    or newline character. Keeps track of parentheses to ensure correct ending
03E9                             ; ;    of the expression.
03E9                             ; ;
03E9                             ; ; Inputs:
03E9                             ; ;    None
03E9                             ; ;
03E9                             ; ; Outputs:
03E9                             ; ;    HL - Points to the collected string.
03E9                             ; ;    A - Contains the length of the collected string.
03E9                             ; ;
03E9                             ; ; Registers Destroyed:
03E9                             ; ;    A, C, D, E, HL
03E9                             ; ; *****************************************************************************
03E9                             ; expr:
03E9                             ;     ld hl, (vStrPtr)        ; Load the address of the top of STRINGS heap
03E9                             ;     ld de, hl               ; Copy it to DE (DE = HL = top of STRINGS heap)
03E9                             ;     inc hl                  ; Move to the next byte to skip the length byte
03E9                             ;     ld c, 1                 ; Initialize parenthesis count to 1
03E9                             ; expr1:
03E9                             ;     ld (hl), a              ; Write the current character to the string BUFFER
03E9                             ;     inc hl                  ; Move to the next position in the BUFFER
03E9                             ;     call nextChar           ; Get the next character from the input stream
03E9                             ;     cp "("                  ; Compare with left parenthesis character
03E9                             ;     jr z, expr2             ; If left parenthesis, increase count
03E9                             ;     cp ")"                  ; Compare with right parenthesis character
03E9                             ;     jr z, expr3             ; If right parenthesis, decrease count
03E9                             ;     cp ","                  ; Compare with comma character
03E9                             ;     jr z, expr4             ; If comma, check if parentheses count is zero
03E9                             ;     cp ";"                  ; Compare with semicolon character
03E9                             ;     jr z, expr4             ; If semicolon, check if parentheses count is zero
03E9                             ;     cp "\n"                 ; Compare with newline character
03E9                             ;     jr z, expr4             ; If newline, check if parentheses count is zero
03E9                             ;     call isAlphanum         ; Check if the character is alphanumeric
03E9                             ;     jr nc, expr4            ; If not alphanumeric, check if parentheses count is zero
03E9                             ;     jr expr1                ; Repeat the process
03E9                             ; expr2:
03E9                             ;     inc c                   ; Increase parentheses count
03E9                             ;     jr expr1                ; Repeat the process
03E9                             ; expr3:
03E9                             ;     dec c                   ; Decrease parentheses count
03E9                             ;     jr nz, expr1            ; If not zero, continue collecting
03E9                             ;     jr expr5                ; If zero, end collection
03E9                             ; expr4:
03E9                             ;     xor a
03E9                             ;     cp c                    ; Check if parentheses count is zero
03E9                             ;     jr nz, expr1            ; If not zero, continue collecting
03E9                             ; expr5:
03E9                             ;     call rewindChar         ; Rewind the input stream by one character
03E9                             ;     ld (vStrPtr), hl        ; Update the top of STRINGS heap pointer
03E9                             ;     or a                    ; Clear A register
03E9                             ;     sbc hl, de              ; Calculate the length of the string (HL = length, DE = string)
03E9                             ;     ex de, hl               ; Swap DE and HL (E = length, HL = string)
03E9                             ;     ld (hl), e              ; Store the length at the beginning of the string BUFFER
03E9                             ;     ld a, e                 ; Load the length into A
03E9                             ;     ret
03E9                             ; *****************************************************************************
03E9                             ; Routine: searchStr
03E9                             ; 
03E9                             ; Purpose:
03E9                             ;    Search through a list of Pascal STRINGS for a match.
03E9                             ; 
03E9                             ; Inputs:
03E9                             ;    HL - Points to the string to search for.
03E9                             ;    DE - Points to the start of the list of STRINGS.
03E9                             ; 
03E9                             ; Outputs:
03E9                             ;    CF - True if match, false otherwise.
03E9                             ;    A - Index of the matching string if a match is found, or -1 if no match
03E9                             ;        is found.
03E9                             ;    HL - Points to the string to search for.
03E9                             ; 
03E9                             ; Destroyed:
03E9                             ;    A, B, C, D, E, A", F"
03E9                             ; *****************************************************************************
03E9                SEARCHSTR:      
03E9   EB                     EX   de,hl   ; DE = search string, HL = string list
03EA   AF                     XOR   a   ; Initialize index counter, ZF = true, CF = false
03EB   08                     EX   af,af'   ; Exchange AF with AF prime
03EC                SEARCHSTR1:      
03EC   D5                     PUSH   de   ; Store search string
03ED   E5                     PUSH   hl   ; Store current string
03EE   CD 52 04               CALL   compareStr   
03F1   20 F6                  JR   nz,searchStr   
03F3   E1                     POP   hl   ; Discard current string
03F4   E1                     POP   hl   ; HL = search string
03F5   08                     EX   af,af'   ; Load index of match
03F6   3F                     CCF      ; If match, CF = true
03F7   C9                     RET      
03F8                SEARCHSTR3:      
03F8   E1                     POP   hl   ; Restore current string
03F9   D1                     POP   de   ; Restore search string
03FA   7E                     LD   a,(hl)   ; Load length of current string
03FB   3C                     INC   a   ; A = length byte plus length of string
03FC   4F                     LD   c,a   ; BC = A
03FD   06 00                  LD   b,0   
03FF   09                     ADD   hl,bc   ; HL += BC, move to next string
0400   D5                     PUSH   de   ; Store search string
0401   E5                     PUSH   hl   ; Store current string
0402   08                     EX   af,af'   ; Increment index counter, ZF = false, CF = false
0403   3C                     INC   a   
0404   08                     EX   af,af'   
0405   7E                     LD   a,(hl)   ; A = length of next string
0406   B7                     OR   a   ; If A != 0, continue searching
0407   20 E3                  JR   nz,searchStr1   
0409   3D                     DEC   a   ; A = NO_MATCH (i.e., -1), ZF = false
040A   3F                     CCF      ; CF = false
040B   C9                     RET      
040C                             ; *****************************************************************************
040C                             ; Routine: searchOpcode
040C                             ; 
040C                             ; Purpose:
040C                             ;    Searches for a matching opcode in various lists of opcodes.
040C                             ; 
040C                             ; Inputs:
040C                             ;    HL - Points to the string to search for.
040C                             ; 
040C                             ; Outputs:
040C                             ;    CF - Set if a match is found, cleared otherwise.
040C                             ;    A  - Contains the index of the matching opcode if a match is found,
040C                             ;         or the last checked index if no match is found.
040C                             ; 
040C                             ; Registers Destroyed:
040C                             ;    A, DE, F
040C                             ; *****************************************************************************
040C                SEARCHOPCODE:      
040C   11 D2 05               LD   de,alu_opcodes   ; Point DE to the list of ALU opcodes
040F   CD E9 03               CALL   searchStr   ; Search for the string in ALU opcodes
0412   D8                     RET   c   ; If match found (CF set), return
0413   11 B3 05               LD   de,rot_opcodes   ; Point DE to the list of ROT opcodes
0416   CD E9 03               CALL   searchStr   ; Search for the string in ROT opcodes
0419   CB EF                  SET   5,a   ; Set bit 5 in A to indicate ROT opcodes
041B   D8                     RET   c   ; If match found (CF set), return
041C   11 F1 05               LD   de,bli_opcodes   ; Point DE to the list of BLI opcodes
041F   CD E9 03               CALL   searchStr   ; Search for the string in BLI opcodes
0422   CB F7                  SET   6,a   ; Set bit 6 in A to indicate BLI opcodes
0424   D8                     RET   c   ; If match found (CF set), return
0425   11 3C 06               LD   de,gen1_opcodes   ; Point DE to the list of general opcodes (set 1)
0428   CD E9 03               CALL   searchStr   ; Search for the string in general opcodes
042B   CB EF                  SET   5,a   ; Set bits 5 & 6 in A to indicate general opcodes (set 1)
042D   CB F7                  SET   6,a   
042F   D8                     RET   c   ; If match found (CF set), return
0430   11 65 06               LD   de,gen2_opcodes   ; Point DE to the list of general opcodes (set 2)
0433   CD E9 03               CALL   searchStr   ; Search for the string in general opcodes
0436   CB FF                  SET   7,a   ; Set bit 7 in A to indicate general opcodes (set 2)
0438   C9                     RET      ; Return if no match is found
0439                             ; *****************************************************************************
0439                             ; Routine: searchOpElem
0439                             ; 
0439                             ; Purpose:
0439                             ;    Searches for an op element in the lists of 8-bit registers, 16-bit registers,
0439                             ;    and flags. Sets appropriate flags based on the type of operand found.
0439                             ; 
0439                             ; Inputs:
0439                             ;    HL - Points to the start of the string to search for.
0439                             ; 
0439                             ; Outputs:
0439                             ;    A  - The index of the matching op element if a match is found, or -1 if no
0439                             ;         match is found.
0439                             ;    CF - Carry flag is set if a match is found.
0439                             ; 
0439                             ; Registers Destroyed:
0439                             ;    A, DE, HL
0439                             ; *****************************************************************************
0439                             ; reg_    .equ    0x00    ; A, B etc
0439                             ; rp_     .equ    0x08    ; bit 3: 8-bit or 16-bit e.g. A or HL, 0xff or 0xffff
0439                             ; flag_   .equ    0x10    ; bit 4: NZ etc
0439                SEARCHOPELEM:      
0439   11 CE 06               LD   de,reg8   ; Point DE to the list of 8-bit register operands
043C   CD E9 03               CALL   searchStr   ; Search for the string in reg8 operands
043F   D8                     RET   c   ; If match found (CF set), return
0440   11 E3 06               LD   de,reg16   ; Point DE to the list of 16-bit register operands
0443   CD E9 03               CALL   searchStr   ; Search for the string in reg16 operands
0446   CB DF                  SET   3,a   ; Set bit 4 in A to indicate a register operand
0448   D8                     RET   c   ; If match found (CF set), return
0449   11 FD 06               LD   de,flags   ; Point DE to the list of flag operands
044C   CD E9 03               CALL   searchStr   ; Search for the string in flag operands
044F   CB E7                  SET   4,a   ; Set bit 3 in A to indicate flag operand
0451   C9                     RET      ; Return if no match is found
0452                             ; *****************************************************************************
0452                             ; Routine: compareStr
0452                             ; 
0452                             ; Purpose:
0452                             ;    Compares two Pascal strings. The comparison includes
0452                             ;    the length byte and continues until all characters are compared or a
0452                             ;    mismatch is found.
0452                             ; 
0452                             ; Inputs:
0452                             ;    DE - Points to the start of string1
0452                             ;    HL - Points to the start of string2
0452                             ; 
0452                             ; Outputs:
0452                             ;    ZF - Set if the strings are equal
0452                             ; 
0452                             ; Registers Destroyed:
0452                             ;    A, B, DE, HL
0452                             ; *****************************************************************************
0452                COMPARESTR:      
0452   1A                     LD   a,(de)   ; Load length of search string
0453   47                     LD   b,a   ; Copy length to B for looping
0454   04                     INC   b   ; Increase to include length byte
0455                COMPARESTR2:      
0455   1A                     LD   a,(de)   ; Load next character from search string
0456   BE                     CP   (hl)   ; Compare with next character in current string
0457   C0                     RET   nz   ; Return if characters are not equal
0458   13                     INC   de   ; Move to next character in search string
0459   23                     INC   hl   ; Move to next character in current string
045A   10 F9                  DJNZ   compareStr2   ; Loop until all characters compared or mismatch
045C                COMPARESTR3:      
045C   C9                     RET      ; Return with ZF set if strings are equal
045D                ISENDOFEXPR:      
045D   B8                     CP   b   ; Compare operand with IX
045E   C8                     RET   z   ; Return if equal (ZF is set)
045F   FE 0A                  CP   "\n"   ; Compare operand with IY
0461   C9                     RET      ; Return (ZF is set if equal, cleared otherwise)
0462                             ; *****************************************************************************
0462                             ; Routine: isIndexReg
0462                             ; 
0462                             ; Purpose:
0462                             ;    Checks if the current operand is an index register (IX or IY).
0462                             ; 
0462                             ; Inputs:
0462                             ;    A - The operand to check.
0462                             ; 
0462                             ; Outputs:
0462                             ;    ZF - Set if the operand is an index register (IX or IY).
0462                             ; 
0462                             ; Registers Destroyed:
0462                             ;    None
0462                             ; *****************************************************************************
0462                ISINDEXREG:      
0462   FE 0D                  CP   IX_   ; Compare operand with IX
0464   C8                     RET   z   ; Return if equal (ZF is set)
0465   FE 0E                  CP   IY_   ; Compare operand with IY
0467   C9                     RET      ; Return (ZF is set if equal, cleared otherwise)
0468                             ; *****************************************************************************
0468                             ; Routine: isAlphaNum
0468                             ; 
0468                             ; Purpose:
0468                             ;    Checks if the character in the A register is an alphanumeric character
0468                             ;    (either uppercase or lowercase). If the character is alphabetic, it converts
0468                             ;    it to uppercase and sets the carry flag. If the character is not alphabetic,
0468                             ;    it clears the carry flag.
0468                             ; 
0468                             ; Input:
0468                             ;    A - Contains the character to be checked.
0468                             ; 
0468                             ; Output:
0468                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
0468                             ;    CF - Set if the input character was alphabetic, cleared otherwise.
0468                             ; 
0468                             ; Destroyed:
0468                             ;    C
0468                             ; *****************************************************************************
0468                ISALPHANUM:      
0468   CD 79 04               CALL   isDigit   ; Check if it's a digit
046B   C8                     RET   z   ; If it's not a digit, continue to isAlpha
046C                             ; Falls through to isAlpha
046C                             ; *****************************************************************************
046C                             ; Routine: isAlpha
046C                             ; 
046C                             ; Purpose:
046C                             ;    Checks if the character in the A register is an alphabetic character
046C                             ;    (either uppercase or lowercase). If the character is alphabetic, it converts
046C                             ;    it to uppercase and sets the carry flag.
046C                             ; 
046C                             ; Input:
046C                             ;    A - Contains the character to be checked.
046C                             ; 
046C                             ; Output:
046C                             ;    A - Contains the uppercase version of the input character if it was alphabetic.
046C                             ;    CF - Set if the input character was alphabetic, cleared otherwise.
046C                             ; 
046C                             ; Destroyed:
046C                             ;    None
046C                             ; *****************************************************************************
046C                ISALPHA:      
046C   FE 61                  CP   "a"   ; Compare with lowercase "a"
046E   38 02                  JR   c,isAlpha1   ; Jump if it"s lower than "a'
0470   D6 20                  SUB   $20   ; Convert lowercase to uppercase
0472                ISALPHA1:      
0472   FE 5B                  CP   "Z"+1   ; Compare with "Z" + 1
0474   D0                     RET   nc   ; Return if it's not alphabetic
0475   FE 41                  CP   "A"   ; Compare with "A"
0477   3F                     CCF      ; Invert CF to set it if it's alphabetic
0478   C9                     RET      ; Return
0479                             ; *****************************************************************************
0479                             ; Routine: isDigit
0479                             ; 
0479                             ; Purpose:
0479                             ;    Checks if the character in the A register is a decimal digit (0-9). If
0479                             ;    the character is a decimal digit, it sets the carry flag.
0479                             ; 
0479                             ; Input:
0479                             ;    A - Contains the character to be checked.
0479                             ; 
0479                             ; Output:
0479                             ;    CF - Set if the input character was a digit, cleared otherwise.
0479                             ; 
0479                             ; Destroyed:
0479                             ;    None
0479                             ; *****************************************************************************
0479                ISDIGIT:      
0479   FE 3A                  CP   "9"+1   ; Compare with "9" + 1
047B   D0                     RET   nc   ; Return if it's not a digit
047C   FE 30                  CP   "0"   ; Compare with "0"
047E   3F                     CCF      ; Invert CF to set it if it's a digit
047F   C9                     RET      ; Return
0480                             ; *****************************************************************************
0480                             ; Routine: number
0480                             ; 
0480                             ; Purpose:
0480                             ;    Parse a number from the input. Handles both decimal and hexadecimal
0480                             ;    numbers, and supports negative numbers.
0480                             ; 
0480                             ; Input:
0480                             ;    A - first char of number
0480                             ; 
0480                             ; Output:
0480                             ;    HL - Contains the parsed number.
0480                             ; 
0480                             ; Destroyed:
0480                             ;    None
0480                             ; *****************************************************************************
0480                NUMBER:      
0480   FE 2D                  CP   "-"   ; Check if it's a negative number
0482   3E FF                  LD   a,-1   ; Set sign flag
0484   28 01                  JR   z,number1   
0486   3C                     INC   a   ; Set sign flag to positive
0487                NUMBER1:      
0487   32 80 31               LD   (vTemp1),a   ; Store the sign flag in vTemp1
048A   CD FE 04               CALL   nextChar   ; Get the next character
048D   FE 24                  CP   "$"   ; Check if it's a hexadecimal number
048F   20 05                  JR   nz,number2   
0491   CD B8 04               CALL   hex   ; If yes, parse hexadecimal number
0494   18 06                  JR   number3   
0496                NUMBER2:      
0496   CD 69 05               CALL   rewindChar   ; Push back the character
0499   CD E3 04               CALL   decimal   ; Parse decimal number
049C                NUMBER3:      
049C   3A 80 31               LD   a,(vTemp1)   ; Load the sign from vTemp1
049F   3C                     INC   a   ; Increment to negate if necessary
04A0   C0                     RET   nz   ; Return if sign is not zero
04A1   EB                     EX   de,hl   ; Negate the value of HL
04A2   21 00 00               LD   hl,0   ; Load zero to clear carry
04A5   B7                     OR   a   ; Clear carry flag
04A6   ED 52                  SBC   hl,de   ; Subtract DE from HL
04A8   CD 69 05               CALL   rewindChar   ; Push back the character
04AB   C9                     RET      ; Return
04AC                NUMBER_HEX:      
04AC   CD 69 05               CALL   rewindChar   
04AF   AF                     XOR   a   
04B0   32 80 31               LD   (vTemp1),a   ; Store the sign flag in vTemp1
04B3   CD B8 04               CALL   hex   ; Parse hexadecimal number
04B6   18 E4                  JR   number3   
04B8                             ; *****************************************************************************
04B8                             ; Routine: hex
04B8                             ; 
04B8                             ; Purpose:
04B8                             ;    Parse a hexadecimal number.
04B8                             ; 
04B8                             ; Input:
04B8                             ;    None
04B8                             ; 
04B8                             ; Output:
04B8                             ;    HL - Parsed number.
04B8                             ; 
04B8                             ; Destroyed:
04B8                             ;    A
04B8                             ; *****************************************************************************
04B8                HEX:         
04B8   21 00 00               LD   hl,0   ; Initialize HL to 0
04BB                HEX1:        
04BB   CD FE 04               CALL   nextChar   ; Get the next character
04BE   FE 30                  CP   "0"   ; Compare with ASCII "0"
04C0   D8                     RET   c   ; Return if less than "0"
04C1   FE 3A                  CP   "9"+1   ; Compare with ASCII "9" + 1
04C3   38 0F                  JR   c,valid   ; If less or equal, jump to valid
04C5   FE 61                  CP   "a"   ; Compare with ASCII "a"
04C7   38 02                  JR   c,hex2   ; If less, jump to hex2
04C9   D6 20                  SUB   $20   ; Convert lowercase to uppercase
04CB                HEX2:        
04CB   FE 41                  CP   "A"   ; Compare with ASCII "A"
04CD   D8                     RET   c   ; Return if less than "A"
04CE   FE 47                  CP   "F"+1   ; Compare with ASCII "F" + 1
04D0   38 00                  JR   c,upper   ; If less or equal, jump to upper
04D2                UPPER:       
04D2   D6 37                  SUB   $37   ; Convert ASCII to hexadecimal
04D4                VALID:       
04D4   D6 30                  SUB   "0"   ; Convert ASCII to numeric value
04D6   D8                     RET   c   ; Return if less than 0 (not a valid digit)
04D7   FE 10                  CP   $10   ; Compare with 16
04D9   D0                     RET   nc   ; Return if greater than 16 (not a valid digit)
04DA   29                     ADD   hl,hl   ; Multiply by 16
04DB   29                     ADD   hl,hl   ; Multiply by 16
04DC   29                     ADD   hl,hl   ; Multiply by 16
04DD   29                     ADD   hl,hl   ; Multiply by 16
04DE   85                     ADD   a,l   ; Add new digit to HL
04DF   6F                     LD   l,a   ; Store result back in L
04E0   C3 BB 04               JP   hex1   ; Jump back to hex1 to process next character
04E3                             ; *****************************************************************************
04E3                             ; Routine: decimal
04E3                             ; 
04E3                             ; Purpose:
04E3                             ;    Parse a decimal number.
04E3                             ; 
04E3                             ; Input:
04E3                             ;    None
04E3                             ; 
04E3                             ; Output:
04E3                             ;    HL - Parsed number.
04E3                             ; 
04E3                             ; Destroyed:
04E3                             ;    A, DE
04E3                             ; *****************************************************************************
04E3                DECIMAL:      
04E3   21 00 00               LD   hl,0   ; Initialize HL to 0
04E6                DECIMAL1:      
04E6   CD FE 04               CALL   nextChar   ; Get the next character
04E9   D6 30                  SUB   "0"   ; Convert ASCII to binary
04EB   D8                     RET   c   ; Return if less than "0"
04EC   FE 0A                  CP   10   ; Compare with 10
04EE   D0                     RET   nc   ; Return if greater than 10
04EF   03                     INC   bc   ; Increment BC to point to next digit
04F0   54 5D                  LD   de,hl   ; Copy HL to DE
04F2   29                     ADD   hl,hl   ; Multiply HL by 2
04F3   29                     ADD   hl,hl   ; Multiply HL by 4
04F4   19                     ADD   hl,de   ; Add DE to HL to multiply by 5
04F5   29                     ADD   hl,hl   ; Multiply HL by 10
04F6   85                     ADD   a,l   ; Add A to HL
04F7   6F                     LD   l,a   ; Store result back in L
04F8   3E 00                  LD   a,0   ; Clear A
04FA   8C                     ADC   a,h   ; Add carry to H
04FB   67                     LD   h,a   ; Store result back in H
04FC   18 E8                  JR   decimal1   ; Jump back to start of loop
04FE                             ; *****************************************************************************
04FE                             ; Routine: nextChar
04FE                             ; 
04FE                             ; Purpose:
04FE                             ;    Fetches the next character from the BUFFER. If the BUFFER is empty or
04FE                             ;    contains a null character (0), it refills the BUFFER by calling nextLine.
04FE                             ; 
04FE                             ; Inputs:
04FE                             ;    None
04FE                             ; 
04FE                             ; Outputs:
04FE                             ;    A - The next character from the BUFFER
04FE                             ; 
04FE                             ; Registers Destroyed:
04FE                             ;    A, D, E, HL
04FE                             ; *****************************************************************************
04FE                NEXTCHAR:      
04FE   21 87 31               LD   hl,vBufferPos   ; Load the offset of BUFFER position variable
0501   7E                     LD   a,(hl)   ; Load the current position offset in the BUFFER into A
0502   FE 80                  CP   BUFFER_SIZE   ; Compare with BUFFER size
0504   CA 15 05               JP   z,nextLine   ; Jump to nextLine if end of BUFFER
0507   11 00 30               LD   de,BUFFER   ; Load the MSB of the BUFFER's address into D
050A   83                     ADD   a,e   ; de += a
050B   5F                     LD   e,a   
050C   3E 00                  LD   a,0   
050E   8A                     ADC   a,d   
050F   57                     LD   d,a   
0510   1A                     LD   a,(de)   ; Load the character at the current BUFFER position into A
0511   34                     INC   (hl)   ; Increment the BUFFER position offset
0512   FE 0A                  CP   "\n"   ; if a != null return else load a new line into buffer
0514   C0                     RET   nz   
0515                NEXTLINE:      
0515   21 00 30               LD   hl,BUFFER   ; Start of the BUFFER
0518   06 80                  LD   b,BUFFER_SIZE   ; Number of bytes to fill
051A                NEXTLINE1:      
051A   CD 81 00               CALL   getchar   ; Get a character from getchar
051D   FE FF                  CP   EOF   ; is it EOF
051F   28 32                  JR   z,nextLine5a   
0521   B7                     OR   a   ; is it NULL?
0522   28 04                  JR   z,nextLine2   
0524   FE 03                  CP   CTRL_C   ; is it ctrl-C ?
0526   20 04                  JR   nz,nextLine3   
0528                NEXTLINE2:      
0528   3E FF                  LD   a,EOF   
052A   18 27                  JR   nextLine5a   
052C                NEXTLINE3:      
052C   FE 08                  CP   "\b"   ; Check if character is backspace
052E   20 10                  JR   nz,nextLine4   ; If not, proceed to store the character
0530   3E 80                  LD   a,BUFFER_SIZE   
0532   90                     SUB   b   ; Check if at the start of the buffer
0533   28 E5                  JR   z,nextLine1   ; If at the start, ignore backspace
0535   2B                     DEC   hl   ; Move back in the buffer
0536   04                     INC   b   ; Adjust buffer size counter
0537   CD 86 05               CALL   print   ; Erase the character at the current cursor position
053A   1B 5B 50 00            .CSTR   ESC,"[P"   ; Escape sequence for erasing character
053E   18 DA                  JR   nextLine1   
0540                NEXTLINE4:      
0540   CD 87 00               CALL   putchar   ; Echo character to terminal
0543   FE 09                  CP   "\t"   
0545   20 04                  JR   nz,nextLine5   ; if a == CR or NL replace with null
0547   3E 20                  LD   a," "   
0549   18 0B                  JR   nextLine6   
054B                NEXTLINE5:      
054B   FE 0D                  CP   "\r"   ; Check if character is carriage return
054D   20 07                  JR   nz,nextLine6   
054F   3E 0A                  LD   a,"\n"   
0551   18 03                  JR   nextLine6   
0553                NEXTLINE5A:      
0553   36 0A                  LD   (hl),"\n"   ; insert newline before EOF
0555   23                     INC   hl   
0556                NEXTLINE6:      
0556   77                     LD   (hl),a   ; Store the character in the BUFFER
0557   23                     INC   hl   ; Move to the next position in the BUFFER
0558   FE FF                  CP   EOF   ; Break loop if character is end of line
055A   28 06                  JR   z,nextLine7   
055C   FE 0A                  CP   "\n"   ; Break loop if character is end of line
055E   28 02                  JR   z,nextLine7   
0560   10 B8                  DJNZ   nextLine1   ; Repeat until BUFFER is full
0562                NEXTLINE7:      
0562   21 87 31               LD   hl,vBufferPos   
0565   36 00                  LD   (hl),0   
0567   18 95                  JR   nextChar   
0569                             ; *****************************************************************************
0569                             ; Routine: rewindChar
0569                             ; 
0569                             ; Purpose:
0569                             ;    Rewinds the BUFFER position by one character, effectively pushing back the
0569                             ;    BUFFER position by one character in the input stream.
0569                             ; 
0569                             ; Inputs:
0569                             ;    None
0569                             ; 
0569                             ; Outputs:
0569                             ;    None
0569                             ; 
0569                             ; Registers Destroyed:
0569                             ;    A
0569                             ; *****************************************************************************
0569                REWINDCHAR:      
0569   21 87 31               LD   hl,vBufferPos   ; Load the address of BUFFER position variable
056C   7E                     LD   a,(hl)   ; Load the current position in the BUFFER into A
056D   B7                     OR   a   ; Check if the BUFFER position is zero
056E   C8                     RET   z   ; If zero, nothing to push back, return
056F   35                     DEC   (hl)   ; Decrement the BUFFER position
0570   C9                     RET      ; Return
0571                             ; *****************************************************************************
0571                             ; Routine: prompt
0571                             ; 
0571                             ; Purpose:
0571                             ;    Prints a prompt symbol ("> ") to indicate readiness for user input.
0571                             ; 
0571                             ; Inputs:
0571                             ;    None
0571                             ; 
0571                             ; Outputs:
0571                             ;    None
0571                             ; 
0571                             ; Registers Destroyed:
0571                             ;    A, HL
0571                             ; *****************************************************************************
0571                PROMPT:      
0571   CD 86 05               CALL   print   ; Print the null-terminated string (prompt message)
0574   0D 0A 3E 20 00         .CSTR   "\r\n> "   ; Define the prompt message
0579   C9                     RET      ; Return to the caller
057A                             ; *****************************************************************************
057A                             ; Routine: crlf
057A                             ; 
057A                             ; Purpose:
057A                             ;    Prints a carriage return and line feed (new line) to the output.
057A                             ; 
057A                             ; Inputs:
057A                             ;    None
057A                             ; 
057A                             ; Outputs:
057A                             ;    None
057A                             ; 
057A                             ; Registers Destroyed:
057A                             ;    A, HL
057A                             ; *****************************************************************************
057A                CRLF:        
057A   CD 86 05               CALL   print   ; Print the null-terminated string (carriage return and line feed)
057D   0D 0A 00               .CSTR   "\r\n"   ; Define the carriage return and line feed message
0580   C9                     RET      ; Return to the caller
0581                             ; *****************************************************************************
0581                             ; Routine: error
0581                             ; 
0581                             ; Purpose:
0581                             ;    Prints an error message and halts execution.
0581                             ; 
0581                             ; Inputs:
0581                             ;    (Stack) - The address of the error message to be printed
0581                             ; 
0581                             ; Outputs:
0581                             ;    None
0581                             ; 
0581                             ; Registers Destroyed:
0581                             ;    A, HL
0581                             ; *****************************************************************************
0581                ERROR:       
0581   E1                     POP   hl   ; Retrieve the "return" address which is the address of the error message
0582   CD 8D 05               CALL   printStr   ; Call the routine to print the null-terminated string
0585   76                     HALT      ; Halt the CPU
0586                             ; *****************************************************************************
0586                             ; Routine: print
0586                             ; 
0586                             ; Purpose:
0586                             ;    Prints a null-terminated string starting from the address in HL.
0586                             ; 
0586                             ; Inputs:
0586                             ;    HL - Points to the start of the string to be printed
0586                             ; 
0586                             ; Outputs:
0586                             ;    None
0586                             ; 
0586                             ; Registers Destroyed:
0586                             ;    None
0586                             ; *****************************************************************************
0586                PRINT:       
0586   E3                     EX   (sp),hl   ; Swap HL with the value on the stack to preserve HL
0587   CD 9A 05               CALL   printZStr   ; Call the routine to print the null-terminated string
058A   23                     INC   hl   ; Increment HL to skip the null terminator
058B   E3                     EX   (sp),hl   ; Restore the original value of HL from the stack
058C   C9                     RET      ; Return to the caller
058D                             ; *****************************************************************************
058D                             ; Routine: printStr
058D                             ; 
058D                             ; Purpose:
058D                             ;    Prints a Pascal string stored in memory.
058D                             ; 
058D                             ; Inputs:
058D                             ;    HL - Points to the start of the string (first byte is the length)
058D                             ; 
058D                             ; Outputs:
058D                             ;    None
058D                             ; 
058D                             ; Registers Destroyed:
058D                             ;    A, B, HL
058D                             ; *****************************************************************************
058D                PRINTSTR:      
058D   7E                     LD   a,(hl)   ; Load the length of the string
058E   B7                     OR   a   ; Check if the length is zero
058F   C8                     RET   z   ; If zero, return immediately
0590   23                     INC   hl   ; Move HL to the start of the string data
0591   47                     LD   b,a   ; Copy the length to B for looping
0592                PRINTSTR1:      
0592   7E                     LD   a,(hl)   ; Load the next character
0593   CD 87 00               CALL   putchar   ; Call a routine that prints a single character
0596   23                     INC   hl   ; Move to the next character
0597   10 F9                  DJNZ   printStr1   ; Decrement B and jump if not zero
0599   C9                     RET      ; Return from the routine
059A                             ; *****************************************************************************
059A                             ; Routine: printZStr
059A                             ; 
059A                             ; Purpose:
059A                             ;    Prints a null-terminated string stored in memory.
059A                             ; 
059A                             ; Inputs:
059A                             ;    HL - Points to the start of the string to be printed
059A                             ; 
059A                             ; Outputs:
059A                             ;    None
059A                             ; 
059A                             ; Registers Destroyed:
059A                             ;    A, HL
059A                             ; *****************************************************************************
059A                PRINTZSTR:      
059A   18 04                  JR   printZStr2   ; Jump to the loop condition
059C                PRINTZSTR1:      
059C   CD 87 00               CALL   putchar   ; Print the current character
059F   23                     INC   hl   ; Move to the next character
05A0                PRINTZSTR2:      
05A0   7E                     LD   a,(hl)   ; Load the current character
05A1   B7                     OR   a   ; Check if the character is null
05A2   20 F8                  JR   nz,printZStr1   ; If not null, continue printing
05A4   C9                     RET      ; Return when null character is encountered
05A5                             ; *****************************************************************************
05A5                             ; Routine: hpush
05A5                             ; 
05A5                             ; Purpose:
05A5                             ;    Pushes a 16-bit value onto the heap. The value to be pushed is in DE,
05A5                             ;    and the heap pointer is updated accordingly.
05A5                             ; 
05A5                             ; Inputs:
05A5                             ;    DE - The 16-bit value to be pushed onto the heap.
05A5                             ; 
05A5                             ; Outputs:
05A5                             ;    Updates the heap pointer in vHeapPtr.
05A5                             ; 
05A5                             ; Registers Destroyed:
05A5                             ;    DE, HL
05A5                             ; *****************************************************************************
05A5                HPUSH:       
05A5   D5                     PUSH   de   ; Save DE
05A6   EB                     EX   de,hl   ; Exchange DE and HL to move value to DE
05A7   2A 91 31               LD   hl,(vHeapPtr)   ; Load the current top of the heap into HL
05AA   72                     LD   (hl),d   ; Store the high byte of DE (now in HL) on the heap
05AB   23                     INC   hl   ; Increment HL to point to the next heap position
05AC   73                     LD   (hl),e   ; Store the low byte of DE (now in HL) on the heap
05AD   23                     INC   hl   ; Increment HL to point to the new top of the heap
05AE   22 91 31               LD   (vHeapPtr),hl   ; Update the heap pointer with the new top of the heap
05B1   D1                     POP   de   ; Restore DE
05B2   C9                     RET      ; Return from the subroutine
05B3                             ; ; *****************************************************************************
05B3                             ; ; Routine: hpop
05B3                             ; ;
05B3                             ; ; Purpose:
05B3                             ; ;    Pops a 16-bit value from the heap into HL. The heap pointer is updated
05B3                             ; ;    accordingly.
05B3                             ; ;
05B3                             ; ; Inputs:
05B3                             ; ;    None
05B3                             ; ;
05B3                             ; ; Outputs:
05B3                             ; ;    HL - Contains the 16-bit value popped from the heap.
05B3                             ; ;    Updates the heap pointer in vHeapPtr.
05B3                             ; ;
05B3                             ; ; Registers Destroyed:
05B3                             ; ;    DE, HL
05B3                             ; ; *****************************************************************************
05B3                             ; hpop:
05B3                             ;     push de                 ; Save DE
05B3                             ;     ld hl, (vHeapPtr)       ; Load the current top of the heap into HL
05B3                             ;     dec hl                  ; Decrement HL to point to the high byte of the value
05B3                             ;     ld l, (hl)              ; Load the low byte of the value into L
05B3                             ;     dec hl                  ; Decrement HL to point to the low byte of the value
05B3                             ;     ld h, (hl)              ; Load the high byte of the value into H
05B3                             ;     ld (vHeapPtr), hl       ; Update the heap pointer with the new top of the heap
05B3                             ;     ex de, hl               ; Exchange DE and HL to move the value to HL
05B3                             ;     pop de                  ; Restore DE
05B3                             ;     ret                     ; Return from the subroutine
05B3                             ; *******************************************************************************
05B3                             ; *********  END OF MAIN   ******************************************************
05B3                             ; *******************************************************************************
05B3                ROT_OPCODES:      
05B3   03 52 4C 43            .PSTR   "RLC"   
05B7   03 52 52 43            .PSTR   "RRC"   
05BB   02 52 4C               .PSTR   "RL"   
05BE   02 52 52               .PSTR   "RR"   
05C1   03 53 4C 41            .PSTR   "SLA"   
05C5   03 53 52 41            .PSTR   "SRA"   
05C9   03 53 4C 4C            .PSTR   "SLL"   
05CD   03 53 52 4C            .PSTR   "SRL"   
05D1   00                     .PSTR   ""   ; terminate list with a string of zero length
05D2                ALU_OPCODES:      
05D2   03 41 44 44            .PSTR   "ADD"   
05D6   03 41 44 43            .PSTR   "ADC"   
05DA   03 53 55 42            .PSTR   "SUB"   
05DE   03 53 42 43            .PSTR   "SBC"   
05E2   03 41 4E 44            .PSTR   "AND"   
05E6   03 58 4F 52            .PSTR   "XOR"   
05EA   02 4F 52               .PSTR   "OR"   
05ED   02 43 50               .PSTR   "CP"   
05F0   00                     .PSTR   ""   ; terminate list with a string of zero length
05F1                BLI_OPCODES:      
05F1   03 4C 44 49            .PSTR   "LDI"   
05F5   03 43 50 49            .PSTR   "CPI"   
05F9   03 49 4E 49            .PSTR   "INI"   
05FD   04 4F 55 54 49         .PSTR   "OUTI"   
0602   03 4C 44 44            .PSTR   "LDD"   
0606   03 43 50 44            .PSTR   "CPD"   
060A   03 49 4E 44            .PSTR   "IND"   
060E   04 4F 55 54 44         .PSTR   "OUTD"   
0613   04 4C 44 49 52         .PSTR   "LDIR"   
0618   04 43 50 49 52         .PSTR   "CPIR"   
061D   04 49 4E 49 52         .PSTR   "INIR"   
0622   04 4F 54 49 52         .PSTR   "OTIR"   
0627   04 4C 44 44 52         .PSTR   "LDDR"   
062C   04 43 50 44 52         .PSTR   "CPDR"   
0631   04 49 4E 44 52         .PSTR   "INDR"   
0636   04 4F 54 44 52         .PSTR   "OTDR"   
063B   00                     .PSTR   ""   ; terminate list with a string of zero length
063C                GEN1_OPCODES:      
063C   03 43 43 46            .PSTR   "CCF"   
0640   03 43 50 4C            .PSTR   "CPL"   
0644   03 44 41 41            .PSTR   "DAA"   
0648   02 44 49               .PSTR   "DI"   
064B   02 45 49               .PSTR   "EI"   
064E   04 48 41 4C 54         .PSTR   "HALT"   
0653   03 4E 4F 50            .PSTR   "NOP"   
0657   04 52 4C 43 41         .PSTR   "RLCA"   
065C   03 52 53 54            .PSTR   "RST"   
0660   03 53 43 46            .PSTR   "SCF"   
0664   00                     .PSTR   ""   ; terminate list with a string of zero length
0665                GEN2_OPCODES:      
0665   03 42 49 54            .PSTR   "BIT"   
0669   04 43 41 4C 4C         .PSTR   "CALL"   
066E   03 44 45 43            .PSTR   "DEC"   
0672   04 44 4A 4E 5A         .PSTR   "DJNZ"   
0677   02 45 58               .PSTR   "EX"   
067A   03 45 58 58            .PSTR   "EXX"   
067E   02 49 4D               .PSTR   "IM"   
0681   02 49 4E               .PSTR   "IN"   
0684   03 49 4E 43            .PSTR   "INC"   
0688   02 4A 50               .PSTR   "JP"   
068B   02 4A 52               .PSTR   "JR"   
068E   02 4C 44               .PSTR   "LD"   
0691   03 4E 45 47            .PSTR   "NEG"   
0695   03 4F 55 54            .PSTR   "OUT"   
0699   03 50 4F 50            .PSTR   "POP"   
069D   04 50 55 53 48         .PSTR   "PUSH"   
06A2   03 52 45 53            .PSTR   "RES"   
06A6   03 52 45 54            .PSTR   "RET"   
06AA   04 52 45 54 49         .PSTR   "RETI"   
06AF   04 52 45 54 4E         .PSTR   "RETN"   
06B4   03 52 4C 41            .PSTR   "RLA"   
06B8   03 52 4C 44            .PSTR   "RLD"   
06BC   03 52 52 41            .PSTR   "RRA"   
06C0   04 52 52 43 41         .PSTR   "RRCA"   
06C5   03 52 52 44            .PSTR   "RRD"   
06C9   03 53 45 54            .PSTR   "SET"   
06CD   00                     .PSTR   ""   ; terminate list with a string of zero length
06CE                REG8:        
06CE   01 42                  .PSTR   "B"   
06D0   01 43                  .PSTR   "C"   
06D2   01 44                  .PSTR   "D"   
06D4   01 45                  .PSTR   "E"   
06D6   01 48                  .PSTR   "H"   
06D8   01 4C                  .PSTR   "L"   
06DA   01 20                  .PSTR   " "   ; don't match, stand-in for (HL)
06DC   01 41                  .PSTR   "A"   
06DE   01 49                  .PSTR   "I"   
06E0   01 52                  .PSTR   "R"   
06E2   00                     .PSTR   ""   ; terminate list with a string of zero length
06E3                REG16:       
06E3   02 42 43               .PSTR   "BC"   
06E6   02 44 45               .PSTR   "DE"   
06E9   02 48 4C               .PSTR   "HL"   
06EC   02 53 50               .PSTR   "SP"   
06EF   02 49 58               .PSTR   "IX"   
06F2   02 49 59               .PSTR   "IY"   
06F5   03 41 46 27            .PSTR   "AF'"   
06F9   02 41 46               .PSTR   "AF"   ; NOTE: AF has the same code as SP in some instructions
06FC   00                     .PSTR   ""   ; terminate list with a string of zero length
06FD                FLAGS:       
06FD   02 4E 5A               .PSTR   "NZ"   
0700   01 5A                  .PSTR   "Z"   
0702   02 4E 43               .PSTR   "NC"   
0705   01 43                  .PSTR   "C"   
0707   02 50 4F               .PSTR   "PO"   
070A   02 50 45               .PSTR   "PE"   
070D   01 50                  .PSTR   "P"   
070F   01 4D                  .PSTR   "M"   
0711   00                     .PSTR   ""   ; terminate list with a string of zero length
0712                DIRECTIVES:      
0712   06 2E 41 4C 49 47 4E   .PSTR   ".ALIGN"   
0719   03 2E 44 42            .PSTR   ".DB"   
071D   04 2E 4F 52 47         .PSTR   ".ORG"   
0722   04 2E 53 45 54         .PSTR   ".SET"   
0727   00                     .PSTR   ""   ; terminate list with a string of zero length
0728                             ; *******************************************************************************
0728                             ; *********  END OF DATA   ******************************************************
0728                             ; *******************************************************************************
3000                          .ORG   RAMSTART   
3000                          ALIGN   $100   
3000                BUFFER:   DS   BUFFER_SIZE   ; line BUFFER, page aligned
3080                          DS   $100   
3180                STACK:       ; grows down
3180                VTEMP1:   DS   2   ; temp var 1
3182                VTEMP2:   DS   2   ; temp var 2
3184                VTOKEN:   DS   1   ; BUFFER for pushed back token
3185                VTOKENVAL:   DS   2   ; BUFFER for pushed back token value
3187                VBUFFERPOS:   DS   2   ; pointer to char position into input BUFFER
3189                VASMPTR:   DS   2   ; pointer to ASSEMBLY point
318B                VSTRPTR:   DS   2   ; pointer to string STACK
318D                VSYMPTR:   DS   2   ; pointer to symbol STACK
318F                VEXPRPTR:   DS   2   ; pointer to expression STACK
3191                VHEAPPTR:   DS   2   ; pointer to expression STACK
3193                VOPCODE:   DS   1   
3194                VOPERAND1:   DS   1   
3195                VOPERAND2:   DS   1   
3196                VOPEXPR:   DS   2   
3198                VOPDISP:   DS   2   
319A                RST08:    DS   2   
319C                RST10:    DS   2   
319E                RST18:    DS   2   
31A0                RST20:    DS   2   
31A2                RST28:    DS   2   
31A4                RST30:    DS   2   
31A6                BAUD:     DS   2   
31A8                INTVEC:   DS   2   
31AA                NMIVEC:   DS   2   
31AC                GETCVEC:   DS   2   
31AE                PUTCVEC:   DS   2   
31B0                STRINGS:   DS   STRS_SIZE   ; string heap - grows up
32B0                HEAP:     DS   HEAP_SIZE   ; expression heap - grows up
33B0                ASSEMBLY:      
4000                          .ORG   $4000   
4000                TESTSSTART:      
4000   31 80 31               LD   sp,STACK   
4003                             ; call describe
4003                             ; .cstr "It should do nothing"
4003                             ; call test
4003                             ; .db 0
4003                             ; call expect
4003                             ; .db 0
4003   CD 47 40               CALL   describe   
4006   49 74 20 73 68 6F 75 6C 64 20 61 73 73 65 6D 62 6C 65 20 6F 6E 65 20 69 6E 73 74 72 75 63 74 69 6F 6E 00 .CSTR   "It should assemble one instruction"   
4029   CD 50 40               CALL   test   
402C   68 61 6C 74            DB   "halt"   
4030   00                     DB   0   
4031   CD 84 40               CALL   expectCode   
4034   65 FF FF               DB   HALT_,-1,-1   
4037                             ; call expect
4037                             ; .db 01, $76
4037   CD 86 05               CALL   print   
403A   44 6F 6E 65 21 00      .CSTR   "Done!"   
4040   76                     HALT      
4041                             ; *****************************************************************************
4041                             ; Test variables
4041                             ; *****************************************************************************
4041                TBDESC:      
4041   00 00                  DW   0   ; Address of the description
4043                TBTEXT:      
4043   00 00                  DW   0   ; Address of the test text
4045                TBPTR:       
4045   00 00                  DW   0   ; Pointer to the current position in the test text
4047                             ; *****************************************************************************
4047                             ; Routine: describe
4047                             ; 
4047                             ; Purpose:
4047                             ;    Stores the address of a description string in tbDesc and then skips the string.
4047                             ; 
4047                             ; Inputs:
4047                             ;    HL - Address of the description string
4047                             ; 
4047                             ; Outputs:
4047                             ;    None
4047                             ; 
4047                             ; Registers Destroyed:
4047                             ;    HL
4047                             ; *****************************************************************************
4047                DESCRIBE:      
4047   E1                     POP   hl   ; Retrieve the return address (address of the description string)
4048   22 41 40               LD   (tbDesc),hl   ; Store the address in tbDesc
404B   CD 3A 41               CALL   skipZStr   ; Skip the description string
404E   23                     INC   hl   ; Move to the next byte after the null terminator
404F   E9                     JP   (hl)   ; Jump to the address specified by the next byte
4050                             ; *****************************************************************************
4050                             ; Routine: test
4050                             ; 
4050                             ; Purpose:
4050                             ;    Stores the address of a test text in tbText and tbPtr, and then skips the string.
4050                             ; 
4050                             ; Inputs:
4050                             ;    HL - Address of the test text
4050                             ; 
4050                             ; Outputs:
4050                             ;    None
4050                             ; 
4050                             ; Registers Destroyed:
4050                             ;    HL
4050                             ; *****************************************************************************
4050                TEST:        
4050   E1                     POP   hl   ; Retrieve the return address (address of the test text)
4051   22 43 40               LD   (tbText),hl   ; Store the address in tbText
4054   22 45 40               LD   (tbPtr),hl   ; Initialize tbPtr with the address of the test text
4057   CD 3A 41               CALL   skipZStr   ; Skip the test text string
405A   23                     INC   hl   ; Move to the next byte after the null terminator
405B   E5                     PUSH   hl   ; push new return address
405C   CD 98 01               CALL   init   ; Initialize the environment
405F   21 10 41               LD   hl,testGetCharImpl   ; Load the address of testGetCharImpl
4062   22 AC 31               LD   (GETCVEC),hl   ; Set the GETCVEC to point to testGetCharImpl
4065   C3 FD 01               JP   statementList   
4068                             ; *****************************************************************************
4068                             ; Routine: expect
4068                             ; 
4068                             ; Purpose:
4068                             ;    Initializes the environment, sets up the testGetCharImpl, executes the statementList,
4068                             ;    and compares the result with the expected output.
4068                             ; 
4068                             ; Inputs:
4068                             ;    None
4068                             ; 
4068                             ; Outputs:
4068                             ;    None
4068                             ; 
4068                             ; Registers Destroyed:
4068                             ;    HL, DE
4068                             ; *****************************************************************************
4068                EXPECT:      
4068   E1                     POP   hl   ; Retrieve the return address
4069   11 B0 33               LD   de,ASSEMBLY   ; Load the expected output address into DE
406C   CD 52 04               CALL   compareStr   ; Compare the result with the expected output
406F   20 01                  JR   nz,expect1   ; If comparison fails, jump to expect1
4071   E9                     JP   (hl)   ; If comparison succeeds, jump to the return address
4072                EXPECT1:      
4072   CD 86 05               CALL   print   ; Print the failure message
4075   46 61 69 6C 65 64 21 00 .CSTR   "Failed!"   
407D   2A 43 40               LD   hl,(tbText)   ; Load the address of the test text
4080   CD 9A 05               CALL   printZStr   ; Print the test text
4083   76                     HALT      ; Halt the program
4084                EXPECTCODE:      
4084   E1                     POP   hl   
4085   11 93 31               LD   de,vOpcode   
4088   1A                     LD   a,(de)   
4089   BE                     CP   (hl)   
408A   20 12                  JR   nz,expectCode1   
408C   23                     INC   hl   
408D   11 94 31               LD   de,vOperand1   
4090   1A                     LD   a,(de)   
4091   BE                     CP   (hl)   
4092   20 27                  JR   nz,expectCode2   
4094   23                     INC   hl   
4095   11 95 31               LD   de,vOperand2   
4098   1A                     LD   a,(de)   
4099   BE                     CP   (hl)   
409A   20 3F                  JR   nz,expectCode3   
409C   23                     INC   hl   
409D   E9                     JP   (hl)   
409E                EXPECTCODE1:      
409E   CD 86 05               CALL   print   
40A1   57 72 6F 6E 67 20 6F 70 63 6F 64 65 2C 20 65 78 70 65 63 74 65 64 20 00 .CSTR   "Wrong opcode, expected "   
40B9   18 40                  JR   expectCode4   
40BB                EXPECTCODE2:      
40BB   CD 86 05               CALL   print   
40BE   57 72 6F 6E 67 20 6F 70 65 72 61 6E 64 20 31 2C 20 65 78 70 65 63 74 65 64 20 00 .CSTR   "Wrong operand 1, expected "   
40D9   18 20                  JR   expectCode4   
40DB                EXPECTCODE3:      
40DB   CD 86 05               CALL   print   
40DE   57 72 6F 6E 67 20 6F 70 65 72 61 6E 64 20 32 2C 20 65 78 70 65 63 74 65 64 20 00 .CSTR   "Wrong operand 2, expected "   
40F9   18 00                  JR   expectCode4   
40FB                EXPECTCODE4:      
40FB   CD 1B 41               CALL   printHex   
40FE   EB                     EX   de,hl   
40FF   CD 86 05               CALL   print   
4102   72 65 63 65 69 76 65 64 20 00 .CSTR   "received "   
410C   CD 1B 41               CALL   printHex   
410F   76                     HALT      
4110                             ; *****************************************************************************
4110                             ; Routine: testGetCharImpl
4110                             ; 
4110                             ; Purpose:
4110                             ;    Retrieves the next character from the test text.
4110                             ; 
4110                             ; Inputs:
4110                             ;    tbPtr - Pointer to the current position in the test text
4110                             ; 
4110                             ; Outputs:
4110                             ;    A - The next character from the test text
4110                             ; 
4110                             ; Registers Destroyed:
4110                             ;    A, HL
4110                             ; *****************************************************************************
4110                TESTGETCHARIMPL:      
4110   E5                     PUSH   hl   ; Save HL register
4111   2A 45 40               LD   hl,(tbPtr)   ; Load the current pointer from tbPtr
4114   7E                     LD   a,(hl)   ; Load the next character from the test text
4115   23                     INC   hl   ; Move to the next character
4116   22 45 40               LD   (tbPtr),hl   ; Update tbPtr with the new pointer
4119   E1                     POP   hl   ; Restore HL register
411A   C9                     RET      ; Return with the character in A
411B                             ; *****************************************************************************
411B                             ; Routine: printHex
411B                             ; 
411B                             ; Purpose:
411B                             ;    Displays the 16-bit value in the HL register as a hexadecimal number.
411B                             ; 
411B                             ; Inputs:
411B                             ;    HL - The 16-bit value to be displayed.
411B                             ; 
411B                             ; Outputs:
411B                             ;    None
411B                             ; 
411B                             ; Registers Destroyed:
411B                             ;    A, C
411B                             ; *****************************************************************************
411B                PRINTHEX:      
411B   C5                     PUSH   bc   ; Preserve the BC register pair
411C   7C                     LD   a,h   ; Load the high byte of HL into A
411D   CD 26 41               CALL   printHex2   ; Print the high byte as hex
4120   7D                     LD   a,l   ; Load the low byte of HL into A
4121   CD 26 41               CALL   printHex2   ; Print the low byte as hex
4124   C1                     POP   bc   ; Restore the BC register pair
4125   C9                     RET      ; Return from the routine
4126                PRINTHEX2:      
4126   4F                     LD   c,a   ; Copy the value in A to C
4127   1F                     RRA      ; Shift the high nibble to the low nibble
4128   1F                     RRA      
4129   1F                     RRA      
412A   1F                     RRA      
412B   CD 2F 41               CALL   printHex3   ; Print the high nibble as hex
412E   79                     LD   a,c   ; Restore the original value to A
412F                PRINTHEX3:      
412F   E6 0F                  AND   0x0F   ; Mask out the upper nibble
4131   C6 90                  ADD   a,0x90   ; Add 0x90 to adjust for the ASCII range
4133   27                     DAA      ; Decimal adjust A to get the correct ASCII value
4134   CE 40                  ADC   a,0x40   ; Add 0x40 to get the ASCII character for 0-9/A-F
4136   27                     DAA      ; Decimal adjust A to get the correct ASCII value
4137   C3 87 00               JP   putchar   ; Jump to the putchar routine to display the character
413A                             ; 
413A                             ; *****************************************************************************
413A                             ; Routine: skipZStr
413A                             ; 
413A                             ; Purpose:
413A                             ;    Skips over a null-terminated string in memory, advancing the HL register
413A                             ;    to the character following the null terminator.
413A                             ; 
413A                             ; Inputs:
413A                             ;    HL - Points to the start of the string to skip.
413A                             ; 
413A                             ; Outputs:
413A                             ;    HL - Points to the character immediately after the null terminator.
413A                             ; 
413A                             ; Registers Destroyed:
413A                             ;    A
413A                             ; *****************************************************************************
413A                SKIPZSTR:      
413A   18 01                  JR   skipZStr2   ; Jump to the character loading step
413C                SKIPZSTR1:      
413C   23                     INC   hl   ; Move to the next character
413D                SKIPZSTR2:      
413D   7E                     LD   a,(hl)   ; Load the current character
413E   B7                     OR   a   ; Check if the character is null
413F   20 FB                  JR   nz,skipZStr1   ; If not null, continue to the next character
4141   C9                     RET      ; Return when a null character is found
4142                             ; call test
4142                             ; ; .db "label1: LD A, 42;comment\r\n"
4142                             ; ; .db "halt"
4142                             ; .db 0


ROMSTART:           0000 DEFINED AT LINE 1 IN constants.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 116 IN IOSerial.asm
                    > USED AT LINE 122 IN IOSerial.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 134 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 146 IN IOSerial.asm
                    > USED AT LINE 152 IN IOSerial.asm
                    > USED AT LINE 158 IN IOSerial.asm
                    > USED AT LINE 200 IN IOSerial.asm
                    > USED AT LINE 17 IN MAIN.asm
RAMSTART:           3000 DEFINED AT LINE 2 IN constants.asm
                    > USED AT LINE 1 IN ram.asm
ROMSIZE:            3000 DEFINED AT LINE 3 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 4 IN constants.asm
EOF:                00-1 DEFINED AT LINE 6 IN constants.asm
                    > USED AT LINE 406 IN MAIN.asm
                    > USED AT LINE 1105 IN MAIN.asm
                    > USED AT LINE 1113 IN MAIN.asm
                    > USED AT LINE 1150 IN MAIN.asm
NULL:               0000 DEFINED AT LINE 7 IN constants.asm
                    > USED AT LINE 325 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 8 IN constants.asm
                    > USED AT LINE 1109 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 9 IN constants.asm
ESC:                001B DEFINED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 1126 IN MAIN.asm
NO_MATCH:           00-1 DEFINED AT LINE 11 IN constants.asm
BUFFER_SIZE:        0080 DEFINED AT LINE 13 IN constants.asm
                    > USED AT LINE 1086 IN MAIN.asm
                    > USED AT LINE 1101 IN MAIN.asm
                    > USED AT LINE 1119 IN MAIN.asm
                    > USED AT LINE 5 IN ram.asm
STRS_SIZE:          0100 DEFINED AT LINE 14 IN constants.asm
                    > USED AT LINE 40 IN ram.asm
HEAP_SIZE:          0100 DEFINED AT LINE 15 IN constants.asm
                    > USED AT LINE 41 IN ram.asm
TOKENS:             0000 DEFINED AT LINE 17 IN constants.asm
COLON_:             000: DEFINED AT LINE 19 IN constants.asm
COMMA_:             000, DEFINED AT LINE 20 IN constants.asm
                    > USED AT LINE 182 IN MAIN.asm
DIRECT_:            000D DEFINED AT LINE 21 IN constants.asm
                    > USED AT LINE 171 IN MAIN.asm
                    > USED AT LINE 470 IN MAIN.asm
DOLLAR_:            000$ DEFINED AT LINE 22 IN constants.asm
                    > USED AT LINE 490 IN MAIN.asm
EOF_:               000E DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 128 IN MAIN.asm
                    > USED AT LINE 409 IN MAIN.asm
IDENT_:             000I DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 474 IN MAIN.asm
LABEL_:             000L DEFINED AT LINE 25 IN constants.asm
                    > USED AT LINE 162 IN MAIN.asm
                    > USED AT LINE 443 IN MAIN.asm
LPAREN_:            000( DEFINED AT LINE 26 IN constants.asm
                    > USED AT LINE 222 IN MAIN.asm
NEWLN_:             000
 DEFINED AT LINE 27 IN constants.asm
                    > USED AT LINE 419 IN MAIN.asm
NUM_:               0009 DEFINED AT LINE 28 IN constants.asm
                    > USED AT LINE 485 IN MAIN.asm
                    > USED AT LINE 503 IN MAIN.asm
OPCODE_:            000C DEFINED AT LINE 29 IN constants.asm
                    > USED AT LINE 169 IN MAIN.asm
                    > USED AT LINE 453 IN MAIN.asm
OPELEM_:            000M DEFINED AT LINE 30 IN constants.asm
                    > USED AT LINE 219 IN MAIN.asm
                    > USED AT LINE 232 IN MAIN.asm
                    > USED AT LINE 461 IN MAIN.asm
RPAREN_:            000) DEFINED AT LINE 31 IN constants.asm
                    > USED AT LINE 256 IN MAIN.asm
UNKNOWN_:           000U DEFINED AT LINE 32 IN constants.asm
                    > USED AT LINE 513 IN MAIN.asm
ALU_:               0000 DEFINED AT LINE 34 IN constants.asm
                    > USED AT LINE 42 IN constants.asm
                    > USED AT LINE 43 IN constants.asm
                    > USED AT LINE 44 IN constants.asm
                    > USED AT LINE 45 IN constants.asm
                    > USED AT LINE 46 IN constants.asm
                    > USED AT LINE 47 IN constants.asm
                    > USED AT LINE 48 IN constants.asm
                    > USED AT LINE 49 IN constants.asm
ROT_:               0020 DEFINED AT LINE 35 IN constants.asm
                    > USED AT LINE 53 IN constants.asm
                    > USED AT LINE 54 IN constants.asm
                    > USED AT LINE 55 IN constants.asm
                    > USED AT LINE 56 IN constants.asm
                    > USED AT LINE 57 IN constants.asm
                    > USED AT LINE 58 IN constants.asm
                    > USED AT LINE 59 IN constants.asm
                    > USED AT LINE 60 IN constants.asm
BLI_:               0040 DEFINED AT LINE 36 IN constants.asm
                    > USED AT LINE 64 IN constants.asm
                    > USED AT LINE 65 IN constants.asm
                    > USED AT LINE 66 IN constants.asm
                    > USED AT LINE 67 IN constants.asm
                    > USED AT LINE 68 IN constants.asm
                    > USED AT LINE 69 IN constants.asm
                    > USED AT LINE 70 IN constants.asm
                    > USED AT LINE 71 IN constants.asm
                    > USED AT LINE 72 IN constants.asm
                    > USED AT LINE 73 IN constants.asm
                    > USED AT LINE 74 IN constants.asm
                    > USED AT LINE 75 IN constants.asm
                    > USED AT LINE 76 IN constants.asm
                    > USED AT LINE 77 IN constants.asm
                    > USED AT LINE 78 IN constants.asm
                    > USED AT LINE 79 IN constants.asm
GEN1_:              0060 DEFINED AT LINE 37 IN constants.asm
                    > USED AT LINE 83 IN constants.asm
                    > USED AT LINE 84 IN constants.asm
                    > USED AT LINE 85 IN constants.asm
                    > USED AT LINE 86 IN constants.asm
                    > USED AT LINE 87 IN constants.asm
                    > USED AT LINE 88 IN constants.asm
                    > USED AT LINE 89 IN constants.asm
                    > USED AT LINE 90 IN constants.asm
                    > USED AT LINE 92 IN constants.asm
GEN2_:              0080 DEFINED AT LINE 38 IN constants.asm
                    > USED AT LINE 91 IN constants.asm
                    > USED AT LINE 96 IN constants.asm
                    > USED AT LINE 97 IN constants.asm
                    > USED AT LINE 98 IN constants.asm
                    > USED AT LINE 99 IN constants.asm
                    > USED AT LINE 100 IN constants.asm
                    > USED AT LINE 101 IN constants.asm
                    > USED AT LINE 102 IN constants.asm
                    > USED AT LINE 103 IN constants.asm
                    > USED AT LINE 104 IN constants.asm
                    > USED AT LINE 105 IN constants.asm
                    > USED AT LINE 106 IN constants.asm
                    > USED AT LINE 107 IN constants.asm
                    > USED AT LINE 108 IN constants.asm
                    > USED AT LINE 109 IN constants.asm
                    > USED AT LINE 110 IN constants.asm
                    > USED AT LINE 111 IN constants.asm
                    > USED AT LINE 112 IN constants.asm
                    > USED AT LINE 113 IN constants.asm
                    > USED AT LINE 114 IN constants.asm
                    > USED AT LINE 115 IN constants.asm
                    > USED AT LINE 116 IN constants.asm
                    > USED AT LINE 117 IN constants.asm
                    > USED AT LINE 118 IN constants.asm
                    > USED AT LINE 119 IN constants.asm
                    > USED AT LINE 120 IN constants.asm
                    > USED AT LINE 121 IN constants.asm
ALU_IDX:            0000 DEFINED AT LINE 40 IN constants.asm
ADD_:               0000 DEFINED AT LINE 42 IN constants.asm
ADC_:               0001 DEFINED AT LINE 43 IN constants.asm
SUB_:               0002 DEFINED AT LINE 44 IN constants.asm
SBC_:               0003 DEFINED AT LINE 45 IN constants.asm
AND_:               0004 DEFINED AT LINE 46 IN constants.asm
XOR_:               0005 DEFINED AT LINE 47 IN constants.asm
OR_:                0006 DEFINED AT LINE 48 IN constants.asm
CP_:                0007 DEFINED AT LINE 49 IN constants.asm
ROT_IDX:            0000 DEFINED AT LINE 51 IN constants.asm
RLC_:               0020 DEFINED AT LINE 53 IN constants.asm
RRC_:               0021 DEFINED AT LINE 54 IN constants.asm
RL_:                0022 DEFINED AT LINE 55 IN constants.asm
RR_:                0023 DEFINED AT LINE 56 IN constants.asm
SLA_:               0024 DEFINED AT LINE 57 IN constants.asm
SRA_:               0025 DEFINED AT LINE 58 IN constants.asm
SLL_:               0026 DEFINED AT LINE 59 IN constants.asm
SRL_:               0027 DEFINED AT LINE 60 IN constants.asm
BLI_IDX:            0000 DEFINED AT LINE 62 IN constants.asm
LDI_:               0040 DEFINED AT LINE 64 IN constants.asm
CPI_:               0041 DEFINED AT LINE 65 IN constants.asm
INI_:               0042 DEFINED AT LINE 66 IN constants.asm
OUTI_:              0043 DEFINED AT LINE 67 IN constants.asm
LDD_:               0044 DEFINED AT LINE 68 IN constants.asm
CPD_:               0045 DEFINED AT LINE 69 IN constants.asm
IND_:               0046 DEFINED AT LINE 70 IN constants.asm
OUTD_:              0047 DEFINED AT LINE 71 IN constants.asm
LDIR_:              0048 DEFINED AT LINE 72 IN constants.asm
CPIR_:              0049 DEFINED AT LINE 73 IN constants.asm
INIR_:              004A DEFINED AT LINE 74 IN constants.asm
OTIR_:              004B DEFINED AT LINE 75 IN constants.asm
LDDR_:              004C DEFINED AT LINE 76 IN constants.asm
CPDR_:              004D DEFINED AT LINE 77 IN constants.asm
INDR_:              004E DEFINED AT LINE 78 IN constants.asm
OTDR_:              004F DEFINED AT LINE 79 IN constants.asm
GEN1_IDX:           0000 DEFINED AT LINE 81 IN constants.asm
CCF_:               0060 DEFINED AT LINE 83 IN constants.asm
CPL_:               0061 DEFINED AT LINE 84 IN constants.asm
DAA_:               0062 DEFINED AT LINE 85 IN constants.asm
DI_:                0063 DEFINED AT LINE 86 IN constants.asm
EI_:                0064 DEFINED AT LINE 87 IN constants.asm
HALT_:              0065 DEFINED AT LINE 88 IN constants.asm
                    > USED AT LINE 34
NOP_:               0066 DEFINED AT LINE 89 IN constants.asm
RLCA_:              0067 DEFINED AT LINE 90 IN constants.asm
RST_:               0088 DEFINED AT LINE 91 IN constants.asm
SCF_:               0069 DEFINED AT LINE 92 IN constants.asm
GEN2_IDX:           0000 DEFINED AT LINE 94 IN constants.asm
BIT_:               0080 DEFINED AT LINE 96 IN constants.asm
CALL_:              0081 DEFINED AT LINE 97 IN constants.asm
DEC_:               0082 DEFINED AT LINE 98 IN constants.asm
DJNZ_:              0083 DEFINED AT LINE 99 IN constants.asm
EX_:                0084 DEFINED AT LINE 100 IN constants.asm
EXX_:               0085 DEFINED AT LINE 101 IN constants.asm
IM_:                0086 DEFINED AT LINE 102 IN constants.asm
IN_:                0087 DEFINED AT LINE 103 IN constants.asm
INC_:               0088 DEFINED AT LINE 104 IN constants.asm
JP_:                0089 DEFINED AT LINE 105 IN constants.asm
JR_:                008A DEFINED AT LINE 106 IN constants.asm
LD_:                008B DEFINED AT LINE 107 IN constants.asm
NEG_:               008C DEFINED AT LINE 108 IN constants.asm
OUT_:               008D DEFINED AT LINE 109 IN constants.asm
POP_:               008E DEFINED AT LINE 110 IN constants.asm
PUSH_:              008F DEFINED AT LINE 111 IN constants.asm
RES_:               0090 DEFINED AT LINE 112 IN constants.asm
RET_:               0091 DEFINED AT LINE 113 IN constants.asm
RETI_:              0092 DEFINED AT LINE 114 IN constants.asm
RETN_:              0093 DEFINED AT LINE 115 IN constants.asm
RLA_:               0094 DEFINED AT LINE 116 IN constants.asm
RLD_:               0095 DEFINED AT LINE 117 IN constants.asm
RRA_:               0096 DEFINED AT LINE 118 IN constants.asm
RRCA_:              0097 DEFINED AT LINE 119 IN constants.asm
RRD_:               0098 DEFINED AT LINE 120 IN constants.asm
SET_:               0003 DEFINED AT LINE 170 IN constants.asm
REG_:               0000 DEFINED AT LINE 123 IN constants.asm
RP_:                0008 DEFINED AT LINE 124 IN constants.asm
                    > USED AT LINE 145 IN constants.asm
                    > USED AT LINE 146 IN constants.asm
                    > USED AT LINE 147 IN constants.asm
                    > USED AT LINE 148 IN constants.asm
                    > USED AT LINE 149 IN constants.asm
                    > USED AT LINE 150 IN constants.asm
                    > USED AT LINE 151 IN constants.asm
                    > USED AT LINE 152 IN constants.asm
FLAG_:              0010 DEFINED AT LINE 125 IN constants.asm
                    > USED AT LINE 156 IN constants.asm
                    > USED AT LINE 157 IN constants.asm
                    > USED AT LINE 158 IN constants.asm
                    > USED AT LINE 159 IN constants.asm
                    > USED AT LINE 160 IN constants.asm
                    > USED AT LINE 161 IN constants.asm
                    > USED AT LINE 162 IN constants.asm
                    > USED AT LINE 163 IN constants.asm
IMMED_:             0020 DEFINED AT LINE 126 IN constants.asm
                    > USED AT LINE 227 IN MAIN.asm
                    > USED AT LINE 251 IN MAIN.asm
MEM_:               0040 DEFINED AT LINE 127 IN constants.asm
                    > USED AT LINE 251 IN MAIN.asm
IDX_:               0080 DEFINED AT LINE 128 IN constants.asm
REG8_IDX:           0000 DEFINED AT LINE 130 IN constants.asm
B_:                 0000 DEFINED AT LINE 132 IN constants.asm
C_:                 0013 DEFINED AT LINE 159 IN constants.asm
D_:                 0002 DEFINED AT LINE 134 IN constants.asm
E_:                 0003 DEFINED AT LINE 135 IN constants.asm
H_:                 0004 DEFINED AT LINE 136 IN constants.asm
L_:                 0005 DEFINED AT LINE 137 IN constants.asm
MHL_:               0006 DEFINED AT LINE 138 IN constants.asm
A_:                 0007 DEFINED AT LINE 139 IN constants.asm
I_:                 0008 DEFINED AT LINE 140 IN constants.asm
R_:                 0009 DEFINED AT LINE 141 IN constants.asm
REG16_IDX:          0000 DEFINED AT LINE 143 IN constants.asm
BC_:                0008 DEFINED AT LINE 145 IN constants.asm
DE_:                0009 DEFINED AT LINE 146 IN constants.asm
HL_:                000A DEFINED AT LINE 147 IN constants.asm
SP_:                000B DEFINED AT LINE 148 IN constants.asm
IX_:                000D DEFINED AT LINE 149 IN constants.asm
                    > USED AT LINE 848 IN MAIN.asm
IY_:                000E DEFINED AT LINE 150 IN constants.asm
                    > USED AT LINE 850 IN MAIN.asm
AFP_:               000C DEFINED AT LINE 151 IN constants.asm
AF_:                000F DEFINED AT LINE 152 IN constants.asm
FLAG_IDX:           0000 DEFINED AT LINE 154 IN constants.asm
NZ_:                0010 DEFINED AT LINE 156 IN constants.asm
Z_:                 0011 DEFINED AT LINE 157 IN constants.asm
NC_:                0012 DEFINED AT LINE 158 IN constants.asm
PO_:                0014 DEFINED AT LINE 160 IN constants.asm
PE_:                0015 DEFINED AT LINE 161 IN constants.asm
P_:                 0016 DEFINED AT LINE 162 IN constants.asm
M_:                 0017 DEFINED AT LINE 163 IN constants.asm
DIRECTIVE_IDX:      0000 DEFINED AT LINE 165 IN constants.asm
ALIGN_:             0000 DEFINED AT LINE 167 IN constants.asm
DB_:                0001 DEFINED AT LINE 168 IN constants.asm
ORG_:               0002 DEFINED AT LINE 169 IN constants.asm
TEC_1:              0001 DEFINED AT LINE 174 IN constants.asm
RC2014:             0000 DEFINED AT LINE 175 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 177 IN constants.asm
LOADER:             0000 DEFINED AT LINE 179 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 180 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 33 IN IOSerial.asm
                    > USED AT LINE 478 IN IOSerial.asm
                    > USED AT LINE 500 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 34 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 322 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 36 IN IOSerial.asm
                    > USED AT LINE 326 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 477 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 46 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 50 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 51 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 52 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 53 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 54 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 55 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 56 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 57 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 61 IN IOSerial.asm
                    > USED AT LINE 499 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 62 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 63 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 64 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 68 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 72 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 73 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 74 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 75 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 76 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 77 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 78 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 79 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 87 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 88 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 89 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 90 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 91 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 92 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 93 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 94 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 108 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 109 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 113 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 163 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 483 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 187 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 193 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 196 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 471 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 305 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 308 IN IOSerial.asm
                    > USED AT LINE 312 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 320 IN IOSerial.asm
                    > USED AT LINE 469 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 321 IN IOSerial.asm
                    > USED AT LINE 325 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 445 IN IOSerial.asm
                    > USED AT LINE 1104 IN MAIN.asm
PUTCHAR:            0087 DEFINED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 1130 IN MAIN.asm
                    > USED AT LINE 1296 IN MAIN.asm
                    > USED AT LINE 1321 IN MAIN.asm
                    > USED AT LINE 202 IN test.lib.asm
RESET:              008D DEFINED AT LINE 457 IN IOSerial.asm
                    > USED AT LINE 114 IN IOSerial.asm
START:              0180 DEFINED AT LINE 37 IN MAIN.asm
INIT:               0198 DEFINED AT LINE 60 IN MAIN.asm
                    > USED AT LINE 39 IN MAIN.asm
                    > USED AT LINE 58 IN test.lib.asm
PARSE:              01C3 DEFINED AT LINE 95 IN MAIN.asm
                    > USED AT LINE 42 IN MAIN.asm
PARSEERROR:         01EA DEFINED AT LINE 101 IN MAIN.asm
                    > USED AT LINE 126 IN MAIN.asm
                    > USED AT LINE 257 IN MAIN.asm
STATEMENTLIST:      01FD DEFINED AT LINE 122 IN MAIN.asm
                    > USED AT LINE 96 IN MAIN.asm
                    > USED AT LINE 130 IN MAIN.asm
                    > USED AT LINE 61 IN test.lib.asm
STATEMENT:          020F DEFINED AT LINE 149 IN MAIN.asm
                    > USED AT LINE 124 IN MAIN.asm
STATEMENT1:         0234 DEFINED AT LINE 168 IN MAIN.asm
                    > USED AT LINE 163 IN MAIN.asm
INSTRUCTION:        023D DEFINED AT LINE 175 IN MAIN.asm
                    > USED AT LINE 170 IN MAIN.asm
DIRECTIVE:          025A DEFINED AT LINE 189 IN MAIN.asm
                    > USED AT LINE 172 IN MAIN.asm
OPERAND:            025B DEFINED AT LINE 218 IN MAIN.asm
                    > USED AT LINE 179 IN MAIN.asm
                    > USED AT LINE 185 IN MAIN.asm
OPERAND1:           026B DEFINED AT LINE 230 IN MAIN.asm
                    > USED AT LINE 223 IN MAIN.asm
OPERAND3:           0282 DEFINED AT LINE 244 IN MAIN.asm
OPERAND2:           0286 DEFINED AT LINE 248 IN MAIN.asm
                    > USED AT LINE 233 IN MAIN.asm
OPERAND4:           0290 DEFINED AT LINE 254 IN MAIN.asm
                    > USED AT LINE 237 IN MAIN.asm
                    > USED AT LINE 246 IN MAIN.asm
                    > USED AT LINE 252 IN MAIN.asm
EXPRESSION:         0299 DEFINED AT LINE 280 IN MAIN.asm
                    > USED AT LINE 225 IN MAIN.asm
                    > USED AT LINE 239 IN MAIN.asm
                    > USED AT LINE 249 IN MAIN.asm
EXPRESSION1:        02B4 DEFINED AT LINE 292 IN MAIN.asm
                    > USED AT LINE 304 IN MAIN.asm
                    > USED AT LINE 314 IN MAIN.asm
                    > USED AT LINE 322 IN MAIN.asm
EXPRESSION2:        02CC DEFINED AT LINE 306 IN MAIN.asm
                    > USED AT LINE 301 IN MAIN.asm
EXPRESSION3:        02DA DEFINED AT LINE 316 IN MAIN.asm
                    > USED AT LINE 309 IN MAIN.asm
                    > USED AT LINE 311 IN MAIN.asm
EXPRESSION4:        02E6 DEFINED AT LINE 324 IN MAIN.asm
                    > USED AT LINE 318 IN MAIN.asm
                    > USED AT LINE 320 IN MAIN.asm
ADDSYMBOL:          02EF DEFINED AT LINE 347 IN MAIN.asm
                    > USED AT LINE 165 IN MAIN.asm
NEXTTOKEN:          0308 DEFINED AT LINE 390 IN MAIN.asm
                    > USED AT LINE 123 IN MAIN.asm
                    > USED AT LINE 127 IN MAIN.asm
                    > USED AT LINE 166 IN MAIN.asm
                    > USED AT LINE 178 IN MAIN.asm
                    > USED AT LINE 181 IN MAIN.asm
                    > USED AT LINE 184 IN MAIN.asm
                    > USED AT LINE 231 IN MAIN.asm
                    > USED AT LINE 255 IN MAIN.asm
                    > USED AT LINE 299 IN MAIN.asm
                    > USED AT LINE 303 IN MAIN.asm
                    > USED AT LINE 313 IN MAIN.asm
NEXTTOKEN0:         0319 DEFINED AT LINE 399 IN MAIN.asm
                    > USED AT LINE 392 IN MAIN.asm
                    > USED AT LINE 431 IN MAIN.asm
NEXTTOKEN1:         031C DEFINED AT LINE 402 IN MAIN.asm
                    > USED AT LINE 405 IN MAIN.asm
NEXTTOKEN1A:        0327 DEFINED AT LINE 408 IN MAIN.asm
NEXTTOKEN2:         032A DEFINED AT LINE 412 IN MAIN.asm
                    > USED AT LINE 407 IN MAIN.asm
NEXTTOKEN3:         0339 DEFINED AT LINE 422 IN MAIN.asm
                    > USED AT LINE 414 IN MAIN.asm
                    > USED AT LINE 416 IN MAIN.asm
                    > USED AT LINE 418 IN MAIN.asm
NEXTTOKEN4:         033E DEFINED AT LINE 426 IN MAIN.asm
                    > USED AT LINE 429 IN MAIN.asm
NEXTTOKEN5:         034A DEFINED AT LINE 433 IN MAIN.asm
                    > USED AT LINE 424 IN MAIN.asm
NEXTTOKEN6:         0353 DEFINED AT LINE 439 IN MAIN.asm
                    > USED AT LINE 435 IN MAIN.asm
NEXTTOKEN7:         035D DEFINED AT LINE 446 IN MAIN.asm
                    > USED AT LINE 442 IN MAIN.asm
NEXTTOKEN8:         036E DEFINED AT LINE 456 IN MAIN.asm
                    > USED AT LINE 450 IN MAIN.asm
NEXTTOKEN9:         0379 DEFINED AT LINE 464 IN MAIN.asm
                    > USED AT LINE 458 IN MAIN.asm
NEXTTOKEN10:        0387 DEFINED AT LINE 473 IN MAIN.asm
                    > USED AT LINE 467 IN MAIN.asm
NEXTTOKEN11:        038A DEFINED AT LINE 477 IN MAIN.asm
                    > USED AT LINE 437 IN MAIN.asm
NEXTTOKEN11A:       039F DEFINED AT LINE 488 IN MAIN.asm
                    > USED AT LINE 483 IN MAIN.asm
NEXTTOKEN12:        03A5 DEFINED AT LINE 493 IN MAIN.asm
                    > USED AT LINE 480 IN MAIN.asm
NEXTTOKEN13:        03AE DEFINED AT LINE 499 IN MAIN.asm
                    > USED AT LINE 495 IN MAIN.asm
NEXTTOKEN14:        03B1 DEFINED AT LINE 502 IN MAIN.asm
NEXTTOKEN15:        03B4 DEFINED AT LINE 506 IN MAIN.asm
                    > USED AT LINE 497 IN MAIN.asm
PUSHBACKTOKEN:      03C0 DEFINED AT LINE 534 IN MAIN.asm
                    > USED AT LINE 327 IN MAIN.asm
IDENT:              03C9 DEFINED AT LINE 563 IN MAIN.asm
                    > USED AT LINE 440 IN MAIN.asm
IDENT1:             03CE DEFINED AT LINE 567 IN MAIN.asm
                    > USED AT LINE 574 IN MAIN.asm
                    > USED AT LINE 576 IN MAIN.asm
IDENT3:             03DE DEFINED AT LINE 577 IN MAIN.asm
SEARCHSTR:          03E9 DEFINED AT LINE 670 IN MAIN.asm
                    > USED AT LINE 466 IN MAIN.asm
                    > USED AT LINE 679 IN MAIN.asm
                    > USED AT LINE 726 IN MAIN.asm
                    > USED AT LINE 730 IN MAIN.asm
                    > USED AT LINE 735 IN MAIN.asm
                    > USED AT LINE 740 IN MAIN.asm
                    > USED AT LINE 746 IN MAIN.asm
                    > USED AT LINE 776 IN MAIN.asm
                    > USED AT LINE 780 IN MAIN.asm
                    > USED AT LINE 785 IN MAIN.asm
SEARCHSTR1:         03EC DEFINED AT LINE 675 IN MAIN.asm
                    > USED AT LINE 701 IN MAIN.asm
SEARCHSTR3:         03F8 DEFINED AT LINE 686 IN MAIN.asm
SEARCHOPCODE:       040C DEFINED AT LINE 724 IN MAIN.asm
                    > USED AT LINE 449 IN MAIN.asm
SEARCHOPELEM:       0439 DEFINED AT LINE 774 IN MAIN.asm
                    > USED AT LINE 457 IN MAIN.asm
COMPARESTR:         0452 DEFINED AT LINE 809 IN MAIN.asm
                    > USED AT LINE 678 IN MAIN.asm
                    > USED AT LINE 83 IN test.lib.asm
COMPARESTR2:        0455 DEFINED AT LINE 814 IN MAIN.asm
                    > USED AT LINE 820 IN MAIN.asm
COMPARESTR3:        045C DEFINED AT LINE 822 IN MAIN.asm
ISENDOFEXPR:        045D DEFINED AT LINE 825 IN MAIN.asm
ISINDEXREG:         0462 DEFINED AT LINE 847 IN MAIN.asm
                    > USED AT LINE 236 IN MAIN.asm
ISALPHANUM:         0468 DEFINED AT LINE 873 IN MAIN.asm
                    > USED AT LINE 482 IN MAIN.asm
                    > USED AT LINE 575 IN MAIN.asm
ISALPHA:            046C DEFINED AT LINE 897 IN MAIN.asm
                    > USED AT LINE 436 IN MAIN.asm
ISALPHA1:           0472 DEFINED AT LINE 901 IN MAIN.asm
                    > USED AT LINE 899 IN MAIN.asm
ISDIGIT:            0479 DEFINED AT LINE 925 IN MAIN.asm
                    > USED AT LINE 496 IN MAIN.asm
                    > USED AT LINE 874 IN MAIN.asm
NUMBER:             0480 DEFINED AT LINE 949 IN MAIN.asm
                    > USED AT LINE 500 IN MAIN.asm
NUMBER1:            0487 DEFINED AT LINE 954 IN MAIN.asm
                    > USED AT LINE 952 IN MAIN.asm
NUMBER2:            0496 DEFINED AT LINE 961 IN MAIN.asm
                    > USED AT LINE 958 IN MAIN.asm
NUMBER3:            049C DEFINED AT LINE 964 IN MAIN.asm
                    > USED AT LINE 960 IN MAIN.asm
                    > USED AT LINE 980 IN MAIN.asm
NUMBER_HEX:         04AC DEFINED AT LINE 975 IN MAIN.asm
                    > USED AT LINE 484 IN MAIN.asm
HEX:                04B8 DEFINED AT LINE 998 IN MAIN.asm
                    > USED AT LINE 959 IN MAIN.asm
                    > USED AT LINE 979 IN MAIN.asm
HEX1:               04BB DEFINED AT LINE 1000 IN MAIN.asm
                    > USED AT LINE 1027 IN MAIN.asm
HEX2:               04CB DEFINED AT LINE 1009 IN MAIN.asm
                    > USED AT LINE 1007 IN MAIN.asm
UPPER:              04D2 DEFINED AT LINE 1014 IN MAIN.asm
                    > USED AT LINE 1013 IN MAIN.asm
VALID:              04D4 DEFINED AT LINE 1016 IN MAIN.asm
                    > USED AT LINE 1005 IN MAIN.asm
DECIMAL:            04E3 DEFINED AT LINE 1045 IN MAIN.asm
                    > USED AT LINE 963 IN MAIN.asm
DECIMAL1:           04E6 DEFINED AT LINE 1047 IN MAIN.asm
                    > USED AT LINE 1064 IN MAIN.asm
NEXTCHAR:           04FE DEFINED AT LINE 1083 IN MAIN.asm
                    > USED AT LINE 403 IN MAIN.asm
                    > USED AT LINE 427 IN MAIN.asm
                    > USED AT LINE 481 IN MAIN.asm
                    > USED AT LINE 571 IN MAIN.asm
                    > USED AT LINE 956 IN MAIN.asm
                    > USED AT LINE 1001 IN MAIN.asm
                    > USED AT LINE 1048 IN MAIN.asm
                    > USED AT LINE 1159 IN MAIN.asm
NEXTLINE:           0515 DEFINED AT LINE 1099 IN MAIN.asm
                    > USED AT LINE 1087 IN MAIN.asm
NEXTLINE1:          051A DEFINED AT LINE 1103 IN MAIN.asm
                    > USED AT LINE 1121 IN MAIN.asm
                    > USED AT LINE 1127 IN MAIN.asm
                    > USED AT LINE 1154 IN MAIN.asm
NEXTLINE2:          0528 DEFINED AT LINE 1112 IN MAIN.asm
                    > USED AT LINE 1108 IN MAIN.asm
NEXTLINE3:          052C DEFINED AT LINE 1116 IN MAIN.asm
                    > USED AT LINE 1110 IN MAIN.asm
NEXTLINE4:          0540 DEFINED AT LINE 1129 IN MAIN.asm
                    > USED AT LINE 1118 IN MAIN.asm
NEXTLINE5:          054B DEFINED AT LINE 1137 IN MAIN.asm
                    > USED AT LINE 1133 IN MAIN.asm
NEXTLINE5A:         0553 DEFINED AT LINE 1143 IN MAIN.asm
                    > USED AT LINE 1106 IN MAIN.asm
                    > USED AT LINE 1114 IN MAIN.asm
NEXTLINE6:          0556 DEFINED AT LINE 1147 IN MAIN.asm
                    > USED AT LINE 1135 IN MAIN.asm
                    > USED AT LINE 1139 IN MAIN.asm
                    > USED AT LINE 1141 IN MAIN.asm
NEXTLINE7:          0562 DEFINED AT LINE 1156 IN MAIN.asm
                    > USED AT LINE 1151 IN MAIN.asm
                    > USED AT LINE 1153 IN MAIN.asm
REWINDCHAR:         0569 DEFINED AT LINE 1178 IN MAIN.asm
                    > USED AT LINE 430 IN MAIN.asm
                    > USED AT LINE 447 IN MAIN.asm
                    > USED AT LINE 489 IN MAIN.asm
                    > USED AT LINE 962 IN MAIN.asm
                    > USED AT LINE 972 IN MAIN.asm
                    > USED AT LINE 976 IN MAIN.asm
PROMPT:             0571 DEFINED AT LINE 1202 IN MAIN.asm
CRLF:               057A DEFINED AT LINE 1223 IN MAIN.asm
ERROR:              0581 DEFINED AT LINE 1244 IN MAIN.asm
PRINT:              0586 DEFINED AT LINE 1265 IN MAIN.asm
                    > USED AT LINE 40 IN MAIN.asm
                    > USED AT LINE 97 IN MAIN.asm
                    > USED AT LINE 1125 IN MAIN.asm
                    > USED AT LINE 1203 IN MAIN.asm
                    > USED AT LINE 1224 IN MAIN.asm
                    > USED AT LINE 39
                    > USED AT LINE 88 IN test.lib.asm
                    > USED AT LINE 114 IN test.lib.asm
                    > USED AT LINE 119 IN test.lib.asm
                    > USED AT LINE 124 IN test.lib.asm
                    > USED AT LINE 131 IN test.lib.asm
PRINTSTR:           058D DEFINED AT LINE 1288 IN MAIN.asm
                    > USED AT LINE 1246 IN MAIN.asm
PRINTSTR1:          0592 DEFINED AT LINE 1294 IN MAIN.asm
                    > USED AT LINE 1298 IN MAIN.asm
PRINTZSTR:          059A DEFINED AT LINE 1317 IN MAIN.asm
                    > USED AT LINE 1267 IN MAIN.asm
                    > USED AT LINE 91 IN test.lib.asm
PRINTZSTR1:         059C DEFINED AT LINE 1320 IN MAIN.asm
                    > USED AT LINE 1327 IN MAIN.asm
PRINTZSTR2:         05A0 DEFINED AT LINE 1324 IN MAIN.asm
                    > USED AT LINE 1318 IN MAIN.asm
HPUSH:              05A5 DEFINED AT LINE 1346 IN MAIN.asm
                    > USED AT LINE 285 IN MAIN.asm
                    > USED AT LINE 287 IN MAIN.asm
                    > USED AT LINE 288 IN MAIN.asm
                    > USED AT LINE 296 IN MAIN.asm
                    > USED AT LINE 298 IN MAIN.asm
                    > USED AT LINE 326 IN MAIN.asm
                    > USED AT LINE 352 IN MAIN.asm
                    > USED AT LINE 355 IN MAIN.asm
                    > USED AT LINE 357 IN MAIN.asm
ROT_OPCODES:        05B3 DEFINED AT LINE 1 IN data.asm
                    > USED AT LINE 729 IN MAIN.asm
ALU_OPCODES:        05D2 DEFINED AT LINE 13 IN data.asm
                    > USED AT LINE 725 IN MAIN.asm
BLI_OPCODES:        05F1 DEFINED AT LINE 25 IN data.asm
                    > USED AT LINE 734 IN MAIN.asm
GEN1_OPCODES:       063C DEFINED AT LINE 45 IN data.asm
                    > USED AT LINE 739 IN MAIN.asm
GEN2_OPCODES:       0665 DEFINED AT LINE 59 IN data.asm
                    > USED AT LINE 745 IN MAIN.asm
REG8:               06CE DEFINED AT LINE 89 IN data.asm
                    > USED AT LINE 775 IN MAIN.asm
REG16:              06E3 DEFINED AT LINE 103 IN data.asm
                    > USED AT LINE 779 IN MAIN.asm
FLAGS:              06FD DEFINED AT LINE 115 IN data.asm
                    > USED AT LINE 784 IN MAIN.asm
DIRECTIVES:         0712 DEFINED AT LINE 127 IN data.asm
                    > USED AT LINE 465 IN MAIN.asm
BUFFER:             3000 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 69 IN MAIN.asm
                    > USED AT LINE 1088 IN MAIN.asm
                    > USED AT LINE 1100 IN MAIN.asm
STACK:              3180 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 458 IN IOSerial.asm
                    > USED AT LINE 38 IN MAIN.asm
                    > USED AT LINE 15
VTEMP1:             3180 DEFINED AT LINE 9 IN ram.asm
                    > USED AT LINE 955 IN MAIN.asm
                    > USED AT LINE 965 IN MAIN.asm
                    > USED AT LINE 978 IN MAIN.asm
VTEMP2:             3182 DEFINED AT LINE 10 IN ram.asm
VTOKEN:             3184 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 66 IN MAIN.asm
                    > USED AT LINE 391 IN MAIN.asm
                    > USED AT LINE 393 IN MAIN.asm
                    > USED AT LINE 396 IN MAIN.asm
                    > USED AT LINE 536 IN MAIN.asm
VTOKENVAL:          3185 DEFINED AT LINE 13 IN ram.asm
                    > USED AT LINE 62 IN MAIN.asm
                    > USED AT LINE 394 IN MAIN.asm
                    > USED AT LINE 537 IN MAIN.asm
VBUFFERPOS:         3187 DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 67 IN MAIN.asm
                    > USED AT LINE 1084 IN MAIN.asm
                    > USED AT LINE 1157 IN MAIN.asm
                    > USED AT LINE 1179 IN MAIN.asm
VASMPTR:            3189 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 73 IN MAIN.asm
                    > USED AT LINE 164 IN MAIN.asm
VSTRPTR:            318B DEFINED AT LINE 16 IN ram.asm
                    > USED AT LINE 75 IN MAIN.asm
                    > USED AT LINE 448 IN MAIN.asm
                    > USED AT LINE 564 IN MAIN.asm
                    > USED AT LINE 578 IN MAIN.asm
VSYMPTR:            318D DEFINED AT LINE 17 IN ram.asm
                    > USED AT LINE 63 IN MAIN.asm
                    > USED AT LINE 351 IN MAIN.asm
                    > USED AT LINE 353 IN MAIN.asm
VEXPRPTR:           318F DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 64 IN MAIN.asm
                    > USED AT LINE 284 IN MAIN.asm
                    > USED AT LINE 289 IN MAIN.asm
VHEAPPTR:           3191 DEFINED AT LINE 19 IN ram.asm
                    > USED AT LINE 71 IN MAIN.asm
                    > USED AT LINE 283 IN MAIN.asm
                    > USED AT LINE 350 IN MAIN.asm
                    > USED AT LINE 1349 IN MAIN.asm
                    > USED AT LINE 1354 IN MAIN.asm
VOPCODE:            3193 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 152 IN MAIN.asm
                    > USED AT LINE 177 IN MAIN.asm
                    > USED AT LINE 96 IN test.lib.asm
VOPERAND1:          3194 DEFINED AT LINE 22 IN ram.asm
                    > USED AT LINE 153 IN MAIN.asm
                    > USED AT LINE 180 IN MAIN.asm
                    > USED AT LINE 101 IN test.lib.asm
VOPERAND2:          3195 DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 154 IN MAIN.asm
                    > USED AT LINE 186 IN MAIN.asm
                    > USED AT LINE 106 IN test.lib.asm
VOPEXPR:            3196 DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 156 IN MAIN.asm
                    > USED AT LINE 226 IN MAIN.asm
                    > USED AT LINE 250 IN MAIN.asm
VOPDISP:            3198 DEFINED AT LINE 25 IN ram.asm
                    > USED AT LINE 157 IN MAIN.asm
                    > USED AT LINE 240 IN MAIN.asm
RST08:              319A DEFINED AT LINE 28 IN ram.asm
                    > USED AT LINE 118 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
RST10:              319C DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 124 IN IOSerial.asm
                    > USED AT LINE 461 IN IOSerial.asm
RST18:              319E DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 130 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RST20:              31A0 DEFINED AT LINE 31 IN ram.asm
                    > USED AT LINE 136 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
RST28:              31A2 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
RST30:              31A4 DEFINED AT LINE 33 IN ram.asm
                    > USED AT LINE 148 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
BAUD:               31A6 DEFINED AT LINE 34 IN ram.asm
INTVEC:             31A8 DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 154 IN IOSerial.asm
                    > USED AT LINE 466 IN IOSerial.asm
NMIVEC:             31AA DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 202 IN IOSerial.asm
                    > USED AT LINE 467 IN IOSerial.asm
GETCVEC:            31AC DEFINED AT LINE 37 IN ram.asm
                    > USED AT LINE 447 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
                    > USED AT LINE 60 IN test.lib.asm
PUTCVEC:            31AE DEFINED AT LINE 38 IN ram.asm
                    > USED AT LINE 453 IN IOSerial.asm
                    > USED AT LINE 472 IN IOSerial.asm
STRINGS:            31B0 DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 74 IN MAIN.asm
HEAP:               32B0 DEFINED AT LINE 41 IN ram.asm
                    > USED AT LINE 70 IN MAIN.asm
ASSEMBLY:           33B0 DEFINED AT LINE 42 IN ram.asm
                    > USED AT LINE 72 IN MAIN.asm
                    > USED AT LINE 82 IN test.lib.asm
TESTSSTART:         4000 DEFINED AT LINE 14
                    > USED AT LINE 6
TBDESC:             4041 DEFINED AT LINE 5 IN test.lib.asm
                    > USED AT LINE 30 IN test.lib.asm
TBTEXT:             4043 DEFINED AT LINE 7 IN test.lib.asm
                    > USED AT LINE 53 IN test.lib.asm
                    > USED AT LINE 90 IN test.lib.asm
TBPTR:              4045 DEFINED AT LINE 9 IN test.lib.asm
                    > USED AT LINE 54 IN test.lib.asm
                    > USED AT LINE 155 IN test.lib.asm
                    > USED AT LINE 158 IN test.lib.asm
DESCRIBE:           4047 DEFINED AT LINE 28 IN test.lib.asm
                    > USED AT LINE 26
TEST:               4050 DEFINED AT LINE 51 IN test.lib.asm
                    > USED AT LINE 29
EXPECT:             4068 DEFINED AT LINE 80 IN test.lib.asm
EXPECT1:            4072 DEFINED AT LINE 87 IN test.lib.asm
                    > USED AT LINE 84 IN test.lib.asm
EXPECTCODE:         4084 DEFINED AT LINE 94 IN test.lib.asm
                    > USED AT LINE 33
EXPECTCODE1:        409E DEFINED AT LINE 113 IN test.lib.asm
                    > USED AT LINE 99 IN test.lib.asm
EXPECTCODE2:        40BB DEFINED AT LINE 118 IN test.lib.asm
                    > USED AT LINE 104 IN test.lib.asm
EXPECTCODE3:        40DB DEFINED AT LINE 123 IN test.lib.asm
                    > USED AT LINE 109 IN test.lib.asm
EXPECTCODE4:        40FB DEFINED AT LINE 128 IN test.lib.asm
                    > USED AT LINE 116 IN test.lib.asm
                    > USED AT LINE 121 IN test.lib.asm
                    > USED AT LINE 126 IN test.lib.asm
TESTGETCHARIMPL:    4110 DEFINED AT LINE 153 IN test.lib.asm
                    > USED AT LINE 59 IN test.lib.asm
PRINTHEX:           411B DEFINED AT LINE 178 IN test.lib.asm
                    > USED AT LINE 129 IN test.lib.asm
                    > USED AT LINE 133 IN test.lib.asm
PRINTHEX2:          4126 DEFINED AT LINE 187 IN test.lib.asm
                    > USED AT LINE 181 IN test.lib.asm
                    > USED AT LINE 183 IN test.lib.asm
PRINTHEX3:          412F DEFINED AT LINE 196 IN test.lib.asm
                    > USED AT LINE 193 IN test.lib.asm
SKIPZSTR:           413A DEFINED AT LINE 221 IN test.lib.asm
                    > USED AT LINE 31 IN test.lib.asm
                    > USED AT LINE 55 IN test.lib.asm
SKIPZSTR1:          413C DEFINED AT LINE 224 IN test.lib.asm
                    > USED AT LINE 230 IN test.lib.asm
SKIPZSTR2:          413D DEFINED AT LINE 227 IN test.lib.asm
                    > USED AT LINE 222 IN test.lib.asm
